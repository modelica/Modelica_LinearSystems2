<HTML>
<HEAD>
<TITLE>Modelica_LinearSystems2.Math.Matrices.LAPACK</TITLE>
<META name="HTML-Generator" content="Dymola">
<style type="text/css">
*       { font-size: 10pt; font-family: Arial,sans-serif; }
pre     { font-size:  9pt; font-family: Courier,monospace;}
h4      { font-size: 10pt; font-weight: bold; color: green; }
h3      { font-size: 11pt; font-weight: bold; color: green; }
h2      { font-size: 13pt; font-weight: bold; color: green; }
address {                  font-weight: normal} 
td      { solid #000; vertical-align:top; }
th      { solid #000; vertical-align:top; font-weight: bold; }
table   { solid #000; border-collapse: collapse;}
</style>
</HEAD>
<BODY><P>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE LAPACK<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.LAPACK"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.LAPACK</H2>
<P><H3>Package Content</H3><p>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2 >
<TR><TH >Name</TH><TH>Description</TH></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgeevS.png" ALT="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgeev" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dgeev"
>dgeev</A>
</TD><TD>Compute the eigenvalues and the (real) left and right eigenvectors of matrix A, using lapack routine dgeev </TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgeevS.png" ALT="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgeevx" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dgeevx"
>dgeevx</A>
</TD><TD>Compute the eigenvalues and the (real) left and right eigenvectors of matrix A, using lapack routine dgeevx </TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgeevS.png" ALT="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgegv" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dgegv"
>dgegv</A>
</TD><TD>Compute generalized eigenvalues for a (A,B) system</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgeevS.png" ALT="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgehrd" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dgehrd"
>dgehrd</A>
</TD><TD>reduces a real general matrix A to upper Hessenberg form H by an orthogonal similarity transformation:  Q&#39; * A * Q = H</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgeevS.png" ALT="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgeqp3" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dgeqp3"
>dgeqp3</A>
</TD><TD>computes a QR factorization with column pivoting</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgeevS.png" ALT="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgeqrf" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dgeqrf"
>dgeqrf</A>
</TD><TD>computes a QR factorization without pivoting</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgesddS.png" ALT="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgesdd" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dgesdd"
>dgesdd</A>
</TD><TD>Determine singular value decomposition</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgesddS.png" ALT="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgesvd" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dgesvd"
>dgesvd</A>
</TD><TD>Determine singular value decomposition</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgesddS.png" ALT="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgesvx" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dgesvx"
>dgesvx</A>
</TD><TD>Solve real system of linear equations A**T*X=B with a B matrix with LAPACK routine DGESVX</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgetrsS.png" ALT="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgetrs" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dgetrs"
>dgetrs</A>
</TD><TD>Solves a system of linear equations with the LU decomposition from dgetrf(..)</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgetrsS.png" ALT="Modelica_LinearSystems2.Math.Matrices.LAPACK.dggev" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dggev"
>dggev</A>
</TD><TD>Compute generalized eigenvalues for a (A,B) system</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgetrsS.png" ALT="Modelica_LinearSystems2.Math.Matrices.LAPACK.dggevx" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dggevx"
>dggevx</A>
</TD><TD>Compute generalized eigenvalues for a (A,B) system, using lapack routine dggevx</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgetrsS.png" ALT="Modelica_LinearSystems2.Math.Matrices.LAPACK.dhgeqz" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dhgeqz"
>dhgeqz</A>
</TD><TD>Compute generalized eigenvalues for a (A,B) system</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgetrsS.png" ALT="Modelica_LinearSystems2.Math.Matrices.LAPACK.dhseqr" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dhseqr"
>dhseqr</A>
</TD><TD>compute eingenvalues of a matrix A using lapack routine DHSEQR for Hessenberg form matrix</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgetrsS.png" ALT="Modelica_LinearSystems2.Math.Matrices.LAPACK.dorghr" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dorghr"
>dorghr</A>
</TD><TD>generates a real orthogonal matrix Q which is defined as the product of IHI-ILO elementary reflectors of order N, as returned by DGEHRD</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgetrsS.png" ALT="Modelica_LinearSystems2.Math.Matrices.LAPACK.dorgqr" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dorgqr"
>dorgqr</A>
</TD><TD>generates a real orthogonal matrix Q which is defined as the product of elementary reflectors, as returned by DGEQRF</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgetrsS.png" ALT="Modelica_LinearSystems2.Math.Matrices.LAPACK.dorgqr_x" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dorgqr_x"
>dorgqr_x</A>
</TD><TD>generates a real orthogonal matrix Q which is defined as the product of elementary reflectors, as returned by DGEQRF</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgetrsS.png" ALT="Modelica_LinearSystems2.Math.Matrices.LAPACK.dormhr" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dormhr"
>dormhr</A>
</TD><TD>overwrites the general real M-by-N matrix C with Q * C or C * Q or Q&#39; * C or C * Q&#39;, where Q is an orthogonal matrix as returne by dgehrd</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgetrsS.png" ALT="Modelica_LinearSystems2.Math.Matrices.LAPACK.dormqr" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dormqr"
>dormqr</A>
</TD><TD>overwrites the general real M-by-N matrix C with Q * C or C * Q or Q&#39; * C or C * Q&#39;, where Q is an orthogonal matrix of a QR factorization as returned by dgeqrf</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgetrsS.png" ALT="Modelica_LinearSystems2.Math.Matrices.LAPACK.dtrevc" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dtrevc"
>dtrevc</A>
</TD><TD>compute the right and/or left eigenvectors of a real upper quasi-triangular matrix T</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgetrsS.png" ALT="Modelica_LinearSystems2.Math.Matrices.LAPACK.dtrsen" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dtrsen"
>dtrsen</A>
</TD><TD>DTRSEN reorders the real Schur factorization of a real matrix</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE dgeev<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgeev"></A><A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</A>.dgeev</H2>
<B>Compute the eigenvalues and the (real) left and right eigenvectors of matrix A, using lapack routine dgeev </B><p>
<P><H3>Information</H3></P>
<PRE>   Purpose  
   =======  
 
   DGEEV computes for an N-by-N real nonsymmetric matrix A, the  
   eigenvalues and, optionally, the left and/or right eigenvectors.  
 
   The right eigenvector v(j) of A satisfies  
                    A * v(j) = lambda(j) * v(j)  
   where lambda(j) is its eigenvalue.  
   The left eigenvector u(j) of A satisfies  
                 u(j)**H * A = lambda(j) * u(j)**H  
   where u(j)**H denotes the conjugate transpose of u(j).  
 
   The computed eigenvectors are normalized to have Euclidean norm  
   equal to 1 and largest component real.  
 
   Arguments  
   =========  
 
   JOBVL   (input) CHARACTER*1  
           = &#39;N&#39;: left eigenvectors of A are not computed;  
           = &#39;V&#39;: left eigenvectors of A are computed.  
 
   JOBVR   (input) CHARACTER*1  
           = &#39;N&#39;: right eigenvectors of A are not computed;  
           = &#39;V&#39;: right eigenvectors of A are computed.  
 
   N       (input) INTEGER  
           The order of the matrix A. N &gt;= 0.  
 
   A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)  
           On entry, the N-by-N matrix A.  
           On exit, A has been overwritten.  
 
   LDA     (input) INTEGER  
           The leading dimension of the array A.  LDA &gt;= max(1,N).  
 
   WR      (output) DOUBLE PRECISION array, dimension (N)  
   WI      (output) DOUBLE PRECISION array, dimension (N)  
           WR and WI contain the real and imaginary parts,  
           respectively, of the computed eigenvalues.  Complex  
           conjugate pairs of eigenvalues appear consecutively  
           with the eigenvalue having the positive imaginary part  
           first.  
 
   VL      (output) DOUBLE PRECISION array, dimension (LDVL,N)  
           If JOBVL = &#39;V&#39;, the left eigenvectors u(j) are stored one  
           after another in the columns of VL, in the same order  
           as their eigenvalues.  
           If JOBVL = &#39;N&#39;, VL is not referenced.  
           If the j-th eigenvalue is real, then u(j) = VL(:,j),  
           the j-th column of VL.  
           If the j-th and (j+1)-st eigenvalues form a complex  
           conjugate pair, then u(j) = VL(:,j) + i*VL(:,j+1) and  
           u(j+1) = VL(:,j) - i*VL(:,j+1).  
 
   LDVL    (input) INTEGER  
           The leading dimension of the array VL.  LDVL &gt;= 1; if  
           JOBVL = &#39;V&#39;, LDVL &gt;= N.  
 
   VR      (output) DOUBLE PRECISION array, dimension (LDVR,N)  
           If JOBVR = &#39;V&#39;, the right eigenvectors v(j) are stored one  
           after another in the columns of VR, in the same order  
           as their eigenvalues.  
           If JOBVR = &#39;N&#39;, VR is not referenced.  
           If the j-th eigenvalue is real, then v(j) = VR(:,j),  
           the j-th column of VR.  
           If the j-th and (j+1)-st eigenvalues form a complex  
           conjugate pair, then v(j) = VR(:,j) + i*VR(:,j+1) and  
           v(j+1) = VR(:,j) - i*VR(:,j+1).  
 
   LDVR    (input) INTEGER  
           The leading dimension of the array VR.  LDVR &gt;= 1; if  
           JOBVR = &#39;V&#39;, LDVR &gt;= N.  
 
   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)  
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.  
 
   LWORK   (input) INTEGER  
           The dimension of the array WORK.  LWORK &gt;= max(1,3*N), and  
           if JOBVL = &#39;V&#39; or JOBVR = &#39;V&#39;, LWORK &gt;= 4*N.  For good  
           performance, LWORK must generally be larger.  
 
           If LWORK = -1, then a workspace query is assumed; the routine  
           only calculates the optimal size of the WORK array, returns  
           this value as the first entry of the WORK array, and no error  
           message related to LWORK is issued by XERBLA.  
 
   INFO    (output) INTEGER  
           = 0:  successful exit  
           &lt; 0:  if INFO = -i, the i-th argument had an illegal value.  
           &gt; 0:  if INFO = i, the QR algorithm failed to compute all the  
                 eigenvalues, and no eigenvectors have been computed;  
                 elements i+1:N of WR and WI contain eigenvalues which  
                 have converged.  
 
   =====================================================================  
</PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>alphaReal[size(A, 1)]</TD><TD>Real part of alpha (eigenvalue=(alphaReal+i*alphaImag))</TD></TR>
<TR><TD>alphaImag[size(A, 1)]</TD><TD>Imaginary part of alpha (eigenvalue=(alphaReal+i*alphaImag))</TD></TR>
<TR><TD>lEigenVectors[size(A, 1), size(A, 1)]</TD><TD>left eigenvectors of matrix A</TD></TR>
<TR><TD>rEigenVectors[size(A, 1), size(A, 1)]</TD><TD>right eigenvectors of matrix A</TD></TR>
<TR><TD>info</TD><TD>&nbsp;</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE dgeevx<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgeevx"></A><A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</A>.dgeevx</H2>
<B>Compute the eigenvalues and the (real) left and right eigenvectors of matrix A, using lapack routine dgeevx </B><p>
<P><H3>Information</H3></P>
<PRE>   Purpose  
   =======  
 
   DGEEVX computes for an N-by-N real nonsymmetric matrix A, the  
   eigenvalues and, optionally, the left and/or right eigenvectors.  
 
   Optionally also, it computes a balancing transformation to improve  
   the conditioning of the eigenvalues and eigenvectors (ILO, IHI,  
   SCALE, and ABNRM), reciprocal condition numbers for the eigenvalues  
   (RCONDE), and reciprocal condition numbers for the right  
   eigenvectors (RCONDV).  
 
   The right eigenvector v(j) of A satisfies  
                    A * v(j) = lambda(j) * v(j)  
   where lambda(j) is its eigenvalue.  
   The left eigenvector u(j) of A satisfies  
                 u(j)**H * A = lambda(j) * u(j)**H  
   where u(j)**H denotes the conjugate transpose of u(j).  
 
   The computed eigenvectors are normalized to have Euclidean norm  
   equal to 1 and largest component real.  
 
   Balancing a matrix means permuting the rows and columns to make it  
   more nearly upper triangular, and applying a diagonal similarity  
   transformation D * A * D**(-1), where D is a diagonal matrix, to  
   make its rows and columns closer in norm and the condition numbers  
   of its eigenvalues and eigenvectors smaller.  The computed  
   reciprocal condition numbers correspond to the balanced matrix.  
   Permuting rows and columns will not change the condition numbers  
   (in exact arithmetic) but diagonal scaling will.  For further  
   explanation of balancing, see section 4.10.2 of the LAPACK  
   Users&#39; Guide.  
 
   Arguments  
   =========  
 
   BALANC  (input) CHARACTER*1  
           Indicates how the input matrix should be diagonally scaled  
           and/or permuted to improve the conditioning of its  
           eigenvalues.  
           = &#39;N&#39;: Do not diagonally scale or permute;  
           = &#39;P&#39;: Perform permutations to make the matrix more nearly  
                  upper triangular. Do not diagonally scale;  
           = &#39;S&#39;: Diagonally scale the matrix, i.e. replace A by  
                  D*A*D**(-1), where D is a diagonal matrix chosen  
                  to make the rows and columns of A more equal in  
                  norm. Do not permute;  
           = &#39;B&#39;: Both diagonally scale and permute A.  
 
           Computed reciprocal condition numbers will be for the matrix  
           after balancing and/or permuting. Permuting does not change  
           condition numbers (in exact arithmetic), but balancing does.  
 
   JOBVL   (input) CHARACTER*1  
           = &#39;N&#39;: left eigenvectors of A are not computed;  
           = &#39;V&#39;: left eigenvectors of A are computed.  
           If SENSE = &#39;E&#39; or &#39;B&#39;, JOBVL must = &#39;V&#39;.  
 
   JOBVR   (input) CHARACTER*1  
           = &#39;N&#39;: right eigenvectors of A are not computed;  
           = &#39;V&#39;: right eigenvectors of A are computed.  
           If SENSE = &#39;E&#39; or &#39;B&#39;, JOBVR must = &#39;V&#39;.  
 
   SENSE   (input) CHARACTER*1  
           Determines which reciprocal condition numbers are computed.  
           = &#39;N&#39;: None are computed;  
           = &#39;E&#39;: Computed for eigenvalues only;  
           = &#39;V&#39;: Computed for right eigenvectors only;  
           = &#39;B&#39;: Computed for eigenvalues and right eigenvectors.  
 
           If SENSE = &#39;E&#39; or &#39;B&#39;, both left and right eigenvectors  
           must also be computed (JOBVL = &#39;V&#39; and JOBVR = &#39;V&#39;).  
 
   N       (input) INTEGER  
           The order of the matrix A. N &gt;= 0.  
 
   A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)  
           On entry, the N-by-N matrix A.  
           On exit, A has been overwritten.  If JOBVL = &#39;V&#39; or  
           JOBVR = &#39;V&#39;, A contains the real Schur form of the balanced  
           version of the input matrix A.  
 
   LDA     (input) INTEGER  
           The leading dimension of the array A.  LDA &gt;= max(1,N).  
 
   WR      (output) DOUBLE PRECISION array, dimension (N)  
   WI      (output) DOUBLE PRECISION array, dimension (N)  
           WR and WI contain the real and imaginary parts,  
           respectively, of the computed eigenvalues.  Complex  
           conjugate pairs of eigenvalues will appear consecutively  
           with the eigenvalue having the positive imaginary part  
           first.  
 
   VL      (output) DOUBLE PRECISION array, dimension (LDVL,N)  
           If JOBVL = &#39;V&#39;, the left eigenvectors u(j) are stored one  
           after another in the columns of VL, in the same order  
           as their eigenvalues.  
           If JOBVL = &#39;N&#39;, VL is not referenced.  
           If the j-th eigenvalue is real, then u(j) = VL(:,j),  
           the j-th column of VL.  
           If the j-th and (j+1)-st eigenvalues form a complex  
           conjugate pair, then u(j) = VL(:,j) + i*VL(:,j+1) and  
           u(j+1) = VL(:,j) - i*VL(:,j+1).  
 
   LDVL    (input) INTEGER  
           The leading dimension of the array VL.  LDVL &gt;= 1; if  
           JOBVL = &#39;V&#39;, LDVL &gt;= N.  
 
   VR      (output) DOUBLE PRECISION array, dimension (LDVR,N)  
           If JOBVR = &#39;V&#39;, the right eigenvectors v(j) are stored one  
           after another in the columns of VR, in the same order  
           as their eigenvalues.  
           If JOBVR = &#39;N&#39;, VR is not referenced.  
           If the j-th eigenvalue is real, then v(j) = VR(:,j),  
           the j-th column of VR.  
           If the j-th and (j+1)-st eigenvalues form a complex  
           conjugate pair, then v(j) = VR(:,j) + i*VR(:,j+1) and  
           v(j+1) = VR(:,j) - i*VR(:,j+1).  
 
   LDVR    (input) INTEGER  
           The leading dimension of the array VR.  LDVR &gt;= 1, and if  
           JOBVR = &#39;V&#39;, LDVR &gt;= N.  
 
   ILO,IHI (output) INTEGER  
           ILO and IHI are integer values determined when A was  
           balanced.  The balanced A(i,j) = 0 if I &gt; J and  
           J = 1,...,ILO-1 or I = IHI+1,...,N.  
 
   SCALE   (output) DOUBLE PRECISION array, dimension (N)  
           Details of the permutations and scaling factors applied  
           when balancing A.  If P(j) is the index of the row and column  
           interchanged with row and column j, and D(j) is the scaling  
           factor applied to row and column j, then  
           SCALE(J) = P(J),    for J = 1,...,ILO-1  
                    = D(J),    for J = ILO,...,IHI  
                    = P(J)     for J = IHI+1,...,N.  
           The order in which the interchanges are made is N to IHI+1,  
           then 1 to ILO-1.  
 
   ABNRM   (output) DOUBLE PRECISION  
           The one-norm of the balanced matrix (the maximum  
           of the sum of absolute values of elements of any column).  
 
   RCONDE  (output) DOUBLE PRECISION array, dimension (N)  
           RCONDE(j) is the reciprocal condition number of the j-th  
           eigenvalue.  
 
   RCONDV  (output) DOUBLE PRECISION array, dimension (N)  
           RCONDV(j) is the reciprocal condition number of the j-th  
           right eigenvector.  
 
   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)  
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.  
 
   LWORK   (input) INTEGER  
           The dimension of the array WORK.   If SENSE = &#39;N&#39; or &#39;E&#39;,  
           LWORK &gt;= max(1,2*N), and if JOBVL = &#39;V&#39; or JOBVR = &#39;V&#39;,  
           LWORK &gt;= 3*N.  If SENSE = &#39;V&#39; or &#39;B&#39;, LWORK &gt;= N*(N+6).  
           For good performance, LWORK must generally be larger.  
 
           If LWORK = -1, then a workspace query is assumed; the routine  
           only calculates the optimal size of the WORK array, returns  
           this value as the first entry of the WORK array, and no error  
           message related to LWORK is issued by XERBLA.  
 
   IWORK   (workspace) INTEGER array, dimension (2*N-2)  
           If SENSE = &#39;N&#39; or &#39;E&#39;, not referenced.  
 
   INFO    (output) INTEGER  
           = 0:  successful exit  
           &lt; 0:  if INFO = -i, the i-th argument had an illegal value.  
           &gt; 0:  if INFO = i, the QR algorithm failed to compute all the  
                 eigenvalues, and no eigenvectors or condition numbers  
                 have been computed; elements 1:ILO-1 and i+1:N of WR  
                 and WI contain eigenvalues which have converged.  
 
   =====================================================================  
</PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>alphaReal[size(A, 1)]</TD><TD>Real part of alpha (eigenvalue=(alphaReal+i*alphaImag))</TD></TR>
<TR><TD>alphaImag[size(A, 1)]</TD><TD>Imaginary part of alpha (eigenvalue=(alphaReal+i*alphaImag))</TD></TR>
<TR><TD>lEigenVectors[size(A, 1), size(A, 1)]</TD><TD>left eigenvectors of matrix A</TD></TR>
<TR><TD>rEigenVectors[size(A, 1), size(A, 1)]</TD><TD>right eigenvectors of matrix A</TD></TR>
<TR><TD>AS[size(A, 1), size(A, 2)]</TD><TD>AS iss the real Schur form of the balanced version of the input matrix A</TD></TR>
<TR><TD>info</TD><TD>&nbsp;</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE dgegv<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgegv"></A><A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</A>.dgegv</H2>
<B>Compute generalized eigenvalues for a (A,B) system</B><p>
<P><H3>Information</H3></P>
<PRE>   Purpose  
   =======  
 
   This routine is deprecated and has been replaced by routine DGGEV.  
 
   DGEGV computes for a pair of n-by-n real nonsymmetric matrices A and  
   B, the generalized eigenvalues (alphar +/- alphai*i, beta), and  
   optionally, the left and/or right generalized eigenvectors (VL and  
   VR).  
 
   A generalized eigenvalue for a pair of matrices (A,B) is, roughly  
   speaking, a scalar w or a ratio  alpha/beta = w, such that  A - w*B  
   is singular.  It is usually represented as the pair (alpha,beta),  
   as there is a reasonable interpretation for beta=0, and even for  
   both being zero.  A good beginning reference is the book, &quot;Matrix  
   Computations&quot;, by G. Golub &amp; C. van Loan (Johns Hopkins U. Press)  
 
   A right generalized eigenvector corresponding to a generalized  
   eigenvalue  w  for a pair of matrices (A,B) is a vector  r  such  
   that  (A - w B) r = 0 .  A left generalized eigenvector is a vector  
   l such that l**H * (A - w B) = 0, where l**H is the  
   conjugate-transpose of l.  
 
   Note: this routine performs &quot;full balancing&quot; on A and B -- see  
   &quot;Further Details&quot;, below.  
 
   Arguments  
   =========  
 
   JOBVL   (input) CHARACTER*1  
           = &#39;N&#39;:  do not compute the left generalized eigenvectors;  
           = &#39;V&#39;:  compute the left generalized eigenvectors.  
 
   JOBVR   (input) CHARACTER*1  
           = &#39;N&#39;:  do not compute the right generalized eigenvectors;  
           = &#39;V&#39;:  compute the right generalized eigenvectors.  
 
   N       (input) INTEGER  
           The order of the matrices A, B, VL, and VR.  N &gt;= 0.  
 
   A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)  
           On entry, the first of the pair of matrices whose  
           generalized eigenvalues and (optionally) generalized  
           eigenvectors are to be computed.  
           On exit, the contents will have been destroyed.  (For a  
           description of the contents of A on exit, see &quot;Further  
           Details&quot;, below.)  
 
   LDA     (input) INTEGER  
           The leading dimension of A.  LDA &gt;= max(1,N).  
 
   B       (input/output) DOUBLE PRECISION array, dimension (LDB, N)  
           On entry, the second of the pair of matrices whose  
           generalized eigenvalues and (optionally) generalized  
           eigenvectors are to be computed.  
           On exit, the contents will have been destroyed.  (For a  
           description of the contents of B on exit, see &quot;Further  
           Details&quot;, below.)  
 
   LDB     (input) INTEGER  
           The leading dimension of B.  LDB &gt;= max(1,N).  
 
   ALPHAR  (output) DOUBLE PRECISION array, dimension (N)  
   ALPHAI  (output) DOUBLE PRECISION array, dimension (N)  
   BETA    (output) DOUBLE PRECISION array, dimension (N)  
           On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will  
           be the generalized eigenvalues.  If ALPHAI(j) is zero, then  
           the j-th eigenvalue is real; if positive, then the j-th and  
           (j+1)-st eigenvalues are a complex conjugate pair, with  
           ALPHAI(j+1) negative.  
 
           Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)  
           may easily over- or underflow, and BETA(j) may even be zero.  
           Thus, the user should avoid naively computing the ratio  
           alpha/beta.  However, ALPHAR and ALPHAI will be always less  
           than and usually comparable with norm(A) in magnitude, and  
           BETA always less than and usually comparable with norm(B).  
 
   VL      (output) DOUBLE PRECISION array, dimension (LDVL,N)  
           If JOBVL = &#39;V&#39;, the left generalized eigenvectors.  (See  
           &quot;Purpose&quot;, above.)  Real eigenvectors take one column,  
           complex take two columns, the first for the real part and  
           the second for the imaginary part.  Complex eigenvectors  
           correspond to an eigenvalue with positive imaginary part.  
           Each eigenvector will be scaled so the largest component  
           will have abs(real part) + abs(imag. part) = 1, *except*  
           that for eigenvalues with alpha=beta=0, a zero vector will  
           be returned as the corresponding eigenvector.  
           Not referenced if JOBVL = &#39;N&#39;.  
 
   LDVL    (input) INTEGER  
           The leading dimension of the matrix VL. LDVL &gt;= 1, and  
           if JOBVL = &#39;V&#39;, LDVL &gt;= N.  
 
   VR      (output) DOUBLE PRECISION array, dimension (LDVR,N)  
           If JOBVR = &#39;V&#39;, the right generalized eigenvectors.  (See  
           &quot;Purpose&quot;, above.)  Real eigenvectors take one column,  
           complex take two columns, the first for the real part and  
           the second for the imaginary part.  Complex eigenvectors  
           correspond to an eigenvalue with positive imaginary part.  
           Each eigenvector will be scaled so the largest component  
           will have abs(real part) + abs(imag. part) = 1, *except*  
           that for eigenvalues with alpha=beta=0, a zero vector will  
           be returned as the corresponding eigenvector.  
           Not referenced if JOBVR = &#39;N&#39;.  
 
   LDVR    (input) INTEGER  
           The leading dimension of the matrix VR. LDVR &gt;= 1, and  
           if JOBVR = &#39;V&#39;, LDVR &gt;= N.  
 
   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)  
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.  
 
   LWORK   (input) INTEGER  
           The dimension of the array WORK.  LWORK &gt;= max(1,8*N).  
           For good performance, LWORK must generally be larger.  
           To compute the optimal value of LWORK, call ILAENV to get  
           blocksizes (for DGEQRF, DORMQR, and DORGQR.)  Then compute:  
           NB  -- MAX of the blocksizes for DGEQRF, DORMQR, and DORGQR;  
           The optimal LWORK is:  
               2*N + MAX( 6*N, N*(NB+1) ).  
 
           If LWORK = -1, then a workspace query is assumed; the routine  
           only calculates the optimal size of the WORK array, returns  
           this value as the first entry of the WORK array, and no error  
           message related to LWORK is issued by XERBLA.  
 
   INFO    (output) INTEGER  
           = 0:  successful exit  
           &lt; 0:  if INFO = -i, the i-th argument had an illegal value.  
           = 1,...,N:  
                 The QZ iteration failed.  No eigenvectors have been  
                 calculated, but ALPHAR(j), ALPHAI(j), and BETA(j)  
                 should be correct for j=INFO+1,...,N.  
           &gt; N:  errors that usually indicate LAPACK problems:  
                 =N+1: error return from DGGBAL  
                 =N+2: error return from DGEQRF  
                 =N+3: error return from DORMQR  
                 =N+4: error return from DORGQR  
                 =N+5: error return from DGGHRD  
                 =N+6: error return from DHGEQZ (other than failed  
                                                 iteration)  
                 =N+7: error return from DTGEVC  
                 =N+8: error return from DGGBAK (computing VL)  
                 =N+9: error return from DGGBAK (computing VR)  
                 =N+10: error return from DLASCL (various calls)  
 
   Further Details  
   ===============  
 
   Balancing  
   ---------  
 
   This driver calls DGGBAL to both permute and scale rows and columns  
   of A and B.  The permutations PL and PR are chosen so that PL*A*PR  
   and PL*B*R will be upper triangular except for the diagonal blocks  
   A(i:j,i:j) and B(i:j,i:j), with i and j as close together as  
   possible.  The diagonal scaling matrices DL and DR are chosen so  
   that the pair  DL*PL*A*PR*DR, DL*PL*B*PR*DR have elements close to  
   one (except for the elements that start out zero.)  
 
   After the eigenvalues and eigenvectors of the balanced matrices  
   have been computed, DGGBAK transforms the eigenvectors back to what  
   they would have been (in perfect arithmetic) if they had not been  
   balanced.  
 
   Contents of A and B on Exit  
   -------- -- - --- - -- ----  
 
   If any eigenvectors are computed (either JOBVL=&#39;V&#39; or JOBVR=&#39;V&#39; or  
   both), then on exit the arrays A and B will contain the real Schur  
   form[*] of the &quot;balanced&quot; versions of A and B.  If no eigenvectors  
   are computed, then only the diagonal blocks will be correct.  
 
   [*] See DHGEQZ, DGEGS, or read the book &quot;Matrix Computations&quot;,  
       by Golub &amp; van Loan, pub. by Johns Hopkins U. Press.  
 
   =====================================================================  
</PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>B[size(A, 1), size(A, 1)]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>alphaReal[size(A, 1)]</TD><TD>Real part of alpha (eigenvalue=(alphaReal+i*alphaImag)/beta)</TD></TR>
<TR><TD>alphaImag[size(A, 1)]</TD><TD>Imaginary part of alpha</TD></TR>
<TR><TD>beta[size(A, 1)]</TD><TD>Denominator of eigenvalue</TD></TR>
<TR><TD>info</TD><TD>&nbsp;</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE dgehrd<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgehrd"></A><A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</A>.dgehrd</H2>
<B>reduces a real general matrix A to upper Hessenberg form H by an orthogonal similarity transformation:  Q&#39; * A * Q = H</B><p>
<P><H3>Information</H3></P>
<PRE>
   Purpose  
   =======  
 
   DGEHRD reduces a real general matrix A to upper Hessenberg form H by  
   an orthogonal similarity transformation:  Q&#39; * A * Q = H .  
 
   Arguments  
   =========  
 
   N       (input) INTEGER  
           The order of the matrix A.  N &gt;= 0.  
 
   ILO     (input) INTEGER  
   IHI     (input) INTEGER  
           It is assumed that A is already upper triangular in rows  
           and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally  
           set by a previous call to DGEBAL; otherwise they should be  
           set to 1 and N respectively. See Further Details.  
           1 &lt;= ILO &lt;= IHI &lt;= N, if N &gt; 0; ILO=1 and IHI=0, if N=0.  
 
   A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)  
           On entry, the N-by-N general matrix to be reduced.  
           On exit, the upper triangle and the first subdiagonal of A  
           are overwritten with the upper Hessenberg matrix H, and the  
           elements below the first subdiagonal, with the array TAU,  
           represent the orthogonal matrix Q as a product of elementary  
           reflectors. See Further Details.  
 
   LDA     (input) INTEGER  
           The leading dimension of the array A.  LDA &gt;= max(1,N).  
 
   TAU     (output) DOUBLE PRECISION array, dimension (N-1)  
           The scalar factors of the elementary reflectors (see Further  
           Details). Elements 1:ILO-1 and IHI:N-1 of TAU are set to  
           zero.  
 
   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)  
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.  
 
   LWORK   (input) INTEGER  
           The length of the array WORK.  LWORK &gt;= max(1,N).  
           For optimum performance LWORK &gt;= N*NB, where NB is the  
           optimal blocksize.  
 
           If LWORK = -1, then a workspace query is assumed; the routine  
           only calculates the optimal size of the WORK array, returns  
           this value as the first entry of the WORK array, and no error  
           message related to LWORK is issued by XERBLA.  
 
   INFO    (output) INTEGER  
           = 0:  successful exit  
           &lt; 0:  if INFO = -i, the i-th argument had an illegal value.  
 
   Further Details  
   ===============  
 
   The matrix Q is represented as a product of (ihi-ilo) elementary  
   reflectors  
 
      Q = H(ilo) H(ilo+1) . . . H(ihi-1).  
 
   Each H(i) has the form  
 
      H(i) = I - tau * v * v&#39;  
 
   where tau is a real scalar, and v is a real vector with  
   v(1:i) = 0, v(i+1) = 1 and v(ihi+1:n) = 0; v(i+2:ihi) is stored on  
   exit in A(i+2:ihi,i), and tau in TAU(i).  
 
   The contents of A are illustrated by the following example, with  
   n = 7, ilo = 2 and ihi = 6:  
 
   on entry,                        on exit,  
 
   ( a   a   a   a   a   a   a )    (  a   a   h   h   h   h   a )  
   (     a   a   a   a   a   a )    (      a   h   h   h   h   a )  
   (     a   a   a   a   a   a )    (      h   h   h   h   h   h )  
   (     a   a   a   a   a   a )    (      v2  h   h   h   h   h )  
   (     a   a   a   a   a   a )    (      v2  v3  h   h   h   h )  
   (     a   a   a   a   a   a )    (      v2  v3  v4  h   h   h )  
   (                         a )    (                          a )  
 
   where a denotes an element of the original matrix A, h denotes a  
   modified element of the upper Hessenberg matrix H, and vi denotes an  
   element of the vector defining H(i).  
 
   =====================================================================  
</PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 2)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>ilo</TD><TD>lowest index where the original matrix had been Hessenbergform</TD></TR>
<TR><TD>ihi</TD><TD>highest index where the original matrix had been Hessenbergform</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Aout[size(A, 1), size(A, 2)]</TD><TD>contains the Hessenberg form in the upper triangle and the first subdiagonal and below the first subdiagonal it contains the elementary reflectors which represents (with array tau) as a product the orthogonal matrix Q</TD></TR>
<TR><TD>tau[size(A, 1) - 1]</TD><TD>scalar factors of the elementary reflectors</TD></TR>
<TR><TD>info</TD><TD>&nbsp;</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE dgeqp3<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgeqp3"></A><A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</A>.dgeqp3</H2>
<B>computes a QR factorization with column pivoting</B><p>
<P><H3>Information</H3></P>
<PRE>   Purpose  
   =======  
 
   DGEQP3 computes a QR factorization with column pivoting of a  
   matrix A:  A*P = Q*R  using Level 3 BLAS.  
 
   Arguments  
   =========  
 
   M       (input) INTEGER  
           The number of rows of the matrix A. M &gt;= 0.  
 
   N       (input) INTEGER  
           The number of columns of the matrix A.  N &gt;= 0.  
 
   A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)  
           On entry, the M-by-N matrix A.  
           On exit, the upper triangle of the array contains the  
           min(M,N)-by-N upper trapezoidal matrix R; the elements below  
           the diagonal, together with the array TAU, represent the  
           orthogonal matrix Q as a product of min(M,N) elementary  
           reflectors.  
 
   LDA     (input) INTEGER  
           The leading dimension of the array A. LDA &gt;= max(1,M).  
 
   JPVT    (input/output) INTEGER array, dimension (N)  
           On entry, if JPVT(J).ne.0, the J-th column of A is permuted  
           to the front of A*P (a leading column); if JPVT(J)=0,  
           the J-th column of A is a free column.  
           On exit, if JPVT(J)=K, then the J-th column of A*P was the  
           the K-th column of A.  
 
   TAU     (output) DOUBLE PRECISION array, dimension (min(M,N))  
           The scalar factors of the elementary reflectors.  
 
   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)  
           On exit, if INFO=0, WORK(1) returns the optimal LWORK.  
 
   LWORK   (input) INTEGER  
           The dimension of the array WORK. LWORK &gt;= 3*N+1.  
           For optimal performance LWORK &gt;= 2*N+( N+1 )*NB, where NB  
           is the optimal blocksize.  
 
           If LWORK = -1, then a workspace query is assumed; the routine  
           only calculates the optimal size of the WORK array, returns  
           this value as the first entry of the WORK array, and no error  
           message related to LWORK is issued by XERBLA.  
 
   INFO    (output) INTEGER  
           = 0: successful exit.  
           &lt; 0: if INFO = -i, the i-th argument had an illegal value.  
 
   Further Details  
   ===============  
 
   The matrix Q is represented as a product of elementary reflectors  
 
      Q = H(1) H(2) . . . H(k), where k = min(m,n).  
 
   Each H(i) has the form  
 
      H(i) = I - tau * v * v&#39;  
 
   where tau is a real/complex scalar, and v is a real/complex vector  
   with v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in  
   A(i+1:m,i), and tau in TAU(i).  
 
   Based on contributions by  
     G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain  
     X. Sun, Computer Science Dept., Duke University, USA  
 
   =====================================================================  
</PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, :]</TD><TD>&nbsp;</TD></TR>
<TR><TD>lwork1</TD><TD>size of work array; should be optimized with Modelica_LinearSystems2.Math.Matrices.Internal.dgeqp3_workdim</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Aout[size(A, 1), size(A, 2)]</TD><TD>the upper triangle of the array contains the upper trapezoidal matrix R; the elements below the diagonal, together with the array TAU, represent the orthogonal matrix Q as a product of elementary reflectors</TD></TR>
<TR><TD>jpvt[size(A, 2)]</TD><TD>pivoting indices</TD></TR>
<TR><TD>tau[min(size(A, 1), size(A, 2))]</TD><TD>scalar factors of the elementary reflectors</TD></TR>
<TR><TD>info</TD><TD>&nbsp;</TD></TR>
<TR><TD>work[max(lwork1, 3*size(A, 2) + 1)]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE dgeqrf<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgeqrf"></A><A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</A>.dgeqrf</H2>
<B>computes a QR factorization without pivoting</B><p>
<P><H3>Information</H3></P>
<PRE>
   Purpose  
   =======  
 
   DGEQRF computes a QR factorization of a real M-by-N matrix A:  
   A = Q * R.  
 
   Arguments  
   =========  
 
   M       (input) INTEGER  
           The number of rows of the matrix A.  M &gt;= 0.  
 
   N       (input) INTEGER  
           The number of columns of the matrix A.  N &gt;= 0.  
 
   A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)  
           On entry, the M-by-N matrix A.  
           On exit, the elements on and above the diagonal of the array  
           contain the min(M,N)-by-N upper trapezoidal matrix R (R is  
           upper triangular if m &gt;= n); the elements below the diagonal,  
           with the array TAU, represent the orthogonal matrix Q as a  
           product of min(m,n) elementary reflectors (see Further  
           Details).  
 
   LDA     (input) INTEGER  
           The leading dimension of the array A.  LDA &gt;= max(1,M).  
 
   TAU     (output) DOUBLE PRECISION array, dimension (min(M,N))  
           The scalar factors of the elementary reflectors (see Further  
           Details).  
 
   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)  
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.  
 
   LWORK   (input) INTEGER  
           The dimension of the array WORK.  LWORK &gt;= max(1,N).  
           For optimum performance LWORK &gt;= N*NB, where NB is  
           the optimal blocksize.  
 
           If LWORK = -1, then a workspace query is assumed; the routine  
           only calculates the optimal size of the WORK array, returns  
           this value as the first entry of the WORK array, and no error  
           message related to LWORK is issued by XERBLA.  
 
   INFO    (output) INTEGER  
           = 0:  successful exit  
           &lt; 0:  if INFO = -i, the i-th argument had an illegal value  
 
   Further Details  
   ===============  
 
   The matrix Q is represented as a product of elementary reflectors  
 
      Q = H(1) H(2) . . . H(k), where k = min(m,n).  
 
   Each H(i) has the form  
 
      H(i) = I - tau * v * v&#39;  
 
   where tau is a real scalar, and v is a real vector with  
   v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i),  
   and tau in TAU(i).  
 
   =====================================================================  </PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, :]</TD><TD>&nbsp;</TD></TR>
<TR><TD>lwork1</TD><TD>size of work array; should be optimized with Modelica_LinearSystems2.Math.Matrices.Internal.dgeqp3_workdim</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Aout[size(A, 1), size(A, 2)]</TD><TD>the upper triangle of the array contains the upper trapezoidal matrix R; the elements below the diagonal, together with the array TAU, represent the orthogonal matrix Q as a product of elementary reflectors</TD></TR>
<TR><TD>tau[min(size(A, 1), size(A, 2))]</TD><TD>scalar factors of the elementary reflectors</TD></TR>
<TR><TD>info</TD><TD>&nbsp;</TD></TR>
<TR><TD>work[max(lwork1, 3*size(A, 2) + 1)]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE dgesdd<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgesddI.png" ALT="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgesdd" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgesdd"></A><A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</A>.dgesdd</H2>
<B>Determine singular value decomposition</B><p>
<P><H3>Information</H3></P>
<PRE>   Purpose  
   =======  

   DGESDD computes the singular value decomposition (SVD) of a real  
   M-by-N matrix A, optionally computing the left and right singular  
   vectors.  If singular vectors are desired, it uses a  
   divide-and-conquer algorithm.  

   The SVD is written  

        A = U * SIGMA * transpose(V)  

   where SIGMA is an M-by-N matrix which is zero except for its  
   min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and  
   V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA  
   are the singular values of A; they are real and non-negative, and  
   are returned in descending order.  The first min(m,n) columns of  
   U and V are the left and right singular vectors of A.  

   Note that the routine returns VT = V**T, not V.  

   The divide and conquer algorithm makes very mild assumptions about  
   floating point arithmetic. It will work on machines with a guard  
   digit in add/subtract, or on those binary machines without guard  
   digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or  
   Cray-2. It could conceivably fail on hexadecimal or decimal machines  
   without guard digits, but we know of none.  

   Arguments  
   =========  

   JOBZ    (input) CHARACTER*1  
           Specifies options for computing all or part of the matrix U:  
           = &#39;A&#39;:  all M columns of U and all N rows of V**T are  
                   returned in the arrays U and VT;  
           = &#39;S&#39;:  the first min(M,N) columns of U and the first  
                   min(M,N) rows of V**T are returned in the arrays U  
                   and VT;  
           = &#39;O&#39;:  If M &gt;= N, the first N columns of U are overwritten  
                   on the array A and all rows of V**T are returned in  
                   the array VT;  
                   otherwise, all columns of U are returned in the  
                   array U and the first M rows of V**T are overwritten  
                   in the array VT;  
           = &#39;N&#39;:  no columns of U or rows of V**T are computed.  

   M       (input) INTEGER  
           The number of rows of the input matrix A.  M &gt;= 0.  

   N       (input) INTEGER  
           The number of columns of the input matrix A.  N &gt;= 0.  

   A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)  
           On entry, the M-by-N matrix A.  
           On exit,  
           if JOBZ = &#39;O&#39;,  A is overwritten with the first N columns  
                           of U (the left singular vectors, stored  
                           columnwise) if M &gt;= N;  
                           A is overwritten with the first M rows  
                           of V**T (the right singular vectors, stored  
                           rowwise) otherwise.  
           if JOBZ .ne. &#39;O&#39;, the contents of A are destroyed.  

   LDA     (input) INTEGER  
           The leading dimension of the array A.  LDA &gt;= max(1,M).  

   S       (output) DOUBLE PRECISION array, dimension (min(M,N))  
           The singular values of A, sorted so that S(i) &gt;= S(i+1).  

   U       (output) DOUBLE PRECISION array, dimension (LDU,UCOL)  
           UCOL = M if JOBZ = &#39;A&#39; or JOBZ = &#39;O&#39; and M &lt; N;  
           UCOL = min(M,N) if JOBZ = &#39;S&#39;.  
           If JOBZ = &#39;A&#39; or JOBZ = &#39;O&#39; and M &lt; N, U contains the M-by-M  
           orthogonal matrix U;  
           if JOBZ = &#39;S&#39;, U contains the first min(M,N) columns of U  
           (the left singular vectors, stored columnwise);  
           if JOBZ = &#39;O&#39; and M &gt;= N, or JOBZ = &#39;N&#39;, U is not referenced.  

   LDU     (input) INTEGER  
           The leading dimension of the array U.  LDU &gt;= 1; if  
           JOBZ = &#39;S&#39; or &#39;A&#39; or JOBZ = &#39;O&#39; and M &lt; N, LDU &gt;= M.  

   VT      (output) DOUBLE PRECISION array, dimension (LDVT,N)  
           If JOBZ = &#39;A&#39; or JOBZ = &#39;O&#39; and M &gt;= N, VT contains the  
           N-by-N orthogonal matrix V**T;  
           if JOBZ = &#39;S&#39;, VT contains the first min(M,N) rows of  
           V**T (the right singular vectors, stored rowwise);  
           if JOBZ = &#39;O&#39; and M &lt; N, or JOBZ = &#39;N&#39;, VT is not referenced.  

   LDVT    (input) INTEGER  
           The leading dimension of the array VT.  LDVT &gt;= 1; if  
           JOBZ = &#39;A&#39; or JOBZ = &#39;O&#39; and M &gt;= N, LDVT &gt;= N;  
           if JOBZ = &#39;S&#39;, LDVT &gt;= min(M,N).  

   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)  
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK;  

   LWORK   (input) INTEGER  
           The dimension of the array WORK. LWORK &gt;= 1.  
           If JOBZ = &#39;N&#39;,  
             LWORK &gt;= 3*min(M,N) + max(max(M,N),6*min(M,N)).  
           If JOBZ = &#39;O&#39;,  
             LWORK &gt;= 3*min(M,N)*min(M,N) +  
                      max(max(M,N),5*min(M,N)*min(M,N)+4*min(M,N)).  
           If JOBZ = &#39;S&#39; or &#39;A&#39;  
             LWORK &gt;= 3*min(M,N)*min(M,N) +  
                      max(max(M,N),4*min(M,N)*min(M,N)+4*min(M,N)).  
           For good performance, LWORK should generally be larger.  
           If LWORK &lt; 0 but other input arguments are legal, WORK(1)  
           returns the optimal LWORK.  

   IWORK   (workspace) INTEGER array, dimension (8*min(M,N))  

   INFO    (output) INTEGER  
           = 0:  successful exit.  
           &lt; 0:  if INFO = -i, the i-th argument had an illegal value.  
           &gt; 0:  DBDSDC did not converge, updating process failed.  

   Further Details  
   ===============  

   Based on contributions by  
      Ming Gu and Huan Ren, Computer Science Division, University of  
      California at Berkeley, USA  

   =====================================================================  </PRE><P>
Extends from Modelica.Icons.Function (Icon for a function).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, :]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>sigma[min(size(A, 1), size(A, 2))]</TD><TD>&nbsp;</TD></TR>
<TR><TD>U[size(A, 1), size(A, 1)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>VT[size(A, 2), size(A, 2)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>info</TD><TD>&nbsp;</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE dgesvd<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgesddI.png" ALT="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgesvd" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgesvd"></A><A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</A>.dgesvd</H2>
<B>Determine singular value decomposition</B><p>
<P><H3>Information</H3></P>
<PRE>Lapack documentation:
    Purpose   
    =======   
    DGESVD computes the singular value decomposition (SVD) of a real   
    M-by-N matrix A, optionally computing the left and/or right singular 
  
    vectors. The SVD is written   
         A = U * SIGMA * transpose(V)   
    where SIGMA is an M-by-N matrix which is zero except for its   
    min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and   
    V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA   
    are the singular values of A; they are real and non-negative, and   
    are returned in descending order.  The first min(m,n) columns of   
    U and V are the left and right singular vectors of A.   
    Note that the routine returns V**T, not V.   
    Arguments   
    =========   
    JOBU    (input) CHARACTER*1   
            Specifies options for computing all or part of the matrix U: 
  
            = &#39;A&#39;:  all M columns of U are returned in array U:   
            = &#39;S&#39;:  the first min(m,n) columns of U (the left singular   
                    vectors) are returned in the array U;   
            = &#39;O&#39;:  the first min(m,n) columns of U (the left singular   
                    vectors) are overwritten on the array A;   
            = &#39;N&#39;:  no columns of U (no left singular vectors) are   
                    computed.   
    JOBVT   (input) CHARACTER*1   
            Specifies options for computing all or part of the matrix   
            V**T:   
            = &#39;A&#39;:  all N rows of V**T are returned in the array VT;   
            = &#39;S&#39;:  the first min(m,n) rows of V**T (the right singular   
                    vectors) are returned in the array VT;   
            = &#39;O&#39;:  the first min(m,n) rows of V**T (the right singular   
                    vectors) are overwritten on the array A;   
            = &#39;N&#39;:  no rows of V**T (no right singular vectors) are   
                    computed.   
            JOBVT and JOBU cannot both be &#39;O&#39;.   
    M       (input) INTEGER   
            The number of rows of the input matrix A.  M &gt;= 0.   
    N       (input) INTEGER   
            The number of columns of the input matrix A.  N &gt;= 0.   
    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)   
            On entry, the M-by-N matrix A.   
            On exit,   
            if JOBU = &#39;O&#39;,  A is overwritten with the first min(m,n)   
                            columns of U (the left singular vectors,   
                            stored columnwise);   
            if JOBVT = &#39;O&#39;, A is overwritten with the first min(m,n)   
                            rows of V**T (the right singular vectors,   
                            stored rowwise);   
            if JOBU .ne. &#39;O&#39; and JOBVT .ne. &#39;O&#39;, the contents of A   
                            are destroyed.   
    LDA     (input) INTEGER   
            The leading dimension of the array A.  LDA &gt;= max(1,M).   
    S       (output) DOUBLE PRECISION array, dimension (min(M,N))   
            The singular values of A, sorted so that S(i) &gt;= S(i+1).   
    U       (output) DOUBLE PRECISION array, dimension (LDU,UCOL)   
            (LDU,M) if JOBU = &#39;A&#39; or (LDU,min(M,N)) if JOBU = &#39;S&#39;.   
            If JOBU = &#39;A&#39;, U contains the M-by-M orthogonal matrix U;   
            if JOBU = &#39;S&#39;, U contains the first min(m,n) columns of U   
            (the left singular vectors, stored columnwise);   
            if JOBU = &#39;N&#39; or &#39;O&#39;, U is not referenced.   
    LDU     (input) INTEGER   
            The leading dimension of the array U.  LDU &gt;= 1; if   
            JOBU = &#39;S&#39; or &#39;A&#39;, LDU &gt;= M.   
    VT      (output) DOUBLE PRECISION array, dimension (LDVT,N)   
            If JOBVT = &#39;A&#39;, VT contains the N-by-N orthogonal matrix   
            V**T;   
            if JOBVT = &#39;S&#39;, VT contains the first min(m,n) rows of   
            V**T (the right singular vectors, stored rowwise);   
            if JOBVT = &#39;N&#39; or &#39;O&#39;, VT is not referenced.   
    LDVT    (input) INTEGER   
            The leading dimension of the array VT.  LDVT &gt;= 1; if   
            JOBVT = &#39;A&#39;, LDVT &gt;= N; if JOBVT = &#39;S&#39;, LDVT &gt;= min(M,N).   
    WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK) 
  
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK;   
            if INFO &gt; 0, WORK(2:MIN(M,N)) contains the unconverged   
            superdiagonal elements of an upper bidiagonal matrix B   
            whose diagonal is in S (not necessarily sorted). B   
            satisfies A = U * B * VT, so it has the same singular values 
  
            as A, and singular vectors related by U and VT.   
    LWORK   (input) INTEGER   
            The dimension of the array WORK. LWORK &gt;= 1.   
            LWORK &gt;= MAX(3*MIN(M,N)+MAX(M,N),5*MIN(M,N)-4).   
            For good performance, LWORK should generally be larger.   
    INFO    (output) INTEGER   
            = 0:  successful exit.   
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value.   
            &gt; 0:  if DBDSQR did not converge, INFO specifies how many   
                  superdiagonals of an intermediate bidiagonal form B   
                  did not converge to zero. See the description of WORK   
                  above for details.   
</PRE><P>
Extends from Modelica.Icons.Function (Icon for a function).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, :]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>sigma[min(size(A, 1), size(A, 2))]</TD><TD>&nbsp;</TD></TR>
<TR><TD>U[size(A, 1), size(A, 1)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>VT[size(A, 2), size(A, 2)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>info</TD><TD>&nbsp;</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE dgesvx<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgesddI.png" ALT="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgesvx" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgesvx"></A><A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</A>.dgesvx</H2>
<B>Solve real system of linear equations A**T*X=B with a B matrix with LAPACK routine DGESVX</B><p>
<P><H3>Information</H3></P>
<PRE>Lapack documentation:
    Purpose   
    =======   
    DGESV computes the solution to a real system of linear equations   
       A * X = B,   
    where A is an N-by-N matrix and X and B are N-by-NRHS matrices.   
    The LU decomposition with partial pivoting and row interchanges is   
    used to factor A as   
       A = P * L * U,   
    where P is a permutation matrix, L is unit lower triangular, and U is 
  
    upper triangular.  The factored form of A is then used to solve the   
    system of equations A * X = B.   
    Arguments   
    =========   
    N       (input) INTEGER   
            The number of linear equations, i.e., the order of the   
            matrix A.  N &gt;= 0.   
    NRHS    (input) INTEGER   
            The number of right hand sides, i.e., the number of columns   
            of the matrix B.  NRHS &gt;= 0.   
    A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)   
            On entry, the N-by-N coefficient matrix A.   
            On exit, the factors L and U from the factorization   
            A = P*L*U; the unit diagonal elements of L are not stored.   
    LDA     (input) INTEGER   
            The leading dimension of the array A.  LDA &gt;= max(1,N).   
    IPIV    (output) INTEGER array, dimension (N)   
            The pivot indices that define the permutation matrix P;   
            row i of the matrix was interchanged with row IPIV(i).   
    B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)   
            On entry, the N-by-NRHS matrix of right hand side matrix B.   
            On exit, if INFO = 0, the N-by-NRHS solution matrix X.   
    LDB     (input) INTEGER   
            The leading dimension of the array B.  LDB &gt;= max(1,N).   
    INFO    (output) INTEGER   
            = 0:  successful exit   
            &lt; 0:  if INFO = -i, the i-th argument had an illegal value   
            &gt; 0:  if INFO = i, U(i,i) is exactly zero.  The factorization 
  
                  has been completed, but the factor U is exactly   
                  singular, so the solution could not be computed.   
</PRE><P>
Extends from Modelica.Icons.Function (Icon for a function).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>B[size(A, 1), :]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>X[size(A, 1), size(B, 2)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>info</TD><TD>&nbsp;</TD></TR>
<TR><TD>rcond</TD><TD>&nbsp;</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE dgetrs<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgetrs"></A><A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</A>.dgetrs</H2>
<B>Solves a system of linear equations with the LU decomposition from dgetrf(..)</B><p>
<P><H3>Information</H3></P>
<PRE>
Purpose
=======
DGETRS solves a system of linear equations
   A * X = B  or  A&#39; * X = B
with a general N-by-N matrix A using the LU factorization computed
by DGETRF.
Arguments
=========
TRANS   (input) CHARACTER*1
        Specifies the form of the system of equations:
        = &#39;N&#39;:  A * X = B  (No transpose)
        = &#39;T&#39;:  A&#39;* X = B  (Transpose)
        = &#39;C&#39;:  A&#39;* X = B  (Conjugate transpose = Transpose)
N       (input) INTEGER
        The order of the matrix A.  N &gt;= 0.
NRHS    (input) INTEGER
        The number of right hand sides, i.e., the number of columns
        of the matrix B.  NRHS &gt;= 0.
A       (input) DOUBLE PRECISION array, dimension (LDA,N)
        The factors L and U from the factorization A = P*L*U
        as computed by DGETRF.
LDA     (input) INTEGER
        The leading dimension of the array A.  LDA &gt;= max(1,N).
IPIV    (input) INTEGER array, dimension (N)
        The pivot indices from DGETRF; for 1&lt;=i&lt;=N, row i of the
        matrix was interchanged with row IPIV(i).
B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
        On entry, the right hand side matrix B.
        On exit, the solution matrix X.
LDB     (input) INTEGER
        The leading dimension of the array B.  LDB &gt;= max(1,N).
INFO    (output) INTEGER
        = 0:  successful exit
        &lt; 0:  if INFO = -i, the i-th argument had an illegal value
</PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>LU[:, size(LU, 1)]</TD><TD>LU factorization of dgetrf of a square matrix</TD></TR>
<TR><TD>pivots[size(LU, 1)]</TD><TD>Pivot vector of dgetrf</TD></TR>
<TR><TD>B[size(LU, 1), :]</TD><TD>Right hand side matrix B</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>X[size(B, 1), size(B, 2)]</TD><TD>Solution matrix X</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE dggev<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.LAPACK.dggev"></A><A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</A>.dggev</H2>
<B>Compute generalized eigenvalues for a (A,B) system</B><p>
<P><H3>Information</H3></P>
<PRE>   Purpose  
   =======  
 
   DGGEV computes for a pair of N-by-N real nonsymmetric matrices (A,B)  
   the generalized eigenvalues, and optionally, the left and/or right  
   generalized eigenvectors.  
 
   A generalized eigenvalue for a pair of matrices (A,B) is a scalar  
   lambda or a ratio alpha/beta = lambda, such that A - lambda*B is  
   singular. It is usually represented as the pair (alpha,beta), as  
   there is a reasonable interpretation for beta=0, and even for both  
   being zero.  
 
   The right eigenvector v(j) corresponding to the eigenvalue lambda(j)  
   of (A,B) satisfies  
 
                    A * v(j) = lambda(j) * B * v(j).  
 
   The left eigenvector u(j) corresponding to the eigenvalue lambda(j)  
   of (A,B) satisfies  
 
                    u(j)**H * A  = lambda(j) * u(j)**H * B .  
 
   where u(j)**H is the conjugate-transpose of u(j).  
 
 
   Arguments  
   =========  
 
   JOBVL   (input) CHARACTER*1  
           = &#39;N&#39;:  do not compute the left generalized eigenvectors;  
           = &#39;V&#39;:  compute the left generalized eigenvectors.  
 
   JOBVR   (input) CHARACTER*1  
           = &#39;N&#39;:  do not compute the right generalized eigenvectors;  
           = &#39;V&#39;:  compute the right generalized eigenvectors.  
 
   N       (input) INTEGER  
           The order of the matrices A, B, VL, and VR.  N &gt;= 0.  
 
   A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)  
           On entry, the matrix A in the pair (A,B).  
           On exit, A has been overwritten.  
 
   LDA     (input) INTEGER  
           The leading dimension of A.  LDA &gt;= max(1,N).  
 
   B       (input/output) DOUBLE PRECISION array, dimension (LDB, N)  
           On entry, the matrix B in the pair (A,B).  
           On exit, B has been overwritten.  
 
   LDB     (input) INTEGER  
           The leading dimension of B.  LDB &gt;= max(1,N).  
 
   ALPHAR  (output) DOUBLE PRECISION array, dimension (N)  
   ALPHAI  (output) DOUBLE PRECISION array, dimension (N)  
   BETA    (output) DOUBLE PRECISION array, dimension (N)  
           On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will  
           be the generalized eigenvalues.  If ALPHAI(j) is zero, then  
           the j-th eigenvalue is real; if positive, then the j-th and  
           (j+1)-st eigenvalues are a complex conjugate pair, with  
           ALPHAI(j+1) negative.  
 
           Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)  
           may easily over- or underflow, and BETA(j) may even be zero.  
           Thus, the user should avoid naively computing the ratio  
           alpha/beta.  However, ALPHAR and ALPHAI will be always less  
           than and usually comparable with norm(A) in magnitude, and  
           BETA always less than and usually comparable with norm(B).  
 
   VL      (output) DOUBLE PRECISION array, dimension (LDVL,N)  
           If JOBVL = &#39;V&#39;, the left eigenvectors u(j) are stored one  
           after another in the columns of VL, in the same order as  
           their eigenvalues. If the j-th eigenvalue is real, then  
           u(j) = VL(:,j), the j-th column of VL. If the j-th and  
           (j+1)-th eigenvalues form a complex conjugate pair, then  
           u(j) = VL(:,j)+i*VL(:,j+1) and u(j+1) = VL(:,j)-i*VL(:,j+1).  
           Each eigenvector will be scaled so the largest component have  
           abs(real part)+abs(imag. part)=1.  
           Not referenced if JOBVL = &#39;N&#39;.  
 
   LDVL    (input) INTEGER  
           The leading dimension of the matrix VL. LDVL &gt;= 1, and  
           if JOBVL = &#39;V&#39;, LDVL &gt;= N.  
 
   VR      (output) DOUBLE PRECISION array, dimension (LDVR,N)  
           If JOBVR = &#39;V&#39;, the right eigenvectors v(j) are stored one  
           after another in the columns of VR, in the same order as  
           their eigenvalues. If the j-th eigenvalue is real, then  
           v(j) = VR(:,j), the j-th column of VR. If the j-th and  
           (j+1)-th eigenvalues form a complex conjugate pair, then  
           v(j) = VR(:,j)+i*VR(:,j+1) and v(j+1) = VR(:,j)-i*VR(:,j+1).  
           Each eigenvector will be scaled so the largest component have  
           abs(real part)+abs(imag. part)=1.  
           Not referenced if JOBVR = &#39;N&#39;.  
 
   LDVR    (input) INTEGER  
           The leading dimension of the matrix VR. LDVR &gt;= 1, and  
           if JOBVR = &#39;V&#39;, LDVR &gt;= N.  
 
   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)  
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.  
 
   LWORK   (input) INTEGER  
           The dimension of the array WORK.  LWORK &gt;= max(1,8*N).  
           For good performance, LWORK must generally be larger.  
 
           If LWORK = -1, then a workspace query is assumed; the routine  
           only calculates the optimal size of the WORK array, returns  
           this value as the first entry of the WORK array, and no error  
           message related to LWORK is issued by XERBLA.  
 
   INFO    (output) INTEGER  
           = 0:  successful exit  
           &lt; 0:  if INFO = -i, the i-th argument had an illegal value.  
           = 1,...,N:  
                 The QZ iteration failed.  No eigenvectors have been  
                 calculated, but ALPHAR(j), ALPHAI(j), and BETA(j)  
                 should be correct for j=INFO+1,...,N.  
           &gt; N:  =N+1: other than QZ iteration failed in DHGEQZ.  
                 =N+2: error return from DTGEVC.  
 
   =====================================================================  
</PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>B[size(A, 1), size(A, 1)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>nA</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>alphaReal[size(A, 1)]</TD><TD>Real part of alpha (eigenvalue=(alphaReal+i*alphaImag)/beta)</TD></TR>
<TR><TD>alphaImag[size(A, 1)]</TD><TD>Imaginary part of alpha</TD></TR>
<TR><TD>beta[size(A, 1)]</TD><TD>Denominator of eigenvalue</TD></TR>
<TR><TD>lEigenVectors[size(A, 1), size(A, 1)]</TD><TD>left eigenvectors of matrix A</TD></TR>
<TR><TD>rEigenVectors[size(A, 1), size(A, 1)]</TD><TD>right eigenvectors of matrix A</TD></TR>
<TR><TD>info</TD><TD>&nbsp;</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE dggevx<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.LAPACK.dggevx"></A><A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</A>.dggevx</H2>
<B>Compute generalized eigenvalues for a (A,B) system, using lapack routine dggevx</B><p>
<P><H3>Information</H3></P>
<PRE>/*  Purpose  
/*  =======  
 
   DGGEVX computes for a pair of N-by-N real nonsymmetric matrices (A,B)  
   the generalized eigenvalues, and optionally, the left and/or right  
   generalized eigenvectors.  
 
   Optionally also, it computes a balancing transformation to improve  
   the conditioning of the eigenvalues and eigenvectors (ILO, IHI,  
   LSCALE, RSCALE, ABNRM, and BBNRM), reciprocal condition numbers for  
   the eigenvalues (RCONDE), and reciprocal condition numbers for the  
   right eigenvectors (RCONDV).  
 
   A generalized eigenvalue for a pair of matrices (A,B) is a scalar  
   lambda or a ratio alpha/beta = lambda, such that A - lambda*B is  
   singular. It is usually represented as the pair (alpha,beta), as  
   there is a reasonable interpretation for beta=0, and even for both  
   being zero.  
 
   The right eigenvector v(j) corresponding to the eigenvalue lambda(j)  
   of (A,B) satisfies  
 
                    A * v(j) = lambda(j) * B * v(j) .  
 
   The left eigenvector u(j) corresponding to the eigenvalue lambda(j)  
   of (A,B) satisfies  
 
                    u(j)**H * A  = lambda(j) * u(j)**H * B.  
 
   where u(j)**H is the conjugate-transpose of u(j).  
 
 
   Arguments  
   =========  
 
   BALANC  (input) CHARACTER*1  
           Specifies the balance option to be performed.  
           = &#39;N&#39;:  do not diagonally scale or permute;  
           = &#39;P&#39;:  permute only;  
           = &#39;S&#39;:  scale only;  
           = &#39;B&#39;:  both permute and scale.  
           Computed reciprocal condition numbers will be for the  
           matrices after permuting and/or balancing. Permuting does  
           not change condition numbers (in exact arithmetic), but  
           balancing does.  
 
   JOBVL   (input) CHARACTER*1  
           = &#39;N&#39;:  do not compute the left generalized eigenvectors;  
           = &#39;V&#39;:  compute the left generalized eigenvectors.  
 
   JOBVR   (input) CHARACTER*1  
           = &#39;N&#39;:  do not compute the right generalized eigenvectors;  
           = &#39;V&#39;:  compute the right generalized eigenvectors.  
 
   SENSE   (input) CHARACTER*1  
           Determines which reciprocal condition numbers are computed.  
           = &#39;N&#39;: none are computed;  
           = &#39;E&#39;: computed for eigenvalues only;  
           = &#39;V&#39;: computed for eigenvectors only;  
           = &#39;B&#39;: computed for eigenvalues and eigenvectors.  
 
   N       (input) INTEGER  
           The order of the matrices A, B, VL, and VR.  N &gt;= 0.  
 
   A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)  
           On entry, the matrix A in the pair (A,B).  
           On exit, A has been overwritten. If JOBVL=&#39;V&#39; or JOBVR=&#39;V&#39;  
           or both, then A contains the first part of the real Schur  
           form of the &quot;balanced&quot; versions of the input A and B.  
 
   LDA     (input) INTEGER  
           The leading dimension of A.  LDA &gt;= max(1,N).  
 
   B       (input/output) DOUBLE PRECISION array, dimension (LDB, N)  
           On entry, the matrix B in the pair (A,B).  
           On exit, B has been overwritten. If JOBVL=&#39;V&#39; or JOBVR=&#39;V&#39;  
           or both, then B contains the second part of the real Schur  
           form of the &quot;balanced&quot; versions of the input A and B.  
 
   LDB     (input) INTEGER  
           The leading dimension of B.  LDB &gt;= max(1,N).  
 
   ALPHAR  (output) DOUBLE PRECISION array, dimension (N)  
   ALPHAI  (output) DOUBLE PRECISION array, dimension (N)  
   BETA    (output) DOUBLE PRECISION array, dimension (N)  
           On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will  
           be the generalized eigenvalues.  If ALPHAI(j) is zero, then  
           the j-th eigenvalue is real; if positive, then the j-th and  
           (j+1)-st eigenvalues are a complex conjugate pair, with  
           ALPHAI(j+1) negative.  
 
           Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)  
           may easily over- or underflow, and BETA(j) may even be zero.  
           Thus, the user should avoid naively computing the ratio  
           ALPHA/BETA. However, ALPHAR and ALPHAI will be always less  
           than and usually comparable with norm(A) in magnitude, and  
           BETA always less than and usually comparable with norm(B).  
 
   VL      (output) DOUBLE PRECISION array, dimension (LDVL,N)  
           If JOBVL = &#39;V&#39;, the left eigenvectors u(j) are stored one  
           after another in the columns of VL, in the same order as  
           their eigenvalues. If the j-th eigenvalue is real, then  
           u(j) = VL(:,j), the j-th column of VL. If the j-th and  
           (j+1)-th eigenvalues form a complex conjugate pair, then  
           u(j) = VL(:,j)+i*VL(:,j+1) and u(j+1) = VL(:,j)-i*VL(:,j+1).  
           Each eigenvector will be scaled so the largest component have  
           abs(real part) + abs(imag. part) = 1.  
           Not referenced if JOBVL = &#39;N&#39;.  
 
   LDVL    (input) INTEGER  
           The leading dimension of the matrix VL. LDVL &gt;= 1, and  
           if JOBVL = &#39;V&#39;, LDVL &gt;= N.  
 
   VR      (output) DOUBLE PRECISION array, dimension (LDVR,N)  
           If JOBVR = &#39;V&#39;, the right eigenvectors v(j) are stored one  
           after another in the columns of VR, in the same order as  
           their eigenvalues. If the j-th eigenvalue is real, then  
           v(j) = VR(:,j), the j-th column of VR. If the j-th and  
           (j+1)-th eigenvalues form a complex conjugate pair, then  
           v(j) = VR(:,j)+i*VR(:,j+1) and v(j+1) = VR(:,j)-i*VR(:,j+1).  
           Each eigenvector will be scaled so the largest component have  
           abs(real part) + abs(imag. part) = 1.  
           Not referenced if JOBVR = &#39;N&#39;.  
 
   LDVR    (input) INTEGER  
           The leading dimension of the matrix VR. LDVR &gt;= 1, and  
           if JOBVR = &#39;V&#39;, LDVR &gt;= N.  
 
   ILO,IHI (output) INTEGER  
           ILO and IHI are integer values such that on exit  
           A(i,j) = 0 and B(i,j) = 0 if i &gt; j and  
           j = 1,...,ILO-1 or i = IHI+1,...,N.  
           If BALANC = &#39;N&#39; or &#39;S&#39;, ILO = 1 and IHI = N.  
 
   LSCALE  (output) DOUBLE PRECISION array, dimension (N)  
           Details of the permutations and scaling factors applied  
           to the left side of A and B.  If PL(j) is the index of the  
           row interchanged with row j, and DL(j) is the scaling  
           factor applied to row j, then  
             LSCALE(j) = PL(j)  for j = 1,...,ILO-1  
                       = DL(j)  for j = ILO,...,IHI  
                       = PL(j)  for j = IHI+1,...,N.  
           The order in which the interchanges are made is N to IHI+1,  
           then 1 to ILO-1.  
 
   RSCALE  (output) DOUBLE PRECISION array, dimension (N)  
           Details of the permutations and scaling factors applied  
           to the right side of A and B.  If PR(j) is the index of the  
           column interchanged with column j, and DR(j) is the scaling  
           factor applied to column j, then  
             RSCALE(j) = PR(j)  for j = 1,...,ILO-1  
                       = DR(j)  for j = ILO,...,IHI  
                       = PR(j)  for j = IHI+1,...,N  
           The order in which the interchanges are made is N to IHI+1,  
           then 1 to ILO-1.  
 
   ABNRM   (output) DOUBLE PRECISION  
           The one-norm of the balanced matrix A.  
 
   BBNRM   (output) DOUBLE PRECISION  
           The one-norm of the balanced matrix B.  
 
   RCONDE  (output) DOUBLE PRECISION array, dimension (N)  
           If SENSE = &#39;E&#39; or &#39;B&#39;, the reciprocal condition numbers of  
           the selected eigenvalues, stored in consecutive elements of  
           the array. For a complex conjugate pair of eigenvalues two  
           consecutive elements of RCONDE are set to the same value.  
           Thus RCONDE(j), RCONDV(j), and the j-th columns of VL and VR  
           all correspond to the same eigenpair (but not in general the  
           j-th eigenpair, unless all eigenpairs are selected).  
           If SENSE = &#39;V&#39;, RCONDE is not referenced.  
 
   RCONDV  (output) DOUBLE PRECISION array, dimension (N)  
           If SENSE = &#39;V&#39; or &#39;B&#39;, the estimated reciprocal condition  
           numbers of the selected eigenvectors, stored in consecutive  
           elements of the array. For a complex eigenvector two  
           consecutive elements of RCONDV are set to the same value. If  
           the eigenvalues cannot be reordered to compute RCONDV(j),  
           RCONDV(j) is set to 0; this can only occur when the true  
           value would be very small anyway.  
           If SENSE = &#39;E&#39;, RCONDV is not referenced.  
 
   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)  
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.  
 
   LWORK   (input) INTEGER  
           The dimension of the array WORK. LWORK &gt;= max(1,6*N).  
           If SENSE = &#39;E&#39;, LWORK &gt;= 12*N.  
           If SENSE = &#39;V&#39; or &#39;B&#39;, LWORK &gt;= 2*N*N+12*N+16.  
 
           If LWORK = -1, then a workspace query is assumed; the routine  
           only calculates the optimal size of the WORK array, returns  
           this value as the first entry of the WORK array, and no error  
           message related to LWORK is issued by XERBLA.  
 
   IWORK   (workspace) INTEGER array, dimension (N+6)  
           If SENSE = &#39;E&#39;, IWORK is not referenced.  
 
   BWORK   (workspace) LOGICAL array, dimension (N)  
           If SENSE = &#39;N&#39;, BWORK is not referenced.  
 
   INFO    (output) INTEGER  
           = 0:  successful exit  
           &lt; 0:  if INFO = -i, the i-th argument had an illegal value.  
           = 1,...,N:  
                 The QZ iteration failed.  No eigenvectors have been  
                 calculated, but ALPHAR(j), ALPHAI(j), and BETA(j)  
                 should be correct for j=INFO+1,...,N.  
           &gt; N:  =N+1: other than QZ iteration failed in DHGEQZ.  
                 =N+2: error return from DTGEVC.  
 
   Further Details  
   ===============  
 
   Balancing a matrix pair (A,B) includes, first, permuting rows and  
   columns to isolate eigenvalues, second, applying diagonal similarity  
   transformation to the rows and columns to make the rows and columns  
   as close in norm as possible. The computed reciprocal condition  
   numbers correspond to the balanced matrix. Permuting rows and columns  
   will not change the condition numbers (in exact arithmetic) but  
   diagonal scaling will.  For further explanation of balancing, see  
   section 4.11.1.2 of LAPACK Users&#39; Guide.  
 
   An approximate error bound on the chordal distance between the i-th  
   computed generalized eigenvalue w and the corresponding exact  
   eigenvalue lambda is  
 
        chord(w, lambda) &lt;= EPS * norm(ABNRM, BBNRM) / RCONDE(I)  
 
   An approximate error bound for the angle between the i-th computed  
   eigenvector VL(i) or VR(i) is given by  
 
        EPS * norm(ABNRM, BBNRM) / DIF(i).  
 
   For further explanation of the reciprocal condition numbers RCONDE  
   and RCONDV, see section 4.11 of LAPACK User&#39;s Guide.  
 
   =====================================================================  
</PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>B[size(A, 1), size(A, 1)]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>alphaReal[size(A, 1)]</TD><TD>Real part of alpha (eigenvalue=(alphaReal+i*alphaImag)/beta)</TD></TR>
<TR><TD>alphaImag[size(A, 1)]</TD><TD>Imaginary part of alpha</TD></TR>
<TR><TD>beta[size(A, 1)]</TD><TD>Denominator of eigenvalue</TD></TR>
<TR><TD>lEigenVectors[size(A, 1), size(A, 1)]</TD><TD>left eigenvectors of matrix A</TD></TR>
<TR><TD>rEigenVectors[size(A, 1), size(A, 1)]</TD><TD>right eigenvectors of matrix A</TD></TR>
<TR><TD>info</TD><TD>&nbsp;</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE dhgeqz<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.LAPACK.dhgeqz"></A><A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</A>.dhgeqz</H2>
<B>Compute generalized eigenvalues for a (A,B) system</B><p>
<P><H3>Information</H3></P>
<PRE>
     Purpose  
   =======  
 
   DHGEQZ implements a single-/double-shift version of the QZ method for  
   finding the generalized eigenvalues  
 
   w(j)=(ALPHAR(j) + i*ALPHAI(j))/BETAR(j)   of the equation  
 
        det( A - w(i) B ) = 0  
 
   In addition, the pair A,B may be reduced to generalized Schur form:  
   B is upper triangular, and A is block upper triangular, where the  
   diagonal blocks are either 1-by-1 or 2-by-2, the 2-by-2 blocks having  
   complex generalized eigenvalues (see the description of the argument  
   JOB.)  
 
   If JOB=&#39;S&#39;, then the pair (A,B) is simultaneously reduced to Schur  
   form by applying one orthogonal tranformation (usually called Q) on  
   the left and another (usually called Z) on the right.  The 2-by-2  
   upper-triangular diagonal blocks of B corresponding to 2-by-2 blocks  
   of A will be reduced to positive diagonal matrices.  (I.e.,  
   if A(j+1,j) is non-zero, then B(j+1,j)=B(j,j+1)=0 and B(j,j) and  
   B(j+1,j+1) will be positive.)  
 
   If JOB=&#39;E&#39;, then at each iteration, the same transformations  
   are computed, but they are only applied to those parts of A and B  
   which are needed to compute ALPHAR, ALPHAI, and BETAR.  
 
   If JOB=&#39;S&#39; and COMPQ and COMPZ are &#39;V&#39; or &#39;I&#39;, then the orthogonal  
   transformations used to reduce (A,B) are accumulated into the arrays  
   Q and Z s.t.:  
 
        Q(in) A(in) Z(in)* = Q(out) A(out) Z(out)*  
        Q(in) B(in) Z(in)* = Q(out) B(out) Z(out)*  
 
   Ref: C.B. Moler &amp; G.W. Stewart, &quot;An Algorithm for Generalized Matrix  
        Eigenvalue Problems&quot;, SIAM J. Numer. Anal., 10(1973),  
        pp. 241--256.  
 
   Arguments  
   =========  
 
   JOB     (input) CHARACTER*1  
           = &#39;E&#39;: compute only ALPHAR, ALPHAI, and BETA.  A and B will  
                  not necessarily be put into generalized Schur form.  
           = &#39;S&#39;: put A and B into generalized Schur form, as well  
                  as computing ALPHAR, ALPHAI, and BETA.  
 
   COMPQ   (input) CHARACTER*1  
           = &#39;N&#39;: do not modify Q.  
           = &#39;V&#39;: multiply the array Q on the right by the transpose of  
                  the orthogonal tranformation that is applied to the  
                  left side of A and B to reduce them to Schur form.  
           = &#39;I&#39;: like COMPQ=&#39;V&#39;, except that Q will be initialized to  
                  the identity first.  
 
   COMPZ   (input) CHARACTER*1  
           = &#39;N&#39;: do not modify Z.  
           = &#39;V&#39;: multiply the array Z on the right by the orthogonal  
                  tranformation that is applied to the right side of  
                  A and B to reduce them to Schur form.  
           = &#39;I&#39;: like COMPZ=&#39;V&#39;, except that Z will be initialized to  
                  the identity first.  
 
   N       (input) INTEGER  
           The order of the matrices A, B, Q, and Z.  N &gt;= 0.  
 
   ILO     (input) INTEGER  
   IHI     (input) INTEGER  
           It is assumed that A is already upper triangular in rows and  
           columns 1:ILO-1 and IHI+1:N.  
           1 &lt;= ILO &lt;= IHI &lt;= N, if N &gt; 0; ILO=1 and IHI=0, if N=0.  
 
   A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)  
           On entry, the N-by-N upper Hessenberg matrix A.  Elements  
           below the subdiagonal must be zero.  
           If JOB=&#39;S&#39;, then on exit A and B will have been  
              simultaneously reduced to generalized Schur form.  
           If JOB=&#39;E&#39;, then on exit A will have been destroyed.  
              The diagonal blocks will be correct, but the off-diagonal  
              portion will be meaningless.  
 
   LDA     (input) INTEGER  
           The leading dimension of the array A.  LDA &gt;= max( 1, N ).  
 
   B       (input/output) DOUBLE PRECISION array, dimension (LDB, N)  
           On entry, the N-by-N upper triangular matrix B.  Elements  
           below the diagonal must be zero.  2-by-2 blocks in B  
           corresponding to 2-by-2 blocks in A will be reduced to  
           positive diagonal form.  (I.e., if A(j+1,j) is non-zero,  
           then B(j+1,j)=B(j,j+1)=0 and B(j,j) and B(j+1,j+1) will be  
           positive.)  
           If JOB=&#39;S&#39;, then on exit A and B will have been  
              simultaneously reduced to Schur form.  
           If JOB=&#39;E&#39;, then on exit B will have been destroyed.  
              Elements corresponding to diagonal blocks of A will be  
              correct, but the off-diagonal portion will be meaningless.  
 
   LDB     (input) INTEGER  
           The leading dimension of the array B.  LDB &gt;= max( 1, N ).  
 
   ALPHAR  (output) DOUBLE PRECISION array, dimension (N)  
           ALPHAR(1:N) will be set to real parts of the diagonal  
           elements of A that would result from reducing A and B to  
           Schur form and then further reducing them both to triangular  
           form using unitary transformations s.t. the diagonal of B  
           was non-negative real.  Thus, if A(j,j) is in a 1-by-1 block  
           (i.e., A(j+1,j)=A(j,j+1)=0), then ALPHAR(j)=A(j,j).  
           Note that the (real or complex) values  
           (ALPHAR(j) + i*ALPHAI(j))/BETA(j), j=1,...,N, are the  
           generalized eigenvalues of the matrix pencil A - wB.  
 
   ALPHAI  (output) DOUBLE PRECISION array, dimension (N)  
           ALPHAI(1:N) will be set to imaginary parts of the diagonal  
           elements of A that would result from reducing A and B to  
           Schur form and then further reducing them both to triangular  
           form using unitary transformations s.t. the diagonal of B  
           was non-negative real.  Thus, if A(j,j) is in a 1-by-1 block  
           (i.e., A(j+1,j)=A(j,j+1)=0), then ALPHAR(j)=0.  
           Note that the (real or complex) values  
           (ALPHAR(j) + i*ALPHAI(j))/BETA(j), j=1,...,N, are the  
           generalized eigenvalues of the matrix pencil A - wB.  
 
   BETA    (output) DOUBLE PRECISION array, dimension (N)  
           BETA(1:N) will be set to the (real) diagonal elements of B  
           that would result from reducing A and B to Schur form and  
           then further reducing them both to triangular form using  
           unitary transformations s.t. the diagonal of B was  
           non-negative real.  Thus, if A(j,j) is in a 1-by-1 block  
           (i.e., A(j+1,j)=A(j,j+1)=0), then BETA(j)=B(j,j).  
           Note that the (real or complex) values  
           (ALPHAR(j) + i*ALPHAI(j))/BETA(j), j=1,...,N, are the  
           generalized eigenvalues of the matrix pencil A - wB.  
           (Note that BETA(1:N) will always be non-negative, and no  
           BETAI is necessary.)  
 
   Q       (input/output) DOUBLE PRECISION array, dimension (LDQ, N)  
           If COMPQ=&#39;N&#39;, then Q will not be referenced.  
           If COMPQ=&#39;V&#39; or &#39;I&#39;, then the transpose of the orthogonal  
              transformations which are applied to A and B on the left  
              will be applied to the array Q on the right.  
 
   LDQ     (input) INTEGER  
           The leading dimension of the array Q.  LDQ &gt;= 1.  
           If COMPQ=&#39;V&#39; or &#39;I&#39;, then LDQ &gt;= N.  
 
   Z       (input/output) DOUBLE PRECISION array, dimension (LDZ, N)  
           If COMPZ=&#39;N&#39;, then Z will not be referenced.  
           If COMPZ=&#39;V&#39; or &#39;I&#39;, then the orthogonal transformations  
              which are applied to A and B on the right will be applied  
              to the array Z on the right.  
 
   LDZ     (input) INTEGER  
           The leading dimension of the array Z.  LDZ &gt;= 1.  
           If COMPZ=&#39;V&#39; or &#39;I&#39;, then LDZ &gt;= N.  
 
   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)  
           On exit, if INFO &gt;= 0, WORK(1) returns the optimal LWORK.  
 
   LWORK   (input) INTEGER  
           The dimension of the array WORK.  LWORK &gt;= max(1,N).  
 
           If LWORK = -1, then a workspace query is assumed; the routine  
           only calculates the optimal size of the WORK array, returns  
           this value as the first entry of the WORK array, and no error  
           message related to LWORK is issued by XERBLA.  
 
   INFO    (output) INTEGER  
           = 0: successful exit  
           &lt; 0: if INFO = -i, the i-th argument had an illegal value  
           = 1,...,N: the QZ iteration did not converge.  (A,B) is not  
                      in Schur form, but ALPHAR(i), ALPHAI(i), and  
                      BETA(i), i=INFO+1,...,N should be correct.  
           = N+1,...,2*N: the shift calculation failed.  (A,B) is not  
                      in Schur form, but ALPHAR(i), ALPHAI(i), and  
                      BETA(i), i=INFO-N+1,...,N should be correct.  
           &gt; 2*N:     various &quot;impossible&quot; errors.  
 
   Further Details  
   ===============  
 
   Iteration counters:  
 
   JITER  -- counts iterations.  
   IITER  -- counts iterations run since ILAST was last  
             changed.  This is therefore reset only when a 1-by-1 or  
             2-by-2 block deflates off the bottom.  
 
   =====================================================================  
</PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>B[size(A, 1), size(A, 1)]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>alphaReal[size(A, 1)]</TD><TD>Real part of alpha (eigenvalue=(alphaReal+i*alphaImag)/beta)</TD></TR>
<TR><TD>alphaImag[size(A, 1)]</TD><TD>Imaginary part of alpha</TD></TR>
<TR><TD>beta[size(A, 1)]</TD><TD>Denominator of eigenvalue</TD></TR>
<TR><TD>info</TD><TD>&nbsp;</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE dhseqr<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.LAPACK.dhseqr"></A><A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</A>.dhseqr</H2>
<B>compute eingenvalues of a matrix A using lapack routine DHSEQR for Hessenberg form matrix</B><p>
<P><H3>Information</H3></P>
<PRE>    DHSEQR computes the eigenvalues of a real upper Hessenberg matrix H  
   and, optionally, the matrices T and Z from the Schur decomposition  
   H = Z T Z**T, where T is an upper quasi-triangular matrix (the Schur  
   form), and Z is the orthogonal matrix of Schur vectors.  
 
   Optionally Z may be postmultiplied into an input orthogonal matrix Q,  
   so that this routine can give the Schur factorization of a matrix A  
   which has been reduced to the Hessenberg form H by the orthogonal  
   matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.  
 
   Arguments  
   =========  
 
   JOB     (input) CHARACTER*1  
           = &#39;E&#39;:  compute eigenvalues only;  
           = &#39;S&#39;:  compute eigenvalues and the Schur form T.  
 
   COMPZ   (input) CHARACTER*1  
           = &#39;N&#39;:  no Schur vectors are computed;  
           = &#39;I&#39;:  Z is initialized to the unit matrix and the matrix Z  
                   of Schur vectors of H is returned;  
           = &#39;V&#39;:  Z must contain an orthogonal matrix Q on entry, and  
                   the product Q*Z is returned.  
 
   N       (input) INTEGER  
           The order of the matrix H.  N &gt;= 0.  
 
   ILO     (input) INTEGER  
   IHI     (input) INTEGER  
           It is assumed that H is already upper triangular in rows  
           and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally  
           set by a previous call to DGEBAL, and then passed to SGEHRD  
           when the matrix output by DGEBAL is reduced to Hessenberg  
           form. Otherwise ILO and IHI should be set to 1 and N  
           respectively.  
           1 &lt;= ILO &lt;= IHI &lt;= N, if N &gt; 0; ILO=1 and IHI=0, if N=0.  
 
   H       (input/output) DOUBLE PRECISION array, dimension (LDH,N)  
           On entry, the upper Hessenberg matrix H.  
           On exit, if JOB = &#39;S&#39;, H contains the upper quasi-triangular  
           matrix T from the Schur decomposition (the Schur form);  
           2-by-2 diagonal blocks (corresponding to complex conjugate  
           pairs of eigenvalues) are returned in standard form, with  
           H(i,i) = H(i+1,i+1) and H(i+1,i)*H(i,i+1) &lt; 0. If JOB = &#39;E&#39;,  
           the contents of H are unspecified on exit.  
 
   LDH     (input) INTEGER  
           The leading dimension of the array H. LDH &gt;= max(1,N).  
 
   WR      (output) DOUBLE PRECISION array, dimension (N)  
   WI      (output) DOUBLE PRECISION array, dimension (N)  
           The real and imaginary parts, respectively, of the computed  
           eigenvalues. If two eigenvalues are computed as a complex  
           conjugate pair, they are stored in consecutive elements of  
           WR and WI, say the i-th and (i+1)th, with WI(i) &gt; 0 and  
           WI(i+1) &lt; 0. If JOB = &#39;S&#39;, the eigenvalues are stored in the  
           same order as on the diagonal of the Schur form returned in  
           H, with WR(i) = H(i,i) and, if H(i:i+1,i:i+1) is a 2-by-2  
           diagonal block, WI(i) = sqrt(H(i+1,i)*H(i,i+1)) and  
           WI(i+1) = -WI(i).  
 
   Z       (input/output) DOUBLE PRECISION array, dimension (LDZ,N)  
           If COMPZ = &#39;N&#39;: Z is not referenced.  
           If COMPZ = &#39;I&#39;: on entry, Z need not be set, and on exit, Z  
           contains the orthogonal matrix Z of the Schur vectors of H.  
           If COMPZ = &#39;V&#39;: on entry Z must contain an N-by-N matrix Q,  
           which is assumed to be equal to the unit matrix except for  
           the submatrix Z(ILO:IHI,ILO:IHI); on exit Z contains Q*Z.  
           Normally Q is the orthogonal matrix generated by DORGHR after  
           the call to DGEHRD which formed the Hessenberg matrix H.  
 
   LDZ     (input) INTEGER  
           The leading dimension of the array Z.  
           LDZ &gt;= max(1,N) if COMPZ = &#39;I&#39; or &#39;V&#39;; LDZ &gt;= 1 otherwise.  
 
   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)  
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.  
 
   LWORK   (input) INTEGER  
           The dimension of the array WORK.  LWORK &gt;= max(1,N).  
 
           If LWORK = -1, then a workspace query is assumed; the routine  
           only calculates the optimal size of the WORK array, returns  
           this value as the first entry of the WORK array, and no error  
           message related to LWORK is issued by XERBLA.  
 
   INFO    (output) INTEGER  
           = 0:  successful exit  
           &lt; 0:  if INFO = -i, the i-th argument had an illegal value  
           &gt; 0:  if INFO = i, DHSEQR failed to compute all of the  
                 eigenvalues in a total of 30*(IHI-ILO+1) iterations;  
                 elements 1:ilo-1 and i+1:n of WR and WI contain those  
                 eigenvalues which have been successfully computed.  
 
   =====================================================================  </PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>H[:, size(H, 1)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>lwork</TD><TD>&nbsp;</TD></TR>
<TR><TD>eigenValuesOnly</TD><TD>&nbsp;</TD></TR>
<TR><TD>compz</TD><TD>&nbsp;</TD></TR>
<TR><TD>Z[:, :]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>alphaReal[size(H, 1)]</TD><TD>Real part of alpha (eigenvalue=(alphaReal+i*alphaImag))</TD></TR>
<TR><TD>alphaImag[size(H, 1)]</TD><TD>Imaginary part of alpha (eigenvalue=(alphaReal+i*alphaImag))</TD></TR>
<TR><TD>info</TD><TD>&nbsp;</TD></TR>
<TR><TD>Ho[:, :]</TD><TD>&nbsp;</TD></TR>
<TR><TD>Zo[:, :]</TD><TD>&nbsp;</TD></TR>
<TR><TD>work[max({lwork,size(H, 1),1})]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE dorghr<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.LAPACK.dorghr"></A><A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</A>.dorghr</H2>
<B>generates a real orthogonal matrix Q which is defined as the product of IHI-ILO elementary reflectors of order N, as returned by DGEHRD</B><p>
<P><H3>Information</H3></P>
<PRE> 
 
   Purpose  
   =======  
 
   DGEHRD reduces a real general matrix A to upper Hessenberg form H by  
   an orthogonal similarity transformation:  Q&#39; * A * Q = H .  
 
   Arguments  
   =========  
 
   N       (input) INTEGER  
           The order of the matrix A.  N &gt;= 0.  
 
   ILO     (input) INTEGER  
   IHI     (input) INTEGER  
           It is assumed that A is already upper triangular in rows  
           and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally  
           set by a previous call to DGEBAL; otherwise they should be  
           set to 1 and N respectively. See Further Details.  
           1 &lt;= ILO &lt;= IHI &lt;= N, if N &gt; 0; ILO=1 and IHI=0, if N=0.  
 
   A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)  
           On entry, the N-by-N general matrix to be reduced.  
           On exit, the upper triangle and the first subdiagonal of A  
           are overwritten with the upper Hessenberg matrix H, and the  
           elements below the first subdiagonal, with the array TAU,  
           represent the orthogonal matrix Q as a product of elementary  
           reflectors. See Further Details.  
 
   LDA     (input) INTEGER  
           The leading dimension of the array A.  LDA &gt;= max(1,N).  
 
   TAU     (output) DOUBLE PRECISION array, dimension (N-1)  
           The scalar factors of the elementary reflectors (see Further  
           Details). Elements 1:ILO-1 and IHI:N-1 of TAU are set to  
           zero.  
 
   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)  
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.  
 
   LWORK   (input) INTEGER  
           The length of the array WORK.  LWORK &gt;= max(1,N).  
           For optimum performance LWORK &gt;= N*NB, where NB is the  
           optimal blocksize.  
 
           If LWORK = -1, then a workspace query is assumed; the routine  
           only calculates the optimal size of the WORK array, returns  
           this value as the first entry of the WORK array, and no error  
           message related to LWORK is issued by XERBLA.  
 
   INFO    (output) INTEGER  
           = 0:  successful exit  
           &lt; 0:  if INFO = -i, the i-th argument had an illegal value.  
 
   Further Details  
   ===============  
 
   The matrix Q is represented as a product of (ihi-ilo) elementary  
   reflectors  
 
      Q = H(ilo) H(ilo+1) . . . H(ihi-1).  
 
   Each H(i) has the form  
 
      H(i) = I - tau * v * v&#39;  
 
   where tau is a real scalar, and v is a real vector with  
   v(1:i) = 0, v(i+1) = 1 and v(ihi+1:n) = 0; v(i+2:ihi) is stored on  
   exit in A(i+2:ihi,i), and tau in TAU(i).  
 
   The contents of A are illustrated by the following example, with  
   n = 7, ilo = 2 and ihi = 6:  
 
   on entry,                        on exit,  
 
   ( a   a   a   a   a   a   a )    (  a   a   h   h   h   h   a )  
   (     a   a   a   a   a   a )    (      a   h   h   h   h   a )  
   (     a   a   a   a   a   a )    (      h   h   h   h   h   h )  
   (     a   a   a   a   a   a )    (      v2  h   h   h   h   h )  
   (     a   a   a   a   a   a )    (      v2  v3  h   h   h   h )  
   (     a   a   a   a   a   a )    (      v2  v3  v4  h   h   h )  
   (                         a )    (                          a )  
 
   where a denotes an element of the original matrix A, h denotes a  
   modified element of the upper Hessenberg matrix H, and vi denotes an  
   element of the vector defining H(i).  
 
   =====================================================================  
</PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>ilo</TD><TD>lowest index where the original matrix had been Hessenbergform - ilo must have the same value as in the previous call of DGEHRD</TD></TR>
<TR><TD>ihi</TD><TD>highest index where the original matrix had been Hessenbergform  - ihi must have the same value as in the previous call of DGEHRD</TD></TR>
<TR><TD>tau[size(A, 1) - 1]</TD><TD>scalar factors of the elementary reflectors</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Aout[size(A, 1), size(A, 2)]</TD><TD>Orthogonal matrix as a result of elementary reflectors</TD></TR>
<TR><TD>info</TD><TD>&nbsp;</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE dorgqr<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.LAPACK.dorgqr"></A><A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</A>.dorgqr</H2>
<B>generates a real orthogonal matrix Q which is defined as the product of elementary reflectors, as returned by DGEQRF</B><p>
<P><H3>Information</H3></P>
<PRE>   Purpose  
   =======  
 
   DORGQR generates an M-by-N real matrix Q with orthonormal columns,  
   which is defined as the first N columns of a product of K elementary  
   reflectors of order M  
 
         Q  =  H(1) H(2) . . . H(k)  
 
   as returned by DGEQRF.  
 
   Arguments  
   =========  
 
   M       (input) INTEGER  
           The number of rows of the matrix Q. M &gt;= 0.  
 
   N       (input) INTEGER  
           The number of columns of the matrix Q. M &gt;= N &gt;= 0.  
 
   K       (input) INTEGER  
           The number of elementary reflectors whose product defines the  
           matrix Q. N &gt;= K &gt;= 0.  
 
   A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)  
           On entry, the i-th column must contain the vector which  
           defines the elementary reflector H(i), for i = 1,2,...,k, as  
           returned by DGEQRF in the first k columns of its array  
           argument A.  
           On exit, the M-by-N matrix Q.  
 
   LDA     (input) INTEGER  
           The first dimension of the array A. LDA &gt;= max(1,M).  
 
   TAU     (input) DOUBLE PRECISION array, dimension (K)  
           TAU(i) must contain the scalar factor of the elementary  
           reflector H(i), as returned by DGEQRF.  
 
   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)  
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.  
 
   LWORK   (input) INTEGER  
           The dimension of the array WORK. LWORK &gt;= max(1,N).  
           For optimum performance LWORK &gt;= N*NB, where NB is the  
           optimal blocksize.  
 
           If LWORK = -1, then a workspace query is assumed; the routine  
           only calculates the optimal size of the WORK array, returns  
           this value as the first entry of the WORK array, and no error  
           message related to LWORK is issued by XERBLA.  
 
   INFO    (output) INTEGER  
           = 0:  successful exit  
           &lt; 0:  if INFO = -i, the i-th argument has an illegal value  
 
   =====================================================================  
</PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Q[:, :]</TD><TD>Orthogonal matrix as a result of elementary reflectors</TD></TR>
<TR><TD>tau[:]</TD><TD>scalar factors of the elementary reflectors</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Qout[size(Q, 1), size(Q, 2)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>info</TD><TD>&nbsp;</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE dorgqr_x<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.LAPACK.dorgqr_x"></A><A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</A>.dorgqr_x</H2>
<B>generates a real orthogonal matrix Q which is defined as the product of elementary reflectors, as returned by DGEQRF</B><p>
<P><H3>Information</H3></P>
<PRE>   Purpose  
   =======  
 
   DORGQR generates an M-by-N real matrix Q with orthonormal columns,  
   which is defined as the first N columns of a product of K elementary  
   reflectors of order M  
 
         Q  =  H(1) H(2) . . . H(k)  
 
   as returned by DGEQRF.  
 
   Arguments  
   =========  
 
   M       (input) INTEGER  
           The number of rows of the matrix Q. M &gt;= 0.  
 
   N       (input) INTEGER  
           The number of columns of the matrix Q. M &gt;= N &gt;= 0.  
 
   K       (input) INTEGER  
           The number of elementary reflectors whose product defines the  
           matrix Q. N &gt;= K &gt;= 0.  
 
   A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)  
           On entry, the i-th column must contain the vector which  
           defines the elementary reflector H(i), for i = 1,2,...,k, as  
           returned by DGEQRF in the first k columns of its array  
           argument A.  
           On exit, the M-by-N matrix Q.  
 
   LDA     (input) INTEGER  
           The first dimension of the array A. LDA &gt;= max(1,M).  
 
   TAU     (input) DOUBLE PRECISION array, dimension (K)  
           TAU(i) must contain the scalar factor of the elementary  
           reflector H(i), as returned by DGEQRF.  
 
   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)  
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.  
 
   LWORK   (input) INTEGER  
           The dimension of the array WORK. LWORK &gt;= max(1,N).  
           For optimum performance LWORK &gt;= N*NB, where NB is the  
           optimal blocksize.  
 
           If LWORK = -1, then a workspace query is assumed; the routine  
           only calculates the optimal size of the WORK array, returns  
           this value as the first entry of the WORK array, and no error  
           message related to LWORK is issued by XERBLA.  
 
   INFO    (output) INTEGER  
           = 0:  successful exit  
           &lt; 0:  if INFO = -i, the i-th argument has an illegal value  
 
   =====================================================================  
</PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Q[:, :]</TD><TD>Orthogonal matrix as a result of elementary reflectors</TD></TR>
<TR><TD>tau[:]</TD><TD>scalar factors of the elementary reflectors</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Aout[size(Q, 1), size(Q, 1)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>info</TD><TD>&nbsp;</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE dormhr<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.LAPACK.dormhr"></A><A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</A>.dormhr</H2>
<B>overwrites the general real M-by-N matrix C with Q * C or C * Q or Q&#39; * C or C * Q&#39;, where Q is an orthogonal matrix as returne by dgehrd</B><p>
<P><H3>Information</H3></P>
<PRE> 
   Purpose  
   =======  
 
     DORMHR overwrites the general real M-by-N matrix C with  
 
                   SIDE = &#39;L&#39;     SIDE = &#39;R&#39;  
   TRANS = &#39;N&#39;:      Q * C          C * Q  
   TRANS = &#39;T&#39;:      Q**T * C       C * Q**T  
 
   where Q is a real orthogonal matrix of order nq, with nq = m if  
   SIDE = &#39;L&#39; and nq = n if SIDE = &#39;R&#39;. Q is defined as the product of  
   IHI-ILO elementary reflectors, as returned by DGEHRD:  
 
   Q = H(ilo) H(ilo+1) . . . H(ihi-1).  
 
   Arguments  
   =========  
 
   SIDE    (input) CHARACTER*1  
           = &#39;L&#39;: apply Q or Q**T from the Left;  
           = &#39;R&#39;: apply Q or Q**T from the Right.  
 
   TRANS   (input) CHARACTER*1  
           = &#39;N&#39;:  No transpose, apply Q;  
           = &#39;T&#39;:  Transpose, apply Q**T.  
 
   M       (input) INTEGER  
           The number of rows of the matrix C. M &gt;= 0.  
 
   N       (input) INTEGER  
           The number of columns of the matrix C. N &gt;= 0.  
 
   ILO     (input) INTEGER  
   IHI     (input) INTEGER  
           ILO and IHI must have the same values as in the previous call  
           of DGEHRD. Q is equal to the unit matrix except in the  
           submatrix Q(ilo+1:ihi,ilo+1:ihi).  
           If SIDE = &#39;L&#39;, then 1 &lt;= ILO &lt;= IHI &lt;= M, if M &gt; 0, and  
           ILO = 1 and IHI = 0, if M = 0;  
           if SIDE = &#39;R&#39;, then 1 &lt;= ILO &lt;= IHI &lt;= N, if N &gt; 0, and  
           ILO = 1 and IHI = 0, if N = 0.  
 
   A       (input) DOUBLE PRECISION array, dimension  
                                (LDA,M) if SIDE = &#39;L&#39;  
                                (LDA,N) if SIDE = &#39;R&#39;  
           The vectors which define the elementary reflectors, as  
           returned by DGEHRD.  
 
   LDA     (input) INTEGER  
           The leading dimension of the array A.  
           LDA &gt;= max(1,M) if SIDE = &#39;L&#39;; LDA &gt;= max(1,N) if SIDE = &#39;R&#39;.  
 
   TAU     (input) DOUBLE PRECISION array, dimension  
                                (M-1) if SIDE = &#39;L&#39;  
                                (N-1) if SIDE = &#39;R&#39;  
           TAU(i) must contain the scalar factor of the elementary  
           reflector H(i), as returned by DGEHRD.  
 
   C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)  
           On entry, the M-by-N matrix C.  
           On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.  
 
   LDC     (input) INTEGER  
           The leading dimension of the array C. LDC &gt;= max(1,M).  
 
   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)  
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.  
 
   LWORK   (input) INTEGER  
           The dimension of the array WORK.  
           If SIDE = &#39;L&#39;, LWORK &gt;= max(1,N);  
           if SIDE = &#39;R&#39;, LWORK &gt;= max(1,M).  
           For optimum performance LWORK &gt;= N*NB if SIDE = &#39;L&#39;, and  
           LWORK &gt;= M*NB if SIDE = &#39;R&#39;, where NB is the optimal  
           blocksize.  
 
           If LWORK = -1, then a workspace query is assumed; the routine  
           only calculates the optimal size of the WORK array, returns  
           this value as the first entry of the WORK array, and no error  
           message related to LWORK is issued by XERBLA.  
 
   INFO    (output) INTEGER  
           = 0:  successful exit  
           &lt; 0:  if INFO = -i, the i-th argument had an illegal value  
 
   =====================================================================  </PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>C[:, :]</TD><TD>&nbsp;</TD></TR>
<TR><TD>A[:, :]</TD><TD>&nbsp;</TD></TR>
<TR><TD>tau[size(A, 2) - 1]</TD><TD>&nbsp;</TD></TR>
<TR><TD>side</TD><TD>&nbsp;</TD></TR>
<TR><TD>trans</TD><TD>&nbsp;</TD></TR>
<TR><TD>ilo</TD><TD>lowest index where the original matrix had been Hessenbergform</TD></TR>
<TR><TD>ihi</TD><TD>highest index where the original matrix had been Hessenbergform</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Cout[size(C, 1), size(C, 2)]</TD><TD>contains the Hessenberg form in the upper triangle and the first subdiagonal and below the first subdiagonal it contains the elementary reflectors which represents (with array tau) as a product the orthogonal matrix Q</TD></TR>
<TR><TD>info</TD><TD>&nbsp;</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE dormqr<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.LAPACK.dormqr"></A><A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</A>.dormqr</H2>
<B>overwrites the general real M-by-N matrix C with Q * C or C * Q or Q&#39; * C or C * Q&#39;, where Q is an orthogonal matrix of a QR factorization as returned by dgeqrf</B><p>
<P><H3>Information</H3></P>
<PRE>   Purpose  
   =======  
 
   DORMQR overwrites the general real M-by-N matrix C with  
 
                   SIDE = &#39;L&#39;     SIDE = &#39;R&#39;  
   TRANS = &#39;N&#39;:      Q * C          C * Q  
   TRANS = &#39;T&#39;:      Q**T * C       C * Q**T  
 
   where Q is a real orthogonal matrix defined as the product of k  
   elementary reflectors  
 
         Q = H(1) H(2) . . . H(k)  
 
   as returned by DGEQRF. Q is of order M if SIDE = &#39;L&#39; and of order N  
   if SIDE = &#39;R&#39;.  
 
   Arguments  
   =========  
 
   SIDE    (input) CHARACTER*1  
           = &#39;L&#39;: apply Q or Q**T from the Left;  
           = &#39;R&#39;: apply Q or Q**T from the Right.  
 
   TRANS   (input) CHARACTER*1  
           = &#39;N&#39;:  No transpose, apply Q;  
           = &#39;T&#39;:  Transpose, apply Q**T.  
 
   M       (input) INTEGER  
           The number of rows of the matrix C. M &gt;= 0.  
 
   N       (input) INTEGER  
           The number of columns of the matrix C. N &gt;= 0.  
 
   K       (input) INTEGER  
           The number of elementary reflectors whose product defines  
           the matrix Q.  
           If SIDE = &#39;L&#39;, M &gt;= K &gt;= 0;  
           if SIDE = &#39;R&#39;, N &gt;= K &gt;= 0.  
 
   A       (input) DOUBLE PRECISION array, dimension (LDA,K)  
           The i-th column must contain the vector which defines the  
           elementary reflector H(i), for i = 1,2,...,k, as returned by  
           DGEQRF in the first k columns of its array argument A.  
           A is modified by the routine but restored on exit.  
 
   LDA     (input) INTEGER  
           The leading dimension of the array A.  
           If SIDE = &#39;L&#39;, LDA &gt;= max(1,M);  
           if SIDE = &#39;R&#39;, LDA &gt;= max(1,N).  
 
   TAU     (input) DOUBLE PRECISION array, dimension (K)  
           TAU(i) must contain the scalar factor of the elementary  
           reflector H(i), as returned by DGEQRF.  
 
   C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)  
           On entry, the M-by-N matrix C.  
           On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.  
 
   LDC     (input) INTEGER  
           The leading dimension of the array C. LDC &gt;= max(1,M).  
 
   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)  
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.  
 
   LWORK   (input) INTEGER  
           The dimension of the array WORK.  
           If SIDE = &#39;L&#39;, LWORK &gt;= max(1,N);  
           if SIDE = &#39;R&#39;, LWORK &gt;= max(1,M).  
           For optimum performance LWORK &gt;= N*NB if SIDE = &#39;L&#39;, and  
           LWORK &gt;= M*NB if SIDE = &#39;R&#39;, where NB is the optimal  
           blocksize.  
 
           If LWORK = -1, then a workspace query is assumed; the routine  
           only calculates the optimal size of the WORK array, returns  
           this value as the first entry of the WORK array, and no error  
           message related to LWORK is issued by XERBLA.  
 
   INFO    (output) INTEGER  
           = 0:  successful exit  
           &lt; 0:  if INFO = -i, the i-th argument had an illegal value  
 
   =====================================================================  </PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>C[:, :]</TD><TD>&nbsp;</TD></TR>
<TR><TD>A[:, :]</TD><TD>&nbsp;</TD></TR>
<TR><TD>tau[:]</TD><TD>&nbsp;</TD></TR>
<TR><TD>side</TD><TD>&nbsp;</TD></TR>
<TR><TD>trans</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Cout[size(C, 1), size(C, 2)]</TD><TD>contains Q*C or Q**T*C or C*Q**T or C*Q</TD></TR>
<TR><TD>info</TD><TD>&nbsp;</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE dtrevc<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.LAPACK.dtrevc"></A><A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</A>.dtrevc</H2>
<B>compute the right and/or left eigenvectors of a real upper quasi-triangular matrix T</B><p>
<P><H3>Information</H3></P>
<PRE>    /*  DTREVC computes some or all of the right and/or left eigenvectors of 
 a real upper quasi-triangular matrix T. 
 Matrices of this type are produced by the Schur factorization of 
 a real general matrix:  A = Q*T*Q**T, as computed by DHSEQR. 
 
 The right eigenvector x and the left eigenvector y of T corresponding 
 to an eigenvalue w are defined by: 
 
    T*x = w*x,     (y**H)*T = w*(y**H) 
 
 where y**H denotes the conjugate transpose of y. 
 The eigenvalues are not input to this routine, but are read directly 
 from the diagonal blocks of T. 
 
 This routine returns the matrices X and/or Y of right and left 
 eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an 
 input matrix.  If Q is the orthogonal factor that reduces a matrix 
 A to Schur form T, then Q*X and Q*Y are the matrices of right and 
 left eigenvectors of A. 
 
 Arguments 
 ========= 
 
 SIDE    (input) CHARACTER*1 
         = &#39;R&#39;:  compute right eigenvectors only; 
         = &#39;L&#39;:  compute left eigenvectors only; 
         = &#39;B&#39;:  compute both right and left eigenvectors. 
 
 HOWMNY  (input) CHARACTER*1 
         = &#39;A&#39;:  compute all right and/or left eigenvectors; 
         = &#39;B&#39;:  compute all right and/or left eigenvectors, 
                 backtransformed by the matrices in VR and/or VL; 
         = &#39;S&#39;:  compute selected right and/or left eigenvectors, 
                 as indicated by the logical array SELECT. 
 
 SELECT  (input/output) LOGICAL array, dimension (N) 
         If HOWMNY = &#39;S&#39;, SELECT specifies the eigenvectors to be 
         computed. 
         If w(j) is a real eigenvalue, the corresponding real 
         eigenvector is computed if SELECT(j) is .TRUE.. 
         If w(j) and w(j+1) are the real and imaginary parts of a 
         complex eigenvalue, the corresponding complex eigenvector is 
         computed if either SELECT(j) or SELECT(j+1) is .TRUE., and 
         on exit SELECT(j) is set to .TRUE. and SELECT(j+1) is set to 
         .FALSE.. 
         Not referenced if HOWMNY = &#39;A&#39; or &#39;B&#39;. 
 
 N       (input) INTEGER 
         The order of the matrix T. N &gt;= 0. 
 
 T       (input) DOUBLE PRECISION array, dimension (LDT,N) 
         The upper quasi-triangular matrix T in Schur canonical form. 
 
 LDT     (input) INTEGER 
         The leading dimension of the array T. LDT &gt;= max(1,N). 
 
 VL      (input/output) DOUBLE PRECISION array, dimension (LDVL,MM) 
         On entry, if SIDE = &#39;L&#39; or &#39;B&#39; and HOWMNY = &#39;B&#39;, VL must 
         contain an N-by-N matrix Q (usually the orthogonal matrix Q 
         of Schur vectors returned by DHSEQR). 
         On exit, if SIDE = &#39;L&#39; or &#39;B&#39;, VL contains: 
         if HOWMNY = &#39;A&#39;, the matrix Y of left eigenvectors of T; 
         if HOWMNY = &#39;B&#39;, the matrix Q*Y; 
         if HOWMNY = &#39;S&#39;, the left eigenvectors of T specified by 
                          SELECT, stored consecutively in the columns 
                          of VL, in the same order as their 
                          eigenvalues. 
         A complex eigenvector corresponding to a complex eigenvalue 
         is stored in two consecutive columns, the first holding the 
         real part, and the second the imaginary part. 
         Not referenced if SIDE = &#39;R&#39;. 
 
 LDVL    (input) INTEGER 
         The leading dimension of the array VL.  LDVL &gt;= 1, and if 
         SIDE = &#39;L&#39; or &#39;B&#39;, LDVL &gt;= N. 
 
 VR      (input/output) DOUBLE PRECISION array, dimension (LDVR,MM) 
         On entry, if SIDE = &#39;R&#39; or &#39;B&#39; and HOWMNY = &#39;B&#39;, VR must 
         contain an N-by-N matrix Q (usually the orthogonal matrix Q 
         of Schur vectors returned by DHSEQR). 
         On exit, if SIDE = &#39;R&#39; or &#39;B&#39;, VR contains: 
         if HOWMNY = &#39;A&#39;, the matrix X of right eigenvectors of T; 
         if HOWMNY = &#39;B&#39;, the matrix Q*X; 
         if HOWMNY = &#39;S&#39;, the right eigenvectors of T specified by 
                          SELECT, stored consecutively in the columns 
                          of VR, in the same order as their 
                          eigenvalues. 
         A complex eigenvector corresponding to a complex eigenvalue 
         is stored in two consecutive columns, the first holding the 
         real part and the second the imaginary part. 
         Not referenced if SIDE = &#39;L&#39;. 
 
 LDVR    (input) INTEGER 
         The leading dimension of the array VR.  LDVR &gt;= 1, and if 
         SIDE = &#39;R&#39; or &#39;B&#39;, LDVR &gt;= N. 
 
 MM      (input) INTEGER 
         The number of columns in the arrays VL and/or VR. MM &gt;= M. 
 
 M       (output) INTEGER 
         The number of columns in the arrays VL and/or VR actually 
         used to store the eigenvectors. 
         If HOWMNY = &#39;A&#39; or &#39;B&#39;, M is set to N. 
         Each selected real eigenvector occupies one column and each 
         selected complex eigenvector occupies two columns. 
 
 WORK    (workspace) DOUBLE PRECISION array, dimension (3*N) 
 
 INFO    (output) INTEGER 
         = 0:  successful exit 
         &lt; 0:  if INFO = -i, the i-th argument had an illegal value 
 
 Further Details 
 =============== 
 
 The algorithm used in this program is basically backward (forward) 
 substitution, with scaling to make the the code robust against 
 possible overflow. 
 
 Each eigenvector is normalized so that the element of largest 
 magnitude has magnitude 1; here the magnitude of a complex number 
 (x,y) is taken to be |x| + |y|. 
 
   =====================================================================  </PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>T[:, size(T, 1)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>side</TD><TD>&nbsp;</TD></TR>
<TR><TD>howmny</TD><TD>&nbsp;</TD></TR>
<TR><TD>Q[size(T, 1), size(T, 1)]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>lEigenVectors[size(T, 1), size(T, 1)]</TD><TD>left eigenvectors of matrix T</TD></TR>
<TR><TD>rEigenVectors[size(T, 1), size(T, 1)]</TD><TD>right eigenvectors of matrix T</TD></TR>
<TR><TD>info</TD><TD>&nbsp;</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE dtrsen<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.LAPACK.dtrsen"></A><A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</A>.dtrsen</H2>
<B>DTRSEN reorders the real Schur factorization of a real matrix</B><p>
<P><H3>Information</H3></P>
<PRE>   
   Purpose  
   =======  
 
     DTRSEN reorders the real Schur factorization of a real matrix  
   A = Q*T*Q**T, so that a selected cluster of eigenvalues appears in  
   the leading diagonal blocks of the upper quasi-triangular matrix T,  
   and the leading columns of Q form an orthonormal basis of the  
   corresponding right invariant subspace.  
 
   Optionally the routine computes the reciprocal condition numbers of  
   the cluster of eigenvalues and/or the invariant subspace.  
 
   T must be in Schur canonical form (as returned by DHSEQR), that is,  
   block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each  
   2-by-2 diagonal block has its diagonal elemnts equal and its  
   off-diagonal elements of opposite sign.  
 
   Arguments  
   =========  
 
   JOB     (input) CHARACTER*1  
           Specifies whether condition numbers are required for the  
           cluster of eigenvalues (S) or the invariant subspace (SEP):  
           = &#39;N&#39;: none;  
           = &#39;E&#39;: for eigenvalues only (S);  
           = &#39;V&#39;: for invariant subspace only (SEP);  
           = &#39;B&#39;: for both eigenvalues and invariant subspace (S and  
                  SEP).  
 
   COMPQ   (input) CHARACTER*1  
           = &#39;V&#39;: update the matrix Q of Schur vectors;  
           = &#39;N&#39;: do not update Q.  
 
   SELECT  (input) LOGICAL array, dimension (N)  
           SELECT specifies the eigenvalues in the selected cluster. To  
           select a real eigenvalue w(j), SELECT(j) must be set to  
           .TRUE.. To select a complex conjugate pair of eigenvalues  
           w(j) and w(j+1), corresponding to a 2-by-2 diagonal block,  
           either SELECT(j) or SELECT(j+1) or both must be set to  
           .TRUE.; a complex conjugate pair of eigenvalues must be  
           either both included in the cluster or both excluded.  
 
   N       (input) INTEGER  
           The order of the matrix T. N &gt;= 0.  
 
   T       (input/output) DOUBLE PRECISION array, dimension (LDT,N)  
           On entry, the upper quasi-triangular matrix T, in Schur  
           canonical form.  
           On exit, T is overwritten by the reordered matrix T, again in  
           Schur canonical form, with the selected eigenvalues in the  
           leading diagonal blocks.  
 
   LDT     (input) INTEGER  
           The leading dimension of the array T. LDT &gt;= max(1,N).  
 
   Q       (input/output) DOUBLE PRECISION array, dimension (LDQ,N)  
           On entry, if COMPQ = &#39;V&#39;, the matrix Q of Schur vectors.  
           On exit, if COMPQ = &#39;V&#39;, Q has been postmultiplied by the  
           orthogonal transformation matrix which reorders T; the  
           leading M columns of Q form an orthonormal basis for the  
           specified invariant subspace.  
           If COMPQ = &#39;N&#39;, Q is not referenced.  
 
   LDQ     (input) INTEGER  
           The leading dimension of the array Q.  
           LDQ &gt;= 1; and if COMPQ = &#39;V&#39;, LDQ &gt;= N.  
 
   WR      (output) DOUBLE PRECISION array, dimension (N)  
   WI      (output) DOUBLE PRECISION array, dimension (N)  
           The real and imaginary parts, respectively, of the reordered  
           eigenvalues of T. The eigenvalues are stored in the same  
           order as on the diagonal of T, with WR(i) = T(i,i) and, if  
           T(i:i+1,i:i+1) is a 2-by-2 diagonal block, WI(i) &gt; 0 and  
           WI(i+1) = -WI(i). Note that if a complex eigenvalue is  
           sufficiently ill-conditioned, then its value may differ  
           significantly from its value before reordering.  
 
   M       (output) INTEGER  
           The dimension of the specified invariant subspace.  
           0 &lt; = M &lt;= N.  
 
   S       (output) DOUBLE PRECISION  
           If JOB = &#39;E&#39; or &#39;B&#39;, S is a lower bound on the reciprocal  
           condition number for the selected cluster of eigenvalues.  
           S cannot underestimate the true reciprocal condition number  
           by more than a factor of sqrt(N). If M = 0 or N, S = 1.  
           If JOB = &#39;N&#39; or &#39;V&#39;, S is not referenced.  
 
   SEP     (output) DOUBLE PRECISION  
           If JOB = &#39;V&#39; or &#39;B&#39;, SEP is the estimated reciprocal  
           condition number of the specified invariant subspace. If  
           M = 0 or N, SEP = norm(T).  
           If JOB = &#39;N&#39; or &#39;E&#39;, SEP is not referenced.  
 
   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)  
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.  
 
   LWORK   (input) INTEGER  
           The dimension of the array WORK.  
           If JOB = &#39;N&#39;, LWORK &gt;= max(1,N);  
           if JOB = &#39;E&#39;, LWORK &gt;= M*(N-M);  
           if JOB = &#39;V&#39; or &#39;B&#39;, LWORK &gt;= 2*M*(N-M).  
 
           If LWORK = -1, then a workspace query is assumed; the routine  
           only calculates the optimal size of the WORK array, returns  
           this value as the first entry of the WORK array, and no error  
           message related to LWORK is issued by XERBLA.  
 
   IWORK   (workspace) INTEGER array, dimension (LIWORK)  
           IF JOB = &#39;N&#39; or &#39;E&#39;, IWORK is not referenced.  
 
   LIWORK  (input) INTEGER  
           The dimension of the array IWORK.  
           If JOB = &#39;N&#39; or &#39;E&#39;, LIWORK &gt;= 1;  
           if JOB = &#39;V&#39; or &#39;B&#39;, LIWORK &gt;= M*(N-M).  
 
           If LIWORK = -1, then a workspace query is assumed; the  
           routine only calculates the optimal size of the IWORK array,  
           returns this value as the first entry of the IWORK array, and  
           no error message related to LIWORK is issued by XERBLA.  
 
   INFO    (output) INTEGER  
           = 0: successful exit  
           &lt; 0: if INFO = -i, the i-th argument had an illegal value  
           = 1: reordering of T failed because some eigenvalues are too  
                close to separate (the problem is very ill-conditioned);  
                T may have been partially reordered, and WR and WI  
                contain the eigenvalues in the same order as in T; S and  
                SEP (if requested) are set to zero.  
 
   Further Details  
   ===============  
 
   DTRSEN first collects the selected eigenvalues by computing an  
   orthogonal transformation Z to move them to the top left corner of T.  
   In other words, the selected eigenvalues are the eigenvalues of T11  
   in:  
 
                 Z&#39;*T*Z = ( T11 T12 ) n1  
                          (  0  T22 ) n2  
                             n1  n2  
 
   where N = n1+n2 and Z&#39; means the transpose of Z. The first n1 columns  
   of Z span the specified invariant subspace of T.  
 
   If T has been obtained from the real Schur factorization of a matrix  
   A = Q*T*Q&#39;, then the reordered real Schur factorization of A is given  
   by A = (Q*Z)*(Z&#39;*T*Z)*(Q*Z)&#39;, and the first n1 columns of Q*Z span  
   the corresponding invariant subspace of A.  
 
   The reciprocal condition number of the average of the eigenvalues of  
   T11 may be returned in S. S lies between 0 (very badly conditioned)  
   and 1 (very well conditioned). It is computed as follows. First we  
   compute R so that  
 
                          P = ( I  R ) n1  
                              ( 0  0 ) n2  
                                n1 n2  
 
   is the projector on the invariant subspace associated with T11.  
   R is the solution of the Sylvester equation:  
 
                         T11*R - R*T22 = T12.  
 
   Let F-norm(M) denote the Frobenius-norm of M and 2-norm(M) denote  
   the two-norm of M. Then S is computed as the lower bound  
 
                       (1 + F-norm(R)**2)**(-1/2)  
 
   on the reciprocal of 2-norm(P), the true reciprocal condition number.  
   S cannot underestimate 1 / 2-norm(P) by more than a factor of  
   sqrt(N).  
 
   An approximate error bound for the computed average of the  
   eigenvalues of T11 is  
 
                          EPS * norm(T) / S  
 
   where EPS is the machine precision.  
 
   The reciprocal condition number of the right invariant subspace  
   spanned by the first n1 columns of Z (or of Q*Z) is returned in SEP.  
   SEP is defined as the separation of T11 and T22:  
 
                      sep( T11, T22 ) = sigma-min( C )  
 
   where sigma-min(C) is the smallest singular value of the  
   n1*n2-by-n1*n2 matrix  
 
      C  = kprod( I(n2), T11 ) - kprod( transpose(T22), I(n1) )  
 
   I(m) is an m by m identity matrix, and kprod denotes the Kronecker  
   product. We estimate sigma-min(C) by the reciprocal of an estimate of  
   the 1-norm of inverse(C). The true reciprocal 1-norm of inverse(C)  
   cannot differ from sigma-min(C) by more than a factor of sqrt(n1*n2).  
 
   When SEP is small, small changes in T can cause large changes in  
   the invariant subspace. An approximate bound on the maximum angular  
   error in the computed right invariant subspace is  
 
                       EPS * norm(T) / SEP  
 
   =====================================================================  </PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>job</TD><TD>&nbsp;</TD></TR>
<TR><TD>compq</TD><TD>&nbsp;</TD></TR>
<TR><TD>select[:]</TD><TD>&nbsp;</TD></TR>
<TR><TD>T[:, :]</TD><TD>&nbsp;</TD></TR>
<TR><TD>Q[:, size(T, 2)]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>To[:, :]</TD><TD>&nbsp;</TD></TR>
<TR><TD>Qo[:, :]</TD><TD>&nbsp;</TD></TR>
<TR><TD>wr[size(T, 2)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>wi[size(T, 2)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>m</TD><TD>&nbsp;</TD></TR>
<TR><TD>s</TD><TD>&nbsp;</TD></TR>
<TR><TD>sep</TD><TD>&nbsp;</TD></TR>
<TR><TD>info</TD><TD>&nbsp;</TD></TR>
</TABLE>
<address>HTML-documentation generated by <a href="http://www.Dymola.com/">Dymola</a> Tue Sep 08 18:52:57 2009.
</address></BODY>
</HTML>
