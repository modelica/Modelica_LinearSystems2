<HTML>
<HEAD>
<TITLE>Modelica_LinearSystems2.Math.Matrices</TITLE>
<META name="HTML-Generator" content="Dymola">
<META name="description" content="&quot;Additional functions for Modelica.Math&quot;">
<style type="text/css">
*       { font-size: 10pt; font-family: Arial,sans-serif; }
pre     { font-size:  9pt; font-family: Courier,monospace;}
h4      { font-size: 10pt; font-weight: bold; color: green; }
h3      { font-size: 11pt; font-weight: bold; color: green; }
h2      { font-size: 13pt; font-weight: bold; color: green; }
address {                  font-weight: normal} 
td      { solid #000; vertical-align:top; }
th      { solid #000; vertical-align:top; font-weight: bold; }
table   { solid #000; border-collapse: collapse;}
</style>
</HEAD>
<BODY><P>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE Matrices<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices"></A><A HREF="Modelica_LinearSystems2_Math.html#Modelica_LinearSystems2.Math"
>Modelica_LinearSystems2.Math</A>.Matrices</H2>
<B>Additional functions for Modelica.Math</B>
<P>
<P><H3>Information</H3></P>
Extends from Modelica.Icons.Package (Icon for standard packages).
<P><H3>Package Content</H3><p>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2 >
<TR><TH >Name</TH><TH>Description</TH></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.LAPACKS.png" ALT="Modelica_LinearSystems2.Math.Matrices.LAPACK" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>LAPACK</A>
</TD><TD>&nbsp;</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.ExamplesS.png" ALT="Modelica_LinearSystems2.Math.Matrices.Examples" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices_Examples.html#Modelica_LinearSystems2.Math.Matrices.Examples"
>Examples</A>
</TD><TD>&nbsp;</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.careS.png" ALT="Modelica_LinearSystems2.Math.Matrices.care" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.care"
>care</A>
</TD><TD>Solution of continuous-time algebraic Riccati equations</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.careS.png" ALT="Modelica_LinearSystems2.Math.Matrices.dare" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.dare"
>dare</A>
</TD><TD>Solution of discrete-time algebraic Riccati equations</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.careS.png" ALT="Modelica_LinearSystems2.Math.Matrices.sylvester" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.sylvester"
>sylvester</A>
</TD><TD>Solution of continuous-time Sylvester equation A*X + X*B = C</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.careS.png" ALT="Modelica_LinearSystems2.Math.Matrices.dsylvester" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.dsylvester"
>dsylvester</A>
</TD><TD>Solution of discrete-time Sylvester equation A*X*B + sgn*X = C</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.careS.png" ALT="Modelica_LinearSystems2.Math.Matrices.lyapunov" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.lyapunov"
>lyapunov</A>
</TD><TD>Solution of continuous-time Lyapunov equation X*A + A&#39;*X = C</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.careS.png" ALT="Modelica_LinearSystems2.Math.Matrices.dlyapunov" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.dlyapunov"
>dlyapunov</A>
</TD><TD>Solution of continuous-time Lyapunov equation A&#39;X*A - X = C</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.conditionNumberS.png" ALT="Modelica_LinearSystems2.Math.Matrices.conditionNumber" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.conditionNumber"
>conditionNumber</A>
</TD><TD>Calculate the condition number norm(A)*norm(inv(A))</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.conditionNumberS.png" ALT="Modelica_LinearSystems2.Math.Matrices.rcond" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.rcond"
>rcond</A>
</TD><TD>Reciprocal condition number</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.conditionNumberS.png" ALT="Modelica_LinearSystems2.Math.Matrices.det" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.det"
>det</A>
</TD><TD>Determinant of a matrix (computed by LU decomposition)</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.conditionNumberS.png" ALT="Modelica_LinearSystems2.Math.Matrices.norm" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.norm"
>norm</A>
</TD><TD>Returns the norm of a matrix</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.conditionNumberS.png" ALT="Modelica_LinearSystems2.Math.Matrices.nullspace" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.nullspace"
>nullspace</A>
</TD><TD>Orthonormal nullspace of a matrix</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.conditionNumberS.png" ALT="Modelica_LinearSystems2.Math.Matrices.eigenValues" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.eigenValues"
>eigenValues</A>
</TD><TD>Compute eigenvalues and eigenvectors for a real, nonsymmetric matrix</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.conditionNumberS.png" ALT="Modelica_LinearSystems2.Math.Matrices.equalityLeastSquares" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.equalityLeastSquares"
>equalityLeastSquares</A>
</TD><TD>Solve a linear equality constrained least squares problem</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.conditionNumberS.png" ALT="Modelica_LinearSystems2.Math.Matrices.solve" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.solve"
>solve</A>
</TD><TD>Solve real system of linear equations A*x=b with a b vector (Gaussian elemination with partial pivoting)</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.conditionNumberS.png" ALT="Modelica_LinearSystems2.Math.Matrices.solve2" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.solve2"
>solve2</A>
</TD><TD>Solve real system of linear equations A*X=B with a B matrix (Gaussian elemination with partial pivoting)</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.conditionNumberS.png" ALT="Modelica_LinearSystems2.Math.Matrices.solve2r" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.solve2r"
>solve2r</A>
</TD><TD>Solve real system of linear equations X*op(A)=B with a B matrix (Gaussian elemination with partial pivoting)</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.conditionNumberS.png" ALT="Modelica_LinearSystems2.Math.Matrices.LU" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.LU"
>LU</A>
</TD><TD>LU decomposition of square or rectangular matrix</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.conditionNumberS.png" ALT="Modelica_LinearSystems2.Math.Matrices.LU_solve" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.LU_solve"
>LU_solve</A>
</TD><TD>Solve real system of linear equations P*L*U*x=b with a b vector and an LU decomposition (from LU(..))</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.LU_solve2S.png" ALT="Modelica_LinearSystems2.Math.Matrices.LU_solve2" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.LU_solve2"
>LU_solve2</A>
</TD><TD>Solve real system of linear equations P*L*U*X=B with a B vector and an LU decomposition (from LU(..))</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.leastSquaresS.png" ALT="Modelica_LinearSystems2.Math.Matrices.leastSquares" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.leastSquares"
>leastSquares</A>
</TD><TD>Solve overdetermined or underdetermined real system of linear equations A*x=b in a least squares sense (A may be rank deficient)</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.leastSquaresS.png" ALT="Modelica_LinearSystems2.Math.Matrices.leastSquares2" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.leastSquares2"
>leastSquares2</A>
</TD><TD>Solve overdetermined or underdetermined real system of linear equations A*X=B in a least squares sense (A may be rank deficient)</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.QRS.png" ALT="Modelica_LinearSystems2.Math.Matrices.QR" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.QR"
>QR</A>
</TD><TD>QR decomposition of a rectangular matrix without column pivoting (A = Q*R). Return the full square Q-matrix</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.QRS.png" ALT="Modelica_LinearSystems2.Math.Matrices.LQ" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.LQ"
>LQ</A>
</TD><TD>LQ decomposition of a rectangular matrix without column pivoting (A = L*Q)</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.QRS.png" ALT="Modelica_LinearSystems2.Math.Matrices.orthogonalQ" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.orthogonalQ"
>orthogonalQ</A>
</TD><TD>generates a real orthogonal matrix Q which is defined as the product of IHI-ILO elementary reflectors of order N, as returned by DGEHRD</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.QRS.png" ALT="Modelica_LinearSystems2.Math.Matrices.cholesky" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.cholesky"
>cholesky</A>
</TD><TD>Compute the Cholesky factorization of a symmetric positive definte matrix</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.QRS.png" ALT="Modelica_LinearSystems2.Math.Matrices.choleskyUpDate" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.choleskyUpDate"
>choleskyUpDate</A>
</TD><TD>Compute the cholesky factor Lu according to Au=Lu&#39;*Lu=A + v*v&#39; with A=L&#39;*L</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.QRS.png" ALT="Modelica_LinearSystems2.Math.Matrices.choleskyDownDate" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.choleskyDownDate"
>choleskyDownDate</A>
</TD><TD>Compute the cholesky factor Ld according to Ad=Ld&#39;*Ld=A - v*v&#39; with A=L&#39;*L</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.QRS.png" ALT="Modelica_LinearSystems2.Math.Matrices.rsf" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.rsf"
>rsf</A>
</TD><TD>Computes the real Schur form (RSF) of a square matrix</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.QRS.png" ALT="Modelica_LinearSystems2.Math.Matrices.rsf2" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.rsf2"
>rsf2</A>
</TD><TD>Computes the real Schur form (RSF) of a square matrix but uses lapack.dgees</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.QRS.png" ALT="Modelica_LinearSystems2.Math.Matrices.hessenberg" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.hessenberg"
>hessenberg</A>
</TD><TD>Transform a matrix to upper Hessenberg form</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.QRS.png" ALT="Modelica_LinearSystems2.Math.Matrices.toUpperHessenberg" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.toUpperHessenberg"
>toUpperHessenberg</A>
</TD><TD>transform a real general matrix A to upper Hessenberg form H by an orthogonal similarity transformation:  Q&#39; * A * Q = H</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.QRS.png" ALT="Modelica_LinearSystems2.Math.Matrices.householderReflexion" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.householderReflexion"
>householderReflexion</A>
</TD><TD>Reflect each of the vectors ai of matrix  A=[a1, a2, ..., an] on a plane with orthogonal vector u</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.QRS.png" ALT="Modelica_LinearSystems2.Math.Matrices.householderSimilarityTransformation" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.householderSimilarityTransformation"
>householderSimilarityTransformation</A>
</TD><TD>Calculate the similarity transformation S*A*S of matrix A with symmetric householder matrix S = I - 2u*u&#39;</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.QRS.png" ALT="Modelica_LinearSystems2.Math.Matrices.fliplr" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.fliplr"
>fliplr</A>
</TD><TD>flip the columns of a matrix in left/right direction</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.QRS.png" ALT="Modelica_LinearSystems2.Math.Matrices.flipud" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.flipud"
>flipud</A>
</TD><TD>flip the columns of a matrix in up/down direction</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.QRS.png" ALT="Modelica_LinearSystems2.Math.Matrices.triangle" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.triangle"
>triangle</A>
</TD><TD>Return the upper/lower triangular part of a square matrix</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.traceS.png" ALT="Modelica_LinearSystems2.Math.Matrices.trace" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.trace"
>trace</A>
</TD><TD>tarce(A) is the sum of the diagonal elements of A</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.generalizedEigenvaluesTriangularS.png" ALT="Modelica_LinearSystems2.Math.Matrices.generalizedEigenvaluesTriangular" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.generalizedEigenvaluesTriangular"
>generalizedEigenvaluesTriangular</A>
</TD><TD>Compute invariant zeros of linear state space system with a generalized system matrix [A, B, C, D] which is of upper Hessenberg form</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.generalizedEigenvaluesTriangularS.png" ALT="Modelica_LinearSystems2.Math.Matrices.printMatrix" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.printMatrix"
>printMatrix</A>
</TD><TD>print matrix</TD></TR>
<TR><TD><IMG SRC="Modelica_LinearSystems2.Math.Matrices.generalizedEigenvaluesTriangularS.png" ALT="Modelica_LinearSystems2.Math.Matrices.fromFile" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.fromFile"
>fromFile</A>
</TD><TD>Read matrix from a matlab file</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE care<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.care"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.care</H2>
<B>Solution of continuous-time algebraic Riccati equations</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
 
 
Function <b>care</b> computes the solution <b>X</b> of the continuous-time algebraic Riccati equation
<blockquote><pre>
 <b>Q</b> + <b>A</b>'*<b>X</b> + <b>X</b>*<b>A</b> - <b>X</b>*<b>G</b>*<b>X</b> = <b>0</b> 
</pre></blockquote>
with
<blockquote><pre>
       -1
<b>G</b> = <b>B</b>*<b>R</b> *<b>B</b>' 
</pre>
</blockquote>
using the Schur vector approach proposed by Laub [1].
<p>
It is assumed that <b>Q</b> is symmetric and positve semidefinite and <b>R</b> is symmetric, nonsingular and positive definite,
(<b>A</b>,<b>B</b>) is stabilizable and (<b>A</b>,<b>Q</b>) is detectable.
<p><b>
The assumptions are not checked in this function
</b>
<p>
The assumptions guarantee that Hamiltonian matrix 
<blockquote><pre>
<b>H</b> = [<b>A</b>, -<b>G</b>; -<b>Q</b>, -<b>A</b>']
</pre></blockquote>
has no pure imaginary eigenvalue and can be put
to an ordered real Schur form 
<blockquote><pre>
<b>U</b>'*<b>H</b>*<b>U</b> = <b>S</b> = [<b>S</b>11, <b>S</b>12; <b>0</b>, <b>S</b>22]
</pre></blockquote>
with orthogonal similarity transformation <b>U</b>. <b>S</b> is ordered in such a way,
that <b>S11</b> contains the n stable eigenvalues of the closed loop system with system matrix
<blockquote><pre>
       -1
<b>A</b> - <b>B</b>*<b>R</b> *<b>B</b>'*<b>X</b>
</pre></blockquote>
If <b>U</b> is partitioned to 
<blockquote><pre>
<b>U</b> = [<b>U</b>11, <b>U</b>12; <b>U</b>21, <b>U</b>22]
</pre></blockquote>
with dimenstions according to <b>S</b>, the solution <b>X</b> can be calculated by
<blockquote><pre>
<b>X</b>*<b>U</b>11 = <b>U</b>21.
</pre></blockquote>
 
The algorithm uses LAPACK routines dgehrd (to compute the upper Hessenberg matrix of <b>H</b>), dorghr (to calculate the orthogonal
matrix from the elementary reflectors as returned from dgehrd), dhseqr (to put transformed <b>H</b> to Schur form and to calculate the eigenvalues 
of the closed loop system) and dtrsen (to compute the ordered real Schur form and matrix <b>U</b>).
 
<p>
 
 
<A name="References"><B><FONT SIZE="+1">References</FONT></B></A>
<PRE>
  [1] Laub, A.J.
      A Schur Method for Solving Algebraic Riccati equations.
      IEEE Trans. Auto. Contr., AC-24, pp. 913-921, 1979.
</PRE>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>B[size(A, 1), :]</TD><TD>&nbsp;</TD></TR>
<TR><TD>R[size(B, 2), size(B, 2)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>Q[size(A, 1), size(A, 1)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>refine</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>X[size(A, 1), size(A, 2)]</TD><TD>stabilizing solution of CARE</TD></TR>
<TR><TD>ev[size(A, 1)]</TD><TD>eigenvalues of the closed loop system</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE dare<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.dare"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.dare</H2>
<B>Solution of discrete-time algebraic Riccati equations</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
Function <b>dare</b> computes the solution <b>X</b> of the discrete-time algebraic Riccati equation
<blockquote><pre>
                                 -1
 <b>X</b> = <b>A</b>'*<b>X</b>*<b>A</b> - <b>A</b>'*<b>X</b>*<b>B</b>*(<b>R</b> + <b>B</b>'*<b>X</b>*<b>B</b>)  *<b>B</b>'*<b>X</b>*<b>A</b> + <b>Q</b>
</pre>
</blockquote>
using the Schur vector approach proposed by Laub [1].
<p>
It is assumed that <b>Q</b> is symmetric and positve semidefinite and <b>R</b> is symmetric, nonsingular and positive definite,
(<b>A</b>,<b>B</b>) is stabilizable and (<b>A</b>,<b>Q</b>) is detectable.
<p><b>
The assumptions are not checked in this function
</b>
 
<p>
The assumptions guarantee that the Hamiltonian matrix 
<blockquote><pre>
      -1  -1       -1        -1
<b>H</b> = [<b>A</b>, -<b>A</b>  *<b>G</b>; <b>Q</b>*<b>A</b>, <b>A</b>' + <b>Q</b>*<b>A</b>  *<b>G</b> ]
</pre></blockquote>
with
<blockquote><pre>
       -1
<b>G</b> = <b>B</b>*<b>R</b> *<b>B</b>' 
</pre>
</blockquote>
has no eigenvalue on the unit circle and can be put
to an ordered real Schur form 
<blockquote><pre>
<b>U</b>'*<b>H</b>*<b>U</b> = <b>X</b> = [<b>S11</b>, <b>S12</b>; <b>0</b>, <b>S22</b>]
</pre></blockquote>
with orthogonal similarity transformation <b>U</b>. <b>X</b> is ordered in such a way,
that <b>S11</b> contains the n stable eigenvalues of the closed loop system with system matrix
<blockquote><pre>
                  -1
<b>A</b> - <b>B</b>*(<b>R</b> + <b>B</b>'*<b>X</b>*<b>B</b>)  *<b>B</b>'*<b>X</b>*<b>A</b>
</pre>
</blockquote>
If <b>U</b> is partitioned to 
<blockquote><pre>
<b>U</b> = [<b>U11</b>, <b>U12</b>; <b>U21</b>, <b>U22</b>]
</pre></blockquote>
according to <b>X</b>, the solution <b>X</b> can be calculated by
<blockquote><pre>
<b>X</b>*<b>U11</b> = <b>U21</b>.
</pre></blockquote>
 
The algorithm uses LAPACK routines dgehrd (to compute the upper Hessenberg matrix of <b>H</b>), dorghr (to calculate the orthogonal
matrix from the elementary reflectors as returned from dgehrd), dhseqr (to put transformed <b>H</b> to Schur form and to calculate the eigenvalues 
of the closed loop system) and dtrsen (to compute the ordered real Schur form and matrix <b>U</b>).
<p>
 
<A name="References"><B><FONT SIZE="+1">References</FONT></B></A>
<PRE>
  [1] Laub, A.J.
      A Schur Method for Solving Algebraic Riccati equations.
      IEEE Trans. Auto. Contr., AC-24, pp. 913-921, 1979.
</PRE>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>B[size(A, 1), :]</TD><TD>&nbsp;</TD></TR>
<TR><TD>R[size(B, 2), size(B, 2)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>Q[size(A, 1), size(A, 1)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>refine</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>X[size(A, 1), size(A, 2)]</TD><TD>orthogonal matrix of the Schur vectors associated to ordered rsf</TD></TR>
<TR><TD>ev[size(A, 1)]</TD><TD>eigenvalues of the closed loop system</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE sylvester<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.sylvester"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.sylvester</H2>
<B>Solution of continuous-time Sylvester equation A*X + X*B = C</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
 
 
Function <b>sylvester</b> computes the solution <b>X</b> of the continuous-time Sylvester equation
<blockquote><pre>
 <b>A</b>*<b>X</b> + <b>X</b>*<b>B</b> = <b>C</b>.
</pre></blockquote>
using the Schur method for Sylvester equations proposed by Bartels and Stewart [1].
<p>
<A name="References"><B><FONT SIZE="+1">References</FONT></B></A>
<PRE>
  [1] Bartels, R.H. and Stewart G.W.
      Algorithm 432: Solution of the matrix equation AX + XB = C.
      Comm. ACM., Vol. 15, pp. 820-826, 1972.
</PRE>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, :]</TD><TD>Matrix A</TD></TR>
<TR><TD>B[:, :]</TD><TD>Matrix B</TD></TR>
<TR><TD>C[size(A, 1), size(B, 2)]</TD><TD>Matrix C</TD></TR>
<TR><TD>aIsSchur</TD><TD>True if A has already real Schur form</TD></TR>
<TR><TD>bIsSchur</TD><TD>True if B has already real Schur form</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>X[size(A, 1), size(B, 2)]</TD><TD>Solution of Sylvester equation</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE dsylvester<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.dsylvester"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.dsylvester</H2>
<B>Solution of discrete-time Sylvester equation A*X*B + sgn*X = C</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
 <h4>Syntax</h4>
<blockquote><pre>
         X = Matrices.<b>dsylvester</b>(A, B, C);
         X = Matrices.<b>dsylvester</b>(A, B, C, AisHess, BTisSchur, sgn, eps);
</pre></blockquote>
<h4>Description</h4>
<p>
Function <b>dsylvester</b> computes the solution <b>X</b> of the discrete-time Sylvester equation
<p>
<blockquote><pre>
 <b>A</b>*<b>X</b>*<b>B</b> + sgn*<b>X</b> = <b>C</b>.

</pre></blockquote>
</p>
where sgn = 1 or sgn = -1. The algorithm applies the Hessenberg-Schur method proposed by Golub et al [1].
For sgn = -1, the discrete Sylvester equation is also known as Stein equation:
<p>
<blockquote><pre>
 <b>A</b>*<b>X</b>*<b>B</b> - <b>X</b> + <b>Q</b> = <b>0</b>.

</pre></blockquote>
</p>

In a nutshell, the problem is reduced to the corresponding problem
<blockquote><pre>
 <b>H</b>*<b>Y</b>*<b>S</b>' + sgn*<b>Y</b> = <b>F</b>.
</pre></blockquote>
<p>
with <b>H</b>=<b>U</b>'*<b>A</b>*<b>U</b> is the Hessenberg form of <b>A</b> and <b>S</b>=<b>V</b>'*<b>B</b>'*<b>V</b> is the real Schur form of <b>B</b>',
<b>F</b>=<b>U</b>'*<b>C</b>*<b>V</b> and <b>Y</b>=<b>U</b>*<b>X</b>*<b>V</b>'
are appropriate transformations of <b>C</b> and <b>X</b>. This problem is solved sequently by exploiting the specific forms of <b>S</b> and <b>H</b>.
Finally the solution of the the original problem is recovered as <b>X</b>=<b>U</b>'*<b>Y</b>*<b>V</b>.<br>
The boolean inputs "AisHess" and "BTisSchur" indicate to omit one or both of the transformation to Hessenberg form or Schur form repectively in the case that <b>A</b> and/or <b>B</b> have already Hessenberg form or Schur respectively.

</p>
<h4>References</h4>
<PRE>
  [1] Golub, G.H., Nash, S. and Van Loan, C.F.
      A Hessenberg-Schur method for the problem AX + XB = C.
      IEEE Transaction on Automatic Control, AC-24, no. 6, pp. 909-913, 1979.


</PRE>


</p>
<h4>Example</h4>
<blockquote><pre>
  A = [1.0,   2.0,   3.0;
       6.0,   7.0,   8.0;
       9.0,   2.0,   3.0];


  B = [7.0,   2.0,   3.0;
       2.0,   1.0,   2.0;
       3.0,   4.0,   1.0];


  C = [271.0,   135.0,   147.0;
       923.0,   494.0,   482.0;
       578.0,   383.0,   287.0];

  X = discreteSylvester(A, B, C);

  results in:
  X = [2.0,   3.0,   6.0;
       4.0,   7.0,   1.0;
       5.0,   3.0,   2.0];

</pre></blockquote>



<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>Square matrix A in A*X*B + sgn*X = C</TD></TR>
<TR><TD>B[:, size(B, 1)]</TD><TD>Square matrix B in A*X*B + sgn*X = C</TD></TR>
<TR><TD>C[size(A, 2), size(B, 1)]</TD><TD>Rectangular matrix C in A*X*B + sgn*X = C</TD></TR>
<TR><TD>AisHess</TD><TD>True if A has already Hessenberg form</TD></TR>
<TR><TD>BTisSchur</TD><TD>True if B&#39; has already real Schur form</TD></TR>
<TR><TD>sgn</TD><TD>Specifies the sign in A*X*B + sgn*X = C</TD></TR>
<TR><TD>eps</TD><TD>Tolerance</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>X[size(A, 2), size(B, 1)]</TD><TD>solution of the discrete Sylvester equation A*X*B + sgn*X = C</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE lyapunov<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.lyapunov"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.lyapunov</H2>
<B>Solution of continuous-time Lyapunov equation X*A + A&#39;*X = C</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
 
 
Function <b>laypunov</b> computes the solution <b>X</b> of the continuous-time Lyapunov equation
<blockquote><pre>
 <b>X</b><b>A</b> + <b>A</b>'*<b>X</b> = <b>C</b>.
</pre></blockquote>
using the Schur method for Lyapunov equations proposed by Bartels and Stewart [1].
<p>
<A name="References"><B><FONT SIZE="+1">References</FONT></B></A>
<PRE>
  [1] Bartels, R.H. and Stewart G.W.
      Algorithm 432: Solution of the matrix equation AX + XB = C.
      Comm. ACM., Vol. 15, pp. 820-826, 1972.
</PRE>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>C[size(A, 1), size(A, 2)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>eps</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>X[size(A, 1), size(A, 2)]</TD><TD>solution of the Lyapunov equation</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE dlyapunov<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.dlyapunov"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.dlyapunov</H2>
<B>Solution of continuous-time Lyapunov equation A&#39;X*A - X = C</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
 
 
Function <b>laypunov</b> computes the solution <b>X</b> of the continuous-time Lyapunov equation
<blockquote><pre>
 <b>X</b><b>A</b> + <b>A</b>'*<b>X</b> = <b>C</b>.
</pre></blockquote>
using the Schur method for Lyapunov equations proposed by Bartels and Stewart [1].
<p>
<A name="References"><B><FONT SIZE="+1">References</FONT></B></A>
<PRE>
  [1] Bartels, R.H. and Stewart G.W.
      Algorithm 432: Solution of the matrix equation AX + XB = C.
      Comm. ACM., Vol. 15, pp. 820-826, 1972.
</PRE>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>C[size(A, 1), size(A, 2)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>eps</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>X[size(A, 1), size(A, 2)]</TD><TD>solution of the Lyapunov equation</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE conditionNumber<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Math.Matrices.conditionNumberI.png" ALT="Modelica_LinearSystems2.Math.Matrices.conditionNumber" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.conditionNumber"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.conditionNumber</H2>
<B>Calculate the condition number norm(A)*norm(inv(A))</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
  <h4>Syntax</h4>
<blockquote><pre>
r = Matrices.<b>conditionNumber</b>(A);
</pre></blockquote>
<h4>Description</h4>
<p>
This function calculates the the condition number (norm(A) * norm(inv(A))) of a general real matrix A, in either the 1-norm, 2-norm or the infinity-norm.
In the case of 2-norm the result is he ratio of the largest to the smallest singular value to A.
</p>
<p>
<h4>Example</h4>
<blockquote><pre>
  A = [1, 2
       2, 1];
  r = conditionNumber(A);
  
  results in:
  
  r = 3.0
</pre></blockquote>
</p>
<h4>See also</h4>
<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.rcond"
>Matrices.rcond</a>
<pre></PRE><P>
Extends from Modelica.Icons.Function (Icon for functions).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, :]</TD><TD>Input matrix</TD></TR>
<TR><TD>p</TD><TD>Type of p-norm (only allowed: 1, 2 or Modelica.Constants.inf)</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>result</TD><TD>p-norm of matrix A</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE rcond<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Math.Matrices.conditionNumberI.png" ALT="Modelica_LinearSystems2.Math.Matrices.rcond" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.rcond"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.rcond</H2>
<B>Reciprocal condition number</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
  <h4>Syntax</h4>
<blockquote><pre>
r = Matrices.<b>rcond</b>(A);
(r, info) = Matrices.<b>rcond</b>(A, false);
</pre></blockquote>
<h4>Description</h4>
<p>
This function estimates the reciprocal of the condition number (norm(A) * norm(inv(A))) of a general real matrix A, in either the 1-norm or the infinity-norm, using the LAPACK function DGECON.   
</p>
<p>
<h4>Example</h4>
<blockquote><pre>
  A = [1, 2
       2, 1];
  r = rcond(A);
  
  results in:
  
  r = 0.3333
</pre></blockquote>
</p>
<h4>See also</h4>
<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.conditionNumber"
>Matrices.conditionNumber</a>
<pre></PRE><P>
Extends from Modelica.Icons.Function (Icon for functions).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>Square real matrix</TD></TR>
<TR><TD>inf</TD><TD>Is true if infinity norm is used and false for 1-norm</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>rcond</TD><TD>Reciprocal condition number of A</TD></TR>
<TR><TD>info</TD><TD>Information</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE det<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Math.Matrices.conditionNumberI.png" ALT="Modelica_LinearSystems2.Math.Matrices.det" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.det"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.det</H2>
<B>Determinant of a matrix (computed by LU decomposition)</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<b>det</b>(A);
</pre></blockquote>
<h4>Description</h4>
<p>
This function call returns the determinant of matrix A
computed by a LU decomposition.
Usally, this function should never be used, because
there are nearly always better numerical algorithms
as by computing the determinant. E.g., use function
Matrices.rank</a>
to compute the rank of a matrix.
<h4>See also</h4>
Matrices.rank</a>,
Matrices.solve</a>
<pre></PRE><P>
Extends from Modelica.Icons.Function (Icon for functions).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>result</TD><TD>Determinant of matrix A</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE norm<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Math.Matrices.conditionNumberI.png" ALT="Modelica_LinearSystems2.Math.Matrices.norm" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.norm"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.norm</H2>
<B>Returns the norm of a matrix</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<b>norm</b>(A);
Matrices.<b>norm</b>(A, p=2);
</pre></blockquote>
<h4>Description</h4>
<p>
The function call "<code>Matrices.norm(A)</code>" returns the
2-norm of matrix A, i.e., the largest singular value of A.<br>
The function call "<code>Matrices.norm(A, p)</code>" returns the
p-norm of matrix A. The only allowed values for p are</p>
<ul>
<li> "p=1": the largest column sum of A</li>
<li> "p=2": the largest singular value of A</li> 
<li> "p=Modelica.Constants.inf": the largest row sum of A</li>
</ul>
<p>
Note, for any matrices A1, A2 the following inequality holds:
</p>
<blockquote><pre>
Matrices.<b>norm</b>(A1+A2,p) &le; Matrices.<b>norm</b>(A1,p) + Matrices.<b>norm</b>(A2,p)
</pre></blockquote>
<p>
Note, for any matrix A and vector v the following inequality holds:
</p>
<blockquote><pre>
Vectors.<b>norm</b>(A*v,p) &le; Matrices.<b>norm</b>(A,p)*Vectors.<b>norm</b>(A,p)
</pre></blockquote>
<pre></PRE><P>
Extends from Modelica.Icons.Function (Icon for functions).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, :]</TD><TD>Input matrix</TD></TR>
<TR><TD>p</TD><TD>Type of p-norm (only allowed: 1, 2 or Modelica.Constants.inf)</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>result</TD><TD>p-norm of matrix A</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE nullspace<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Math.Matrices.conditionNumberI.png" ALT="Modelica_LinearSystems2.Math.Matrices.nullspace" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.nullspace"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.nullspace</H2>
<B>Orthonormal nullspace of a matrix</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
  <h4>Syntax</h4>
<blockquote><pre>
Z = Matrices.<b>nullspace</b>(A);<br>
(Z, nullity) = Matrices.<b>nullspace</b>(A);
</pre></blockquote>
<h4>Description</h4>
<p>
This function calculates a orthonormal basis <b>Z</b>=[<b>z</b>_1, <b>z</b>_2, ...] of the nullspace of a matrix <b>A</b>, i.e. <b>A</b>*<b>z</b>_i=0.
</p>
The nullspace is obtained by svd method. That is, matrix <b>A</b> is decomposed into the matrices <b>S</b>, <b>U</b>, <b>V</b>: 
<blockquote><pre>
        T
 <b>A</b> = <b>U</b><b>S</b><b>V</b>
</pre></blockquote>
with the orthonormal matrices <b>U</b> and <b>V</b> and the matrix <b>S</b> with
<blockquote><pre>
 <b>S</b> = [<b>S</b>1, <b>0</b>]
 <b>S</b>1 = [diag(s); <b>0</b>]
</pre></blockquote>
with the singular values <b>s</b>={s1, s2, ..., sr} of <b>A</b> and r=rank(<b>A</b>). Note, that <b>S</b> has the same size as <b>A</b>. Since, <b>U</b> and <b>V</b> are orthonormal, we may write
<blockquote><pre>
  T
 <b>U</b>*<b>A</b>*<b>V</b> = [<b>S</b>1, <b>0</b>].
</pre></blockquote>
Matrix <b>S</b>1 obviously has full column rank and therefore, the left n-r rows (n is the number of columns of <b>A</b> or <b>S</b>) of matrix <b>V</b> span a nullspace of <b>A</b>.
</p>
<p>
The nullity of matrix <b>A</b> is the dimension of the nullspace of <b>A</b>. In view of the above, it becomes clear that nullity holds
<blockquote><pre>
 nullity = n - r
</pre></blockquote>
with
<blockquote><pre>
 n = number of columns of matrix <b>A</b>
 r = rank(<b>A</b>)
</pre></blockquote>

</p>
<p>
<h4>Example</h4>
<blockquote><pre>
  A = [1, 2,  3, 1;
       3, 4,  5, 2;
      -1, 2, -3, 3];
  (Z, nullity) = nullspace(A);
  
  results in:
  
  Z=[0.1715;
    -0.686;
     0.1715;
     0.686]
     
  nullity = 1
</pre></blockquote>
</p>
<h4>See also</h4>
Matrices.singularValues</a>
<pre></PRE><P>
Extends from Modelica.Icons.Function (Icon for functions).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, :]</TD><TD>input matrix</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Z[size(A, 2), :]</TD><TD>orthonormal nullspace of matrix A</TD></TR>
<TR><TD>nullity</TD><TD>nullity, i.e. the dimension of the nullspace</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE eigenValues<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Math.Matrices.conditionNumberI.png" ALT="Modelica_LinearSystems2.Math.Matrices.eigenValues" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.eigenValues"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.eigenValues</H2>
<B>Compute eigenvalues and eigenvectors for a real, nonsymmetric matrix</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
                eigenvalues = Matrices.<b>eigenValues</b>(A);
(eigenvalues, eigenvectors) = Matrices.<b>eigenValues</b>(A);
</pre></blockquote>
<h4>Description</h4>
<p>
This function call returns the eigenvalues and 
optionally the (right) eigenvectors of a square matrix 
<b>A</b>. The first column of "eigenvalues" contains the real and the
second column contains the imaginary part of the eigenvalues.
If the i-th eigenvalue has no imaginary part, then eigenvectors[:,i] is
the corresponding real eigenvector. If the i-th eigenvalue
has an imaginary part, then eigenvalues[i+1,:] is the conjugate complex
eigenvalue and eigenvectors[:,i] is the real and eigenvectors[:,i+1] is the
imaginary part of the eigenvector of the i-th eigenvalue.
With function 
Matrices.eigenValueMatrix</a>,
a real block diagonal matrix is constructed from the eigenvalues 
such that 
</p>
<blockquote>
<pre>
A = eigenvectors * eigenValueMatrix(eigenvalues) * inv(eigenvectors)
</pre>
</blockquote>
<p>
provided the eigenvector matrix "eigenvectors" can be inverted
(an inversion is possible, if all eigenvalues are different
and no eigenvalue is zero).
</p>
<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3; 
                 3,4,5;
                 2,1,4];
  Real eval;
<b>algorithm</b>
  eval := Matrices.eigenValues(A);  // eval = [-0.618, 0; 
                                    //          8.0  , 0;
                                    //          1.618, 0];
</pre>
</blockquote>
<p>
i.e., matrix A has the 3 real eigenvalues -0.618, 8, 1.618.
</p>
</pre></blockquote>
<h4>See also</h4>
Matrices.eigenValueMatrix</a>,
Matrices.singularValues</a>
<pre>
</PRE><P>
Extends from Modelica.Icons.Function (Icon for functions).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>Matrix</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>eigenvalues[size(A, 1), 2]</TD><TD>Eigenvalues of matrix A (Re: first column, Im: second column)</TD></TR>
<TR><TD>leftEigenvectors[size(A, 1), size(A, 2)]</TD><TD>Real-valued eigenvector matrix</TD></TR>
<TR><TD>rightEigenvectors[size(A, 1), size(A, 2)]</TD><TD>Real-valued eigenvector matrix</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE equalityLeastSquares<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Math.Matrices.conditionNumberI.png" ALT="Modelica_LinearSystems2.Math.Matrices.equalityLeastSquares" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.equalityLeastSquares"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.equalityLeastSquares</H2>
<B>Solve a linear equality constrained least squares problem</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
x = Matrices.<b>equalityLeastSquares</b>(A,a,B,b);
</pre></blockquote>
<h4>Description</h4>
<p>
This function returns the
solution <b>x</b> of the linear equality-constrained least squares problem:
</p>
<blockquote>
<p>
min|<b>A</b>*<b>x</b> - <b>a</b>|^2 over <b>x</b>, subject to <b>B</b>*<b>x</b> = <b>b</b>
</p>
</blockquote>
 
<p>
It is required that the dimensions of A and B fulfill the following
relationship:
</p>
 
<blockquote>
size(B,1) &le; size(A,2) &le; size(A,1) + size(B,1)
</blockquote>
 
<p>
Note, the solution is computed with the LAPACK function "dgglse"
using the generalized RQ factorization under the assumptions that
B has full row rank (= size(B,1)) and the matrix [A;B] has
full column rank (= size(A,2)). In this case, the problem
has a unique solution.
</p>
<pre></PRE><P>
Extends from Modelica.Icons.Function (Icon for functions).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, :]</TD><TD>Minimize |A*x - a|^2</TD></TR>
<TR><TD>a[size(A, 1)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>B[:, size(A, 2)]</TD><TD>subject to B*x=b</TD></TR>
<TR><TD>b[size(B, 1)]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>x[size(A, 2)]</TD><TD>solution vector</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE solve<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Math.Matrices.conditionNumberI.png" ALT="Modelica_LinearSystems2.Math.Matrices.solve" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.solve"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.solve</H2>
<B>Solve real system of linear equations A*x=b with a b vector (Gaussian elemination with partial pivoting)</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<b>solve</b>(A,b);
</pre></blockquote>
<h4>Description</h4>
<p>
This function call returns the
solution <b>x</b> of the linear system of equations
</p>
<blockquote>
<p>
<b>A</b>*<b>x</b> = <b>b</b>
</p>
</blockquote>
<p>
If a unique solution <b>x</b> does not exist (since <b>A</b> is singular),
an exception is raised.
</p>
<p>
Note, the solution is computed with the LAPACK function "dgesv",
i.e., by Gaussian elemination with partial pivoting.
</p>
<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3; 
                 3,4,5;
                 2,1,4];
  Real b[3] = {10,22,12};
  Real x[3];
<b>algorithm</b>
  x := Matrices.solve(A,b);  // x = {3,2,1}
</pre></blockquote>
<h4>See also</h4>
Matrices.LU</a>,
Matrices.LU_solve</a>
<pre></PRE><P>
Extends from Modelica.Icons.Function (Icon for functions).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>Matrix A of A*x = b</TD></TR>
<TR><TD>b[size(A, 1)]</TD><TD>Vector b of A*x = b</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>x[size(b, 1)]</TD><TD>Vector x such that A*x = b</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE solve2<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Math.Matrices.conditionNumberI.png" ALT="Modelica_LinearSystems2.Math.Matrices.solve2" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.solve2"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.solve2</H2>
<B>Solve real system of linear equations A*X=B with a B matrix (Gaussian elemination with partial pivoting)</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<b>solve2</b>(A,b);
</pre></blockquote>
<h4>Description</h4>
<p>
This function call returns the
solution <b>X</b> of the linear system of equations
</p>
<blockquote>
<p>
<b>A</b>*<b>X</b> = <b>B</b>
</p>
</blockquote>
<p>
If a unique solution <b>X</b> does not exist (since <b>A</b> is singular),
an exception is raised.
</p>
<p>
Note, the solution is computed with the LAPACK function "dgesv",
i.e., by Gaussian elemination with partial pivoting.
</p>
<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3; 
                 3,4,5;
                 2,1,4];
  Real B[3,2] = [10, 20;
                 22, 44;
                 12, 24];
  Real X[3,2];
<b>algorithm</b>
  (LU, pivots) := Matrices.LU(A);
  X := Matrices.solve2(A, B1);  /* X = [3, 6;
                                        2, 4;
                                        1, 2] */
</pre></blockquote>
 
<h4>See also</h4>
Matrices.LU</a>,
Matrices.LU_solve2</a>
<pre></PRE><P>
Extends from Modelica.Icons.Function (Icon for functions).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>Matrix A of A*X = B</TD></TR>
<TR><TD>B[size(A, 1), :]</TD><TD>Matrix B of A*X = B</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>X[size(B, 1), size(B, 2)]</TD><TD>Matrix X such that A*X = B</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE solve2r<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Math.Matrices.conditionNumberI.png" ALT="Modelica_LinearSystems2.Math.Matrices.solve2r" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.solve2r"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.solve2r</H2>
<B>Solve real system of linear equations X*op(A)=B with a B matrix (Gaussian elemination with partial pivoting)</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
  X = Matrices.<b>solve2r</b>(A,B);
  X = Matrices.<b>solve2r</b>(A, B, transA=false, isTriangular=false);
</pre></blockquote>
<h4>Description</h4>
<p>
This function call returns the
solution <b>X</b> of the linear system of equations
</p>
<blockquote>
<p>
<b>X</b>*op<b>(A)</b> = <b>B</b>
</p>
</blockquote>
<p>
with 
</p>
<blockquote>
<p>
  op<b>(A)</b> = transpose(<b>(A)</b>)  if   transA==true
  op<b>(A)</b> = <b>(A)</b>  if   transA==false
</p>
</blockquote>
<p>
If matrix <b>(A)</b> is already lower triangular, the factorization is avoided if input "isTriangular" is set true.
If a unique solution <b>X</b> does not exist (since <b>A</b> is singular),
an exception is raised.
</p>
<p>
Note, the solution is computed with the LAPACK function "dgesv",
i.e., by Gaussian elemination with partial pivoting.
</p>
<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3;
                 3,4,5;
                 2,1,4];
  
  Real B[2,3]  = [10, 22, 12;
                  20, 44, 24];
  Real X[2,3];
<b>algorithm</b>
  X := Matrices.solve2r(A, B);  /* X = [-34.0, 17.2, 2.4;
                                        -68.0, 34.4, 4.8] */
</pre></blockquote>

<h4>See also</h4>
Matrices.LU</a>,
Matrices.LU_solve2</a>
<pre></PRE><P>
Extends from Modelica.Icons.Function (Icon for functions).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>Matrix A of X*op(A) = B</TD></TR>
<TR><TD>B[:, size(A, 1)]</TD><TD>Matrix B of X*op(A) = B</TD></TR>
<TR><TD>transA</TD><TD>True if op(A)=A&#39;, false if op(A)=A</TD></TR>
<TR><TD>isTriangular</TD><TD>True if the A is already lower triangular</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>X[size(B, 1), size(B, 2)]</TD><TD>Matrix X such that X*op(A) = B</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE LU<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Math.Matrices.conditionNumberI.png" ALT="Modelica_LinearSystems2.Math.Matrices.LU" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.LU"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.LU</H2>
<B>LU decomposition of square or rectangular matrix</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
(LU, pivots)       = Matrices.<b>LU</b>(A);
(LU, pivots, info) = Matrices.<b>LU</b>(A);
</pre></blockquote>
<h4>Description</h4>
<p>
This function call returns the
LU decomposition of a "Real[m,n]" matrix A, i.e.,
</p>
<blockquote>
<p>
<b>P</b>*<b>L</b>*<b>U</b> = <b>A</b>
</p>
</blockquote>
<p>
where <b>P</b> is a permutation matrix (implicitely
defined by vector <code>pivots</code>),
<b>L</b> is a lower triangular matrix with unit
diagonal elements (lower trapezoidal if m &gt; n), and
<b>U</b> is an upper triangular matrix (upper trapezoidal if m &lt; n).
Matrices <b>L</b> and <b>U</b> are stored in the returned
matrix <code>LU</code> (the diagonal of <b>L</b> is not stored).
With the companion function 
Matrices.LU_solve</a>,
this decomposition can be used to solve
linear systems (<b>P</b>*<b>L</b>*<b>U</b>)*<b>x</b> = <b>b</b> with different right
hand side vectors <b>b</b>. If a linear system of equations with
just one right hand side vector <b>b</b> shall be solved, it is
more convenient to just use the function
Matrices.solve</a>.
</p>
<p>
The optional third (Integer) output argument has the following meaning:
<table border=0 cellspacing=0 cellpadding=2>
  <tr><td valign="top">info = 0:</td
      <td valign="top">successful exit</td></tr>
  <tr><td valign="top">info &gt; 0:</td>
      <td valign="top">if info = i, U[i,i] is exactly zero. The factorization
          has been completed, <br> 
          but the factor U is exactly
          singular, and division by zero will occur<br> if it is used
          to solve a system of equations.</td></tr>
</table>
</p>
<p>
The LU factorization is computed
with the LAPACK function "dgetrf",
i.e., by Gaussian elemination using partial pivoting
with row interchanges. Vector "pivots" are the
pivot indices, i.e., for 1 &le; i &le; min(m,n), row i of 
matrix A was interchanged with row pivots[i].
</p>
<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3; 
                 3,4,5;
                 2,1,4];
  Real b1[3] = {10,22,12};
  Real b2[3] = { 7,13,10};
  Real    LU[3,3];
  Integer pivots[3];
  Real    x1[3];
  Real    x2[3];
<b>algorithm</b>
  (LU, pivots) := Matrices.LU(A);
  x1 := Matrices.LU_solve(LU, pivots, b1);  // x1 = {3,2,1}
  x2 := Matrices.LU_solve(LU, pivots, b2);  // x2 = {1,0,2}
</pre></blockquote>
<h4>See also</h4>
Matrices.LU_solve</a>, 
Matrices.solve</a>,
<pre></PRE><P>
Extends from Modelica.Icons.Function (Icon for functions).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, :]</TD><TD>Square or rectangular matrix</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>LU[size(A, 1), size(A, 2)]</TD><TD>L,U factors (used with LU_solve(..))</TD></TR>
<TR><TD>pivots[min(size(A, 1), size(A, 2))]</TD><TD>pivot indices (used with LU_solve(..))</TD></TR>
<TR><TD>info</TD><TD>Information</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE LU_solve<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Math.Matrices.conditionNumberI.png" ALT="Modelica_LinearSystems2.Math.Matrices.LU_solve" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.LU_solve"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.LU_solve</H2>
<B>Solve real system of linear equations P*L*U*x=b with a b vector and an LU decomposition (from LU(..))</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<b>LU_solve</b>(LU, pivots, b);
</pre></blockquote>
<h4>Description</h4>
<p>
This function call returns the
solution <b>x</b> of the linear systems of equations
</p>
<blockquote>
<p>
<b>P</b>*<b>L</b>*<b>U</b>*<b>x</b> = <b>b</b>;
</p>
</blockquote>
<p>
where <b>P</b> is a permutation matrix (implicitely
defined by vector <code>pivots</code>),
<b>L</b> is a lower triangular matrix with unit
diagonal elements (lower trapezoidal if m &gt; n), and
<b>U</b> is an upper triangular matrix (upper trapezoidal if m &lt; n).
The matrices of this decomposition are computed with function
Matrices.LU</a> that
returns arguments <code>LU</code> and <code>pivots</code>
used as input arguments of <code>Matrices.LU_solve</code>.
With <code>Matrices.LU</code> and <code>Matrices.LU_solve</code>
it is possible to efficiently solve linear systems
with different right hand side vectors. If a linear system of equations with
just one right hand side vector shall be solved, it is
more convenient to just use the function
Matrices.solve</a>.
</p>
<p>
If a unique solution <b>x</b> does not exist (since the 
LU decomposition is singular), an exception is raised.
</p>
<p>
The LU factorization is computed
with the LAPACK function "dgetrf",
i.e., by Gaussian elemination using partial pivoting
with row interchanges. Vector "pivots" are the
pivot indices, i.e., for 1 &le; i &le; min(m,n), row i of 
matrix A was interchanged with row pivots[i].
</p>
<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3; 
                 3,4,5;
                 2,1,4];
  Real b1[3] = {10,22,12};
  Real b2[3] = { 7,13,10};
  Real    LU[3,3];
  Integer pivots[3];
  Real    x1[3];
  Real    x2[3];
<b>algorithm</b>
  (LU, pivots) := Matrices.LU(A);
  x1 := Matrices.LU_solve(LU, pivots, b1);  // x1 = {3,2,1}
  x2 := Matrices.LU_solve(LU, pivots, b2);  // x2 = {1,0,2}
</pre></blockquote>
<h4>See also</h4>
Matrices.LU</a>, 
Matrices.solve</a>,
<pre></PRE><P>
Extends from Modelica.Icons.Function (Icon for functions).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>LU[:, size(LU, 1)]</TD><TD>L,U factors of Matrices.LU(..) for a square matrix</TD></TR>
<TR><TD>pivots[size(LU, 1)]</TD><TD>Pivots indices of Matrices.LU(..)</TD></TR>
<TR><TD>b[size(LU, 1)]</TD><TD>Right hand side vector of P*L*U*x=b</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>x[size(b, 1)]</TD><TD>Solution vector such that P*L*U*x = b</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE LU_solve2<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.LU_solve2"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.LU_solve2</H2>
<B>Solve real system of linear equations P*L*U*X=B with a B vector and an LU decomposition (from LU(..))</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4><font color="#008000">Syntax</font></h4>
<blockquote><pre>
Matrices.<b>LU_solve</b>(LU, pivots, B);
</pre></blockquote>
<h4><font color="#008000">Description</font></h4>
<p>
This function call returns the
solution <b>x</b> of the linear systems of equations
</p>
<blockquote>
<p>
<b>P</b>*<b>L</b>*<b>U</b>*<b>X</b> = <b>B</b>;
</p>
</blockquote>
<p>
where <b>P</b> is a permutation matrix (implicitely
defined by vector <code>pivots</code>),
<b>L</b> is a lower triangular matrix with unit
diagonal elements (lower trapezoidal if m &gt; n), and
<b>U</b> is an upper triangular matrix (upper trapezoidal if m &lt; n).
The matrices of this decomposition are computed with function
Matrices.LU</a> that
returns arguments <code>LU</code> and <code>pivots</code>
used as input arguments of <code>Matrices.LU_solve</code>.
With <code>Matrices.LU</code> and <code>Matrices.LU_solve</code>
it is possible to efficiently solve linear systems
with different right hand side <b>matrices</b>. If a linear system of equations with
just one right hand side matrix shall be solved, it is
more convenient to just use the function
Matrices.solve2</a>.
</p>
<p>
If a unique solution <b>X</b> does not exist (since the 
LU decomposition is singular), an exception is raised.
</p>
<p>
The LU factorization is computed
with the LAPACK function "dgetrf",
i.e., by Gaussian elemination using partial pivoting
with row interchanges. Vector "pivots" are the
pivot indices, i.e., for 1 &le; i &le; min(m,n), row i of 
matrix A was interchanged with row pivots[i].
</p>
<h4><font color="#008000">Example</font></h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3; 
                 3,4,5;
                 2,1,4];
  Real B1[3] = [10, 20;
                22, 44;
                12, 24];
  Real B2[3] = [ 7, 14;
                13, 26;
                10, 20];
  Real    LU[3,3];
  Integer pivots[3];
  Real    X1[3,2];
  Real    X2[3,2];
<b>algorithm</b>
  (LU, pivots) := Matrices.LU(A);
  X1 := Matrices.LU_solve2(LU, pivots, B1);  /* X1 = [3, 6;
                                                      2, 4;
                                                      1, 2] */
  X2 := Matrices.LU_solve2(LU, pivots, B2);  /* X2 = [1, 2;
                                                      0, 0;
                                                      2, 4] */
</pre></blockquote>
<h4><font color="#008000">See also</font></h4>
Matrices.LU</a>, 
Matrices.solve2</a>,
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>LU[:, size(LU, 1)]</TD><TD>L,U factors of Matrices.LU(..) for a square matrix</TD></TR>
<TR><TD>pivots[size(LU, 1)]</TD><TD>Pivots indices of Matrices.LU(..)</TD></TR>
<TR><TD>B[size(LU, 1), :]</TD><TD>Right hand side matrix of P*L*U*X=B</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>X[size(B, 1), size(B, 2)]</TD><TD>Solution matrix such that P*L*U*X = B</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE leastSquares<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Math.Matrices.leastSquaresI.png" ALT="Modelica_LinearSystems2.Math.Matrices.leastSquares" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.leastSquares"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.leastSquares</H2>
<B>Solve overdetermined or underdetermined real system of linear equations A*x=b in a least squares sense (A may be rank deficient)</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
x = Matrices.<b>leastSquares</b>(A,b);
</pre></blockquote>
<h4>Description</h4>
<p>
A linear system of equations A*x = b has no solutions or infinitely
many solutions if A is not square. Function "leastSquares" returns
a solution in a least squarse sense:
</p>
<pre>
  size(A,1) &gt; size(A,2):  returns x such that |A*x - b|^2 is a minimum
  size(A,1) = size(A,2):  returns x such that A*x = b
  size(A,1) &lt; size(A,2):  returns x such that |x|^2 is a minimum for all 
                          vectors x that fulfill A*x = b
</pre>
<p>
Note, the solution is computed with the LAPACK function "dgelsx",
i.e., QR or LQ factorization of A with column pivoting. 
If A does not have full rank,
the solution is not unique and from the infinitely many solutions
the one is selected that minimizes both |x|^2 and |A*x - b|^2.
</p>
<pre></PRE><P>
Extends from Modelica.Icons.Function (Icon for functions).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, :]</TD><TD>Matrix A</TD></TR>
<TR><TD>b[size(A, 1)]</TD><TD>Vector b</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>x[size(A, 2)]</TD><TD>Vector x such that min|A*x-b|^2 if size(A,1) &gt;= size(A,2) or min|x|^2 and A*x=b, if size(A,1) &lt; size(A,2)</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE leastSquares2<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Math.Matrices.leastSquaresI.png" ALT="Modelica_LinearSystems2.Math.Matrices.leastSquares2" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.leastSquares2"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.leastSquares2</H2>
<B>Solve overdetermined or underdetermined real system of linear equations A*X=B in a least squares sense (A may be rank deficient)</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
X = Matrices.<b>leastSquares2</b>(A,B);
</pre></blockquote>
<h4>Description</h4>
<p>
Returns a solution of equation A*X = B in a least
square sense (A may be rank deficient):
</p>
<pre>
  minimize | A*X - B |
</pre>

<p>
Several different cases can be distinguished (note, <b>rank</b> is an
output argument of this function):
</p>

<p>
<b>size(A,1) = size(A,2)</b>
</p>

<p> A solution is returned for a regular, as well as a singular matrix A:
</p>

<ul>
<li> <b>rank</b> = size(A,1):<br>
     A is <b>regular</b> and the returned solution X fulfills the equation
     A*X = B uniquely.</li>

<li> <b>rank</b> &lt; size(A,1):<br>
     A is <b>singular</b> and no unique solution for equation A*X = B exists.
     <ul>
     <li>  If an infinite number of solutions exists, the one is selected that fulfills
           the equation and at the same time has the minimum norm |x| for all solution
           vectors that fulfill the equation.</li>
     <li>  If no solution exists, X is selected such that |A*X - B| is as small as
           possible (but A*X - B is not zero).</li>
     </ul>
</ul>

<p>
<b>size(A,1) &gt; size(A,2):</b>
</p>

<p>
The equation A*X = B has no unique solution. The solution X is selected such that
|A*X - B| is as small as possible. If rank = size(A,2), this minimum norm solution is
unique. If rank &lt; size(A,2), there are an infinite number of solutions leading to the
same minimum value of |A*X - B|. From these infinite number of solutions, the one with the
minimum norm |X| is selected. This gives a unique solution that minimizes both
|A*X - B| and |X|.
</p>

<p>
<b>size(A,1) &lt; size(A,2):</b>
</p>

<ul>
<li> <b>rank</b> = size(A,1):<br>
     There are an infinite number of solutions that fulfill the equation A*X = B.
     From this infinite number, the unique solution is selected that minimizes |X|.
     </li>

<li> <b>rank</b> &lt; size(A,1):<br>
     There is either no solution of equation A*X = B, or there are again an infinite
     number of solutions. The unique solution X is returned that minimizes
      both |A*X - B| and |X|.</li>
</ul>


<p>
Note, the solution is computed with the LAPACK function "dgelsx",
i.e., QR or LQ factorization of A with column pivoting.
</p>

<h4>Algorithmic details</h4>

<p>
The function first computes a QR factorization with column pivoting:
</p>

<pre>
      A * P = Q * [ R11 R12 ]
                  [  0  R22 ]
</pre>

<p>
with R11 defined as the largest leading submatrix whose estimated
condition number is less than 1/rcond.  The order of R11, <b>rank</b>,
is the effective rank of A.
</p>

<p>
Then, R22 is considered to be negligible, and R12 is annihilated
by orthogonal transformations from the right, arriving at the
complete orthogonal factorization:
</p>

<pre>
     A * P = Q * [ T11 0 ] * Z
                 [  0  0 ]
</pre>

<p>
The minimum-norm solution is then
</p>

<pre>
     X = P * Z' [ inv(T11)*Q1'*B ]
                [        0       ]
</pre>

<p>
where Q1 consists of the first "rank" columns of Q.
</p>


<h4>See also</h4>

<p>
Matrices.leastSquares</a>
(same as leastSquares2, but with a right hand side vector), <br>
Matrices.solve2</a>
(for square, regular matrices A)
</p>

<pre></PRE><P>
Extends from Modelica.Icons.Function (Icon for functions).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, :]</TD><TD>Matrix A</TD></TR>
<TR><TD>B[size(A, 1), :]</TD><TD>Matrix B</TD></TR>
<TR><TD>rcond</TD><TD>Reciprocal condition number to estimate rank of A</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>X[size(A, 2), size(B, 2)]</TD><TD>Matrix X such that min|A*X-B|^2 if size(A,1) &gt;= size(A,2) or min|X|^2 and A*X=B, if size(A,1) &lt; size(A,2)</TD></TR>
<TR><TD>rank</TD><TD>Rank of A</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE QR<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.QR"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.QR</H2>
<B>QR decomposition of a rectangular matrix without column pivoting (A = Q*R). Return the full square Q-matrix</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, :]</TD><TD>Rectangular matrix with size(A,1) &gt;= size(A,2)</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Q[size(A, 1), size(A, 2)]</TD><TD>Rectangular matrix with orthonormal columns such that Q*R=A[:,p]</TD></TR>
<TR><TD>R[min(size(A, 1), size(A, 2)), size(A, 2)]</TD><TD>Square upper triangular matrix</TD></TR>
<TR><TD>tau[min(size(A, 1), size(A, 2))]</TD><TD>&nbsp;</TD></TR>
<TR><TD>Q2[size(A, 1), size(A, 1)]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE LQ<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.LQ"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.LQ</H2>
<B>LQ decomposition of a rectangular matrix without column pivoting (A = L*Q)</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
(Q,R,p) = Matrices.<b>QR</b>(A);
</pre></blockquote>
<h4>Description</h4>
<p>
This function returns the QR decomposition of
a rectangular matrix <b>A</b> (the number of columns of <b>A</b>
must be less than or equal to the number of rows):
</p>
<blockquote>
<p>
<b>Q</b>*<b>R</b> = <b>A</b>[:,<b>p</b>]
</p>
</blockquote>
<p>
where <b>Q</b> is a rectangular matrix that has orthonormal columns and
has the same size as A (<b>Q</b><sup>T</sup><b>Q</b>=<b>I</b>),
<b>R</b> is a square, upper triangular matrix and <b>p</b> is a permutation
vector. Matrix <b>R</b> has the following important properties:
</p>
<ul>
<li> The absolute value of a diagonal element of <b>R</b> is the largest
     value in this row, i.e.,
     abs(R[i,i]) &ge; abs(R[i,j]).</li>
<li> The diagonal elements of <b>R</b> are sorted according to size, such that
     the largest absolute value is abs(R[1,1]) and
     abs(R[i,i]) &ge; abs(R[j,j]) with i &lt; j. </li>
</ul>
<p>
This means that if abs(R[i,i]) &le; &epsilon; then abs(R[j,k]) &le; &epsilon;
for j &ge; i, i.e., the i-th row up to the last row of <b>R</b> have
small elements and can be treated as being zero. 
This allows to, e.g., estimate the row-rank
of <b>R</b> (which is the same row-rank as <b>A</b>). Furthermore,
<b>R</b> can be partitioned in two parts
</p>
<blockquote>
<pre>
   <b>A</b>[:,<b>p</b>] = <b>Q</b> * [<b>R</b><sub>1</sub>, <b>R</b><sub>2</sub>;
                 <b>0</b>,  <b>0</b>]
</pre>
</blockquote>
<p>
where <b>R</b><sub>1</sub> is a regular, upper triangular matrix. 
</p>
<p>
Note, the solution is computed with the LAPACK functions "dgeqp3"
and "dorgqr", i.e., by Housholder transformations with
column pivoting. If <b>Q</b> is not needed, the function may be
called as: <code>(,R,p) = QR(A)</code>.
</p>
<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3; 
                 3,4,5;
                 2,1,4];
  Real R[3,3];
<b>algorithm</b>
  (,R) := Matrices.QR(A);  // R = [-7.07.., -4.24.., -3.67..;
                                    0     , -1.73.., -0.23..;
                                    0     ,  0     ,  0.65..];
</pre></blockquote>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, :]</TD><TD>Rectangular matrix</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>L[size(A, 1), size(A, 1)]</TD><TD>Rectangular matrix containing the lower triangular matrix</TD></TR>
<TR><TD>Q[size(A, 1), size(A, 2)]</TD><TD>Rectangular matrix with orthonormal columns such that L*Q=A</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE orthogonalQ<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.orthogonalQ"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.orthogonalQ</H2>
<B>generates a real orthogonal matrix Q which is defined as the product of IHI-ILO elementary reflectors of order N, as returned by DGEHRD</B><p>
<P><H3>Information</H3></P>
<PRE>   Purpose  
/*  ======= */
 
/*  DORGHR generates a real orthogonal matrix Q which is defined as the */
/*  product of IHI-ILO elementary reflectors of order N, as returned by */
/*  DGEHRD: */
 
/*  Q = H(ilo) H(ilo+1) . . . H(ihi-1). */
 
/*  Arguments */
/*  ========= */
 
/*  N       (input) INTEGER */
/*          The order of the matrix Q. N &gt;= 0. */
 
/*  ILO     (input) INTEGER */
/*  IHI     (input) INTEGER */
/*          ILO and IHI must have the same values as in the previous call */
/*          of DGEHRD. Q is equal to the unit matrix except in the */
/*          submatrix Q(ilo+1:ihi,ilo+1:ihi). */
/*          1 &lt;= ILO &lt;= IHI &lt;= N, if N &gt; 0; ILO=1 and IHI=0, if N=0. */
 
/*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N) */
/*          On entry, the vectors which define the elementary reflectors, */
/*          as returned by DGEHRD. */
/*          On exit, the N-by-N orthogonal matrix Q. */
 
/*  LDA     (input) INTEGER */
/*          The leading dimension of the array A. LDA &gt;= max(1,N). */
 
/*  TAU     (input) DOUBLE PRECISION array, dimension (N-1) */
/*          TAU(i) must contain the scalar factor of the elementary */
/*          reflector H(i), as returned by DGEHRD. */
 
/*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK) */
/*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK. */
 
/*  LWORK   (input) INTEGER */
/*          The dimension of the array WORK. LWORK &gt;= IHI-ILO. */
/*          For optimum performance LWORK &gt;= (IHI-ILO)*NB, where NB is */
/*          the optimal blocksize. */
 
/*          If LWORK = -1, then a workspace query is assumed; the routine */
/*          only calculates the optimal size of the WORK array, returns */
/*          this value as the first entry of the WORK array, and no error */
/*          message related to LWORK is issued by XERBLA. */
 
/*  INFO    (output) INTEGER */
/*          = 0:  successful exit */
/*          &lt; 0:  if INFO = -i, the i-th argument had an illegal value */
 
/*  ===================================================================== */</PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>tau[size(A, 1) - 1]</TD><TD>scalar factors of the elementary reflectors</TD></TR>
<TR><TD>ilo</TD><TD>lowest index where the original matrix had been Hessenbergform - ilo must have the same value as in the previous call of DGEHRD</TD></TR>
<TR><TD>ihi</TD><TD>highest index where the original matrix had been Hessenbergform  - ihi must have the same value as in the previous call of DGEHRD</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Q[size(A, 1), size(A, 2)]</TD><TD>Orthogonal matrix as a result of elementary reflectors</TD></TR>
<TR><TD>info</TD><TD>&nbsp;</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE cholesky<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.cholesky"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.cholesky</H2>
<B>Compute the Cholesky factorization of a symmetric positive definte matrix</B><p>
<P><H3>Information</H3></P>
<PRE></pre>

<pre> </PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>upper</TD><TD>True if the upper triangle of A is provided</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>H[size(A, 1), size(A, 2)]</TD><TD>Cholesky factor U or L for A = U&#39;*U or A = L*L&#39;</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE choleskyUpDate<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.choleskyUpDate"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.choleskyUpDate</H2>
<B>Compute the cholesky factor Lu according to Au=Lu&#39;*Lu=A + v*v&#39; with A=L&#39;*L</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
  Lud = Matrices.Utilities.<b>choleskyUpDate</b>(L, v);
  Lud = Matrices.Utilities.<b>choleskyUpDate</b>(L, v, true);
</pre></blockquote>
<h4>Description</h4>
<p>
Function </b>choleskyUpDate(L, v)</b> computes the rank-1-updated Cholesky factorization <b>Lud</b>, with
</p>
<blockquote><pre>
             T          T     T      T
<b>Aud</b> = <b>Lud</b>*<b>Lud</b> = <b>A</b> +  <b>v</b>*<b>v</b> = <b>L</b>*<b>L</b> +  <b>v</b>*<b>v</b>  
</pre></blockquote>
<p>
from the input <b>L</b>, i.e. the left (lower) Cholesky factor of the original matrix <b>A</b>.<br>
The approach is a transformation <b>H</b>*[<b>v</b>, <b>L</b>]' = [<b>0</b>, <b>Lud</b>]' with orthonormal matrix <b>H</b> such, that
</p>
<blockquote><pre>
                      T          T         T               T     T
   [<b>0</b>, <b>Lud</b>] * [<b>0</b>, <b>Lud</b>] = [<b>v</b>, <b>L</b>]*<b>H</b> *<b>H</b>*[<b>v</b>, <b>L</b>] = [<b>v</b>, <b>L</b>]*[<b>v</b>, <b>L</b>] = <b>v</b>*<b>v</b> + <b>A</b>
</blockquote></pre>
and matrix <b>Lud</b> is lower (upper) triangular. The transformation is performed by n (order of <b>A</b>) Givens rotations.
The following sequence illustrates the principle of stepwise transformation of matrix [v, L]'. "*" are arbitrary elements. For each step the changed elements are bold.
<blockquote><pre>
| v' |    | * * * * |       | 0 <b>*</b> <b>*</b> <b>*</b> |       | 0 0 <b>*</b> <b>*</b> |       | 0 0 0 <b>*</b> |       | 0 0 0 0 | 
|    |    | * * * * |       | <b>*</b> <b>*</b> <b>*</b> <b>*</b> |       | * * * * |       | * * * * |       | * * * * | 
| L' | =  | 0 * * * |  ->   | 0 * * * |  ->   | 0 <b>*</b> <b>*</b> <b>*</b> |  ->   | 0 * * * |  ->   | 0 * * * | 
|    |    | 0 0 * * |       | 0 0 * * |       | 0 0 * * |       | 0 0 <b>*</b> <b>*</b> |       | 0 0 * * |  
|    |    | 0 0 0 * |       | 0 0 0 * |       | 0 0 0 * |       | 0 0 0 * |       | 0 0 0 <b>*</b> | 

</pre></blockquote>
With the boolean input "upper" the user specifies wether the matrix <b>L</b> is lower or upper triangular matrix (left or right Cholesky factor).
If "upper==true", the output <b>Lud</b> is also upper triangular. Default is "upper==false".

</blockquote>
<h4>Example</h4>
<blockquote><pre>
 

<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>L[:, size(L, 1)]</TD><TD>Cholesky factor</TD></TR>
<TR><TD>v[size(L, 1)]</TD><TD>Real vector A+v*v&#39;</TD></TR>
<TR><TD>upper</TD><TD>True if the upper triangle of A is provided and the modified upper triangle will be returned</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Lud[size(L, 1), size(L, 2)]</TD><TD>Updated Cholesky factor</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE choleskyDownDate<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.choleskyDownDate"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.choleskyDownDate</H2>
<B>Compute the cholesky factor Ld according to Ad=Ld&#39;*Ld=A - v*v&#39; with A=L&#39;*L</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
  Ldd = Matrices.Utilities.<b>choleskyUpDate</b>(L, v);
  Ldd = Matrices.Utilities.<b>choleskyUpDate</b>(L, v, true);
</pre></blockquote>
<h4>Description</h4>
<p>
Function </b>choleskyDownDate(L, v)</b> computes the rank-1-downdated Cholesky factorization <b>Ldd</b>, with
</p>
<blockquote><pre>
             T          T     T      T
<b>Add</b> = <b>Ldd</b>*<b>Ldd</b> = <b>A</b> -  <b>v</b>*<b>v</b> = <b>L</b>*<b>L</b> -  <b>v</b>*<b>v</b>  

</pre>
</blockquote>
<p>
from the input <b>L</b>, i.e. the left (lower) Cholesky factor of the original matrix <b>A</b>.<br>
The algortihm is taken from [1].
</p>
Matrix <b>Ldd</b> is calculated by
<p>
<blockquote><pre>
          T           T    
  [<b>v</b>, <b>Ldd</b>] = <b>H</b> *[<b>0</b>, <b>L</b>]
</blockquote></pre>
<blockquote><pre>
                      T          T         T               T     T
   [<b>v</b>, <b>Ldd</b>] * [<b>v</b>, <b>Ldd</b>] = [<b>0</b>, <b>L</b>]*<b>H</b> *<b>H</b>*[<b>0</b>, <b>L</b>] = [<b>0</b>, <b>L</b>]*[<b>0</b>, <b>L</b>] = <b>L</b>*<b>L</b> + <b>A</b>,
</blockquote></pre>
i.e., by orthogonal transformation 
<blockquote><pre>
 <b>H</b> = <b>H</b>_1*...*<b>H</b>_n.
</blockquote></pre>
The matrices <b>H</b>_i are Givens matrices computed such, that
<blockquote><pre>
                     T T                T
<b>H</b>_1*<b>H</b>_2*...*<b>H</b>_n*[z, <b>a</b> ] = [1, 0, ..., 0],
</blockquote></pre>
with <b>a</b> is the solution of
<blockquote><pre>
<b>L</b>*<b>a</b> = <b>x</b>
</blockquote></pre>
and 
<blockquote><pre>
z = ||<b>a</b>||.
</blockquote></pre>
</p>
The following sequence illustrate the principle of calculating the <b>H</b>_i, starting with <b>H</b>_n
<blockquote><pre>
|z|      |z|      |z|      |z|      
|a| H_3  |a| H_2  |a| H_1  |0|
|a| -->  |a| -->  |0| -->  |0|
|a|      |0|      |0|      |0|

</pre></blockquote>
Note, that the z and a are different in each column.<br>
It is shown in [1] that this algorithms results in the modified Cholesky factor <b>Ldd</b>.<br>

With the boolean input "upper" the user specifies wether the matrix <b>L</b> is lower or upper triangular matrix (left or right Cholesky factor).
If "upper==true", the output <b>Ldd</b> is also upper triangular. Default is "upper==false".


<h4>References</h4>
<table>
<tr> <td align=right>  [1] </td><td align=center>  Dongarra, J. J., Bunch, J. R., Moler, G. B., Stewart, G.W.
  </td>  <td> "LINPACK Users' Guide "  </td> <td> Society for Industrial Mathematics, 1987
 </td></tr>
</table>


</blockquote>
<h4>Example</h4>
<blockquote><pre>
 

<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>L[:, size(L, 1)]</TD><TD>Cholesky factor</TD></TR>
<TR><TD>v[size(L, 1)]</TD><TD>Real vector A+v*v&#39;</TD></TR>
<TR><TD>upper</TD><TD>True if the upper triangle of A is provided</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Ldd[size(L, 1), size(L, 2)]</TD><TD>Updated Cholesky factor</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE rsf<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.rsf"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.rsf</H2>
<B>Computes the real Schur form (RSF) of a square matrix</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4><font color="#008000">Syntax</font></h4>
<table>
<tr> <td align=right>  (T, Z, alphaReal, alphaImag) </td><td align=center> =  </td>  <td> Modelica_LinearSystems2.Math.Matrices.<b<rsf</b>(A)  </td> </tr>
</table>
<h4><font color="#008000">Description</font></h4>
<p>
Function <b>rsf</b> (real Schur form) calculates the real Schur form af a real square matrix <b>A</b>, i.e.
<blockquote><pre>
         T
A = Z*T*Z

</pre></blockquote>
with the real nxn matrices <b>T</b> and <b>Z</b>. <b>Z</b> is an orthogonal matrix.  <b>T</b> is an block upper triangular matrix with 1x1 and 2x2 blocks in the diagonal.The 1x1 blocks contains the real eigenvalues of a. The 2x2 blocks are matrices with the conjugated complex pairs of eigenvalues, whereas the real parts of the eigenvalues are the elements of the diagonal.
<p>
The calculation is performed stepwise using several lapack routines. First, lapack.dgehrd reduces matrix <b>A</b> is to upper Hessenberg form <b>H</b>=<b>Q'AQ</b>, whereas <b>Q</b> is computed by lapack.dodrghr.Finally, lapack.dhseqr transforms <b>H</b> to <b>T</b>. The eigenvalues of <b>A</b> are calculated straightforward from <b>T</b>.
<p>
Function <b>rsf</b> does not apply lapack.dgees, a routine to directly compute the real Schur from. See also
<A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.rsf2"
>Math.Matrices.rsf2</a>
</p>


<h4><font color="#008000">Example</font></h4>
<blockquote><pre>
   Real A[3,3] = [1, 2, 3; 4, 5, 6; 7, 8, 9];
   Real T[3,3];
   Real Z[3,3];
   Real alphaReal[3];
   Real alphaImag[3];

<b>algorithm</b>
  (T, Z, alphaReal, alphaImag):=Modelica_LinearSystems2.Math.Matrices.rsf(A);
//   T = [16.12, 4.9,   1.59E-015;
//        0,    -1.12, -1.12E-015;
//        0,     0,    -1.30E-015]
//   Z = [-0.23,  -0.88,   0.41;
//        -0.52,  -0.24,  -0.82;
//        -0.82,   0.4,    0.41]
//alphaReal = {16.12, -1.12, -1.32E-015}
//alphaImag = {0, 0, 0}

</pre></blockquote>
<pre> </PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>T[size(A, 1), size(A, 2)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>Z[size(A, 1), size(A, 2)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>alphaReal[size(A, 1)]</TD><TD>Real part of eigenvalue=alphaReal+i*alphaImag</TD></TR>
<TR><TD>alphaImag[size(A, 1)]</TD><TD>Imaginary part of eigenvalue=(alphaReal+i*alphaImag</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE rsf2<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.rsf2"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.rsf2</H2>
<B>Computes the real Schur form (RSF) of a square matrix but uses lapack.dgees</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4><font color="#008000">Syntax</font></h4>
<table>
<tr> <td align=right>  (T, Z, alphaReal, alphaImag) </td><td align=center> =  </td>  <td> Modelica_LinearSystems2.Math.Matrices.<b<rsf2</b>(A)  </td> </tr>
</table>
<h4><font color="#008000">Description</font></h4>
<p>
Function <b>rsf2</b> (real Schur form) calculates the real Schur form af a real square matrix <b>A</b>, i.e.
<blockquote><pre>
         T
A = Z*T*Z

</pre></blockquote>
with the real nxn matrices <b>T</b> and <b>Z</b>. <b>Z</b> is an orthogonal matrix.  <b>T</b> is an block upper triangular matrix with 1x1 and 2x2 blocks in the diagonal.The 1x1 blocks contains the real eigenvalues of a. The 2x2 blocks are matrices with the conjugated complex pairs of eigenvalues, whereas the real parts of the eigenvalues are the elements of the diagonal.
<p>
The calculation is performed stepwise using lapack.dgees, i.e. using the internal mehtods of balacing and scaling of dgees.
<p>
See also <A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices.rsf"
>Math.Matrices.rsf</a>
</p>


<h4><font color="#008000">Example</font></h4>
<blockquote><pre>
   Real A[3,3] = [1, 2, 3; 4, 5, 6; 7, 8, 9];
   Real T[3,3];
   Real Z[3,3];
   Real alphaReal[3];
   Real alphaImag[3];

<b>algorithm</b>
  (T, Z, alphaReal, alphaImag):=Modelica_LinearSystems2.Math.Matrices.rsf2(A);
//   T = [16.12, 4.9,   1.59E-015;
//        0,    -1.12, -1.12E-015;
//        0,     0,    -1.30E-015]
//   Z = [-0.23,  -0.88,   0.41;
//        -0.52,  -0.24,  -0.82;
//        -0.82,   0.4,    0.41]
//alphaReal = {16.12, -1.12, -1.32E-015}
//alphaImag = {0, 0, 0}

</pre></blockquote>
<pre> </PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>S[size(A, 1), size(A, 2)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>QZ[size(A, 1), size(A, 2)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>alphaReal[size(A, 1)]</TD><TD>Real part of eigenvalue=alphaReal+i*alphaImag</TD></TR>
<TR><TD>alphaImag[size(A, 1)]</TD><TD>Imaginary part of eigenvalue=(alphaReal+i*alphaImag</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE hessenberg<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.hessenberg"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.hessenberg</H2>
<B>Transform a matrix to upper Hessenberg form</B><p>
<P><H3>Information</H3></P>
<PRE></pre>

<h4>Syntax</h4>
<blockquote><pre>
         H = Matrices.<b>hessenberg</b>(A);
    (H, U) = Matrices.<b>hessenberg</b>(A);
 </pre></blockquote>
<h4>Description</h4>
Function <b>hessenberg</b> computes the Hessenberg matrix <b>H</b> of matrix <b>A</b> as well as the orthogonal transformation matrix <b>U</b> that holds <b>H</b> = <b>U</b>'*<b>A</b>*<b>U</b>.
The Hessenberg form of a matrix is computed by repeated Householder similarity transformation. The elementary reflectors and the corresponding scalar factors are provided
by function "Utilities.toUpperHessenberg()". The transformation matrix <b>U</b> is then computed by
LAPACK.dorghr</a>.<br>
<p>
<h4>Example</h4>
<blockquote><pre>
 A  = [1, 2,  3;
       6, 5,  4;
       1, 0,  0];

 (H, U) = hessenberg(A);

  results in:

 H = [1.0,  -2.466,  2.630;
     -6.083, 5.514, -3.081;
      0.0,   0.919, -0.514]

 U = [1.0,    0.0,      0.0;
      0.0,   -0.9864,  -0.1644;
      0.0,   -0.1644,   0.9864]

  and therefore,

 u*H*transpose(U) = [1.0, 2.0, 3.0;
                     6.0, 5.0, 4.0;
                     1.0, 0.0, 0.0]

</pre></blockquote>

<h4>See also</h4>
Matrices.Utilities.toUpperHessenberg</a>

<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, :]</TD><TD>Square matrix A</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>H[size(A, 1), size(A, 2)]</TD><TD>Hessenberg form of A</TD></TR>
<TR><TD>U[size(A, 1), size(A, 2)]</TD><TD>Transformation matrix</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE toUpperHessenberg<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.toUpperHessenberg"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.toUpperHessenberg</H2>
<B>transform a real general matrix A to upper Hessenberg form H by an orthogonal similarity transformation:  Q&#39; * A * Q = H</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
  
   <h4>Syntax</h4>
<blockquote><pre>
         H = Matrices.Utilities<b>toUpperHessenberg</b>(A);
         (H, V, tau, info) = Matrices.Utilities<b>toUpperHessenberg</b>(A,ilo, ihi);
</pre></blockquote>
<h4>Description</h4>
Function <b>toUpperHessenberg</b> computes a upper Hessenberg form <b>H</b> of a matrix <b>A</b> by orthogonal similarity transformation:  <b>Q</b>' * <b>A</b> * <b>Q</b> = <b>H</b>.
It calls LAPACK function DGEHRD. See Matrices.Lapack.dgehrd for more information about the additional outputs V, tau, info and inputs ilo, ihi for more information.
<p>


<h4>Example</h4>
<blockquote><pre>
 A  = [1, 2,  3;
       6, 5,  4;
       1, 0,  0]; 

 H = toUpperHessenberg(A);

  results in:
  
 H = [1.0,  -2.466,  2.630;
     -6.083, 5.514, -3.081;
      0.0,   0.919, -0.514]
      
</pre></blockquote>

<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>Square matrix A</TD></TR>
<TR><TD>ilo</TD><TD>lowest index where the original matrix had been Hessenbergform</TD></TR>
<TR><TD>ihi</TD><TD>highest index where the original matrix had been Hessenbergform</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>H[size(A, 1), size(A, 2)]</TD><TD>Upper Hessenberg form</TD></TR>
<TR><TD>V[size(A, 1), size(A, 2)]</TD><TD>V=[v1,v2,..vn-1,0] with vi are vectors which define the elementary reflectors</TD></TR>
<TR><TD>tau[max(0, size(A, 1) - 1)]</TD><TD>Scalar factors of the elementary reflectors</TD></TR>
<TR><TD>info</TD><TD>&nbsp;</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE householderReflexion<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.householderReflexion"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.householderReflexion</H2>
<B>Reflect each of the vectors ai of matrix  A=[a1, a2, ..., an] on a plane with orthogonal vector u</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<b>householderReflection</b>(A,u);
</pre></blockquote>
<h4>Description</h4>
<p>
This function computes the Housholder reflection (transformation)
</p>
<blockquote>
 <b>Ar</b> = <b>Q</b>*<b>A</b>
</blockquote>
with
<blockquote>
 <b>Q</b> = <b>I</b> -2*<b>u</b>*<b>u</b>'/(<b>u</b>'*<b>u</b>)
</blockquote>
<p>
where <b>u</b>*<b>u</b> is housholder vector, i.e. the normal vector of the reflection plane.
<p>
Householder reflection is widely used in numerical linear algebra, e.g. to perform QR decompositions.
</p>
<h4>Example</h4>
<blockquote><pre>
// First step of QR decomposition
  import   Modelica.Math.Vectors.Utilities;
  
  Real A[3,3] = [1,2,3;
                 3,4,5;
                 2,1,4];
  Real Ar[3,3];
  Real u[:];
  
  u=Utilities.householderVector(A[:,1],{1,0,0});
  // u={ = {0.763, 0.646, 0}
  Ar=householderReflexion(A,u);
 // Ar = [-6.0828,   -5.2608,   -4.4388;
 //        0.0,      -1.1508,   -2.3016;
 //        0.0,       2.0,       0.0]

</pre></blockquote>

<h4>See also</h4>
<p>
<a href="modelica://Modelica.Math.Matrices.housholderSimilarityTransformation">Matrices.housholderSimilarityTransformation</a>,
</p>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, :]</TD><TD>Rectangular matrix</TD></TR>
<TR><TD>u[size(A, 1)]</TD><TD>Householder vector</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>RA[size(A, 1), size(A, 2)]</TD><TD>Reflexion of A</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE householderSimilarityTransformation<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.householderSimilarityTransformation"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.householderSimilarityTransformation</H2>
<B>Calculate the similarity transformation S*A*S of matrix A with symmetric householder matrix S = I - 2u*u&#39;</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<b>householderSimilarityTransformation</b>(A,u);
</pre></blockquote>
<h4>Description</h4>
<p>
This function computes the Housholder similarity transformation
</p>
<blockquote>
 <b>As</b> = <b>S</b>*<b>A</b>*<b>S</b>
</blockquote>
with
<blockquote>
 <b>S</b> = <b>I</b> -2*<b>u</b>*<b>u</b>'/(<b>u</b>'*<b>u</b>).
</blockquote>
<p>
This transformation is widely used for transforming non-symmetric matrices to a Hessenberg form.
</p>
<h4>Example</h4>
<blockquote><pre>
// First step of Hessenberg decomposition
  import   Modelica.Math.Vectors.Utilities;
  
  Real A[4,4] = [1,2,3,4;
                 3,4,5,6;
                 9,8,7,6;
                 1,2,0,0];
  Real Ar[4,4];
  Real u[4]={0,0,0,0};
  
  u[2:4]=Utilities.householderVector(A[2:4,1],{1,0,0});
  // u= = {0, 0.8107, 0.5819, 0.0647}
  Ar=householderSimilarityTransformation(A,u);
 //  Ar = [1.0,     -3.8787,    -1.2193,    3.531;
          -9.5394, 11.3407,      6.4336,   -5.9243;
           0.0,     3.1307,      0.7525,   -3.3670;
           0.0,     0.8021,     -1.1656,   -1.0932]
</pre></blockquote>

<h4>See also</h4>
<p>
<a href="modelica://Modelica.Math.Matrices.housholderReflection">Matrices.housholderReflection</a>,
</p>
<pre></PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>Square matrix A</TD></TR>
<TR><TD>u[size(A, 1)]</TD><TD>Householder vector</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>SAS[size(A, 1), size(A, 1)]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE fliplr<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.fliplr"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.fliplr</H2>
<B>flip the columns of a matrix in left/right direction</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, :]</TD><TD>Matrix to be fliped</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Aflip[size(A, 1), size(A, 2)]</TD><TD>fliped matrix</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE flipud<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.flipud"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.flipud</H2>
<B>flip the columns of a matrix in up/down direction</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, :]</TD><TD>Matrix to be flipped</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Aflip[size(A, 1), size(A, 2)]</TD><TD>flipped matrix</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE triangle<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.triangle"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.triangle</H2>
<B>Return the upper/lower triangular part of a square matrix</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>Square matrix</TD></TR>
<TR><TD>upper</TD><TD>True for upper triangle to return</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Tri[size(A, 1), size(A, 2)]</TD><TD>Triangular matrix</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE trace<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica_LinearSystems2.Math.Matrices.traceI.png" ALT="Modelica_LinearSystems2.Math.Matrices.trace" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica_LinearSystems2.Math.Matrices.trace"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.trace</H2>
<B>tarce(A) is the sum of the diagonal elements of A</B><p>
<P><H3>Information</H3></P>
Extends from Modelica.Icons.Function (Icon for functions).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>result</TD><TD>&nbsp;</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE generalizedEigenvaluesTriangular<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.generalizedEigenvaluesTriangular"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.generalizedEigenvaluesTriangular</H2>
<B>Compute invariant zeros of linear state space system with a generalized system matrix [A, B, C, D] which is of upper Hessenberg form</B><p>
<P><H3>Information</H3></P>
<PRE>This function is an interface to LAPACK routine DHGEQZ to calculate invariant
zeros of systems with generalized system matrices of upper Hessenberg form.
DHGEQZ is described below:
 
 
 
     Purpose  
   ==========================================================
 
   DHGEQZ implements a single-/double-shift version of the QZ method for  
   finding the generalized eigenvalues  
 
   w(j)=(ALPHAR(j) + i*ALPHAI(j))/BETAR(j)   of the equation  
 
        det( A - w(i) B ) = 0  
 
   In addition, the pair A,B may be reduced to generalized Schur form:  
   B is upper triangular, and A is block upper triangular, where the  
   diagonal blocks are either 1-by-1 or 2-by-2, the 2-by-2 blocks having  
   complex generalized eigenvalues (see the description of the argument  
   JOB.)  
 
   If JOB=&#39;S&#39;, then the pair (A,B) is simultaneously reduced to Schur  
   form by applying one orthogonal tranformation (usually called Q) on  
   the left and another (usually called Z) on the right.  The 2-by-2  
   upper-triangular diagonal blocks of B corresponding to 2-by-2 blocks  
   of A will be reduced to positive diagonal matrices.  (I.e.,  
   if A(j+1,j) is non-zero, then B(j+1,j)=B(j,j+1)=0 and B(j,j) and  
   B(j+1,j+1) will be positive.)  
 
   If JOB=&#39;E&#39;, then at each iteration, the same transformations  
   are computed, but they are only applied to those parts of A and B  
   which are needed to compute ALPHAR, ALPHAI, and BETAR.  
 
   If JOB=&#39;S&#39; and COMPQ and COMPZ are &#39;V&#39; or &#39;I&#39;, then the orthogonal  
   transformations used to reduce (A,B) are accumulated into the arrays  
   Q and Z s.t.:  
 
        Q(in) A(in) Z(in)* = Q(out) A(out) Z(out)*  
        Q(in) B(in) Z(in)* = Q(out) B(out) Z(out)*  
 
   Ref: C.B. Moler &amp; G.W. Stewart, &quot;An Algorithm for Generalized Matrix  
        Eigenvalue Problems&quot;, SIAM J. Numer. Anal., 10(1973),  
        pp. 241--256.  
 
   Arguments  
   =========  
 
   JOB     (input) CHARACTER*1  
           = &#39;E&#39;: compute only ALPHAR, ALPHAI, and BETA.  A and B will  
                  not necessarily be put into generalized Schur form.  
           = &#39;S&#39;: put A and B into generalized Schur form, as well  
                  as computing ALPHAR, ALPHAI, and BETA.  
 
   COMPQ   (input) CHARACTER*1  
           = &#39;N&#39;: do not modify Q.  
           = &#39;V&#39;: multiply the array Q on the right by the transpose of  
                  the orthogonal tranformation that is applied to the  
                  left side of A and B to reduce them to Schur form.  
           = &#39;I&#39;: like COMPQ=&#39;V&#39;, except that Q will be initialized to  
                  the identity first.  
 
   COMPZ   (input) CHARACTER*1  
           = &#39;N&#39;: do not modify Z.  
           = &#39;V&#39;: multiply the array Z on the right by the orthogonal  
                  tranformation that is applied to the right side of  
                  A and B to reduce them to Schur form.  
           = &#39;I&#39;: like COMPZ=&#39;V&#39;, except that Z will be initialized to  
                  the identity first.  
 
   N       (input) INTEGER  
           The order of the matrices A, B, Q, and Z.  N &gt;= 0.  
 
   ILO     (input) INTEGER  
   IHI     (input) INTEGER  
           It is assumed that A is already upper triangular in rows and  
           columns 1:ILO-1 and IHI+1:N.  
           1 &lt;= ILO &lt;= IHI &lt;= N, if N &gt; 0; ILO=1 and IHI=0, if N=0.  
 
   A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)  
           On entry, the N-by-N upper Hessenberg matrix A.  Elements  
           below the subdiagonal must be zero.  
           If JOB=&#39;S&#39;, then on exit A and B will have been  
              simultaneously reduced to generalized Schur form.  
           If JOB=&#39;E&#39;, then on exit A will have been destroyed.  
              The diagonal blocks will be correct, but the off-diagonal  
              portion will be meaningless.  
 
   LDA     (input) INTEGER  
           The leading dimension of the array A.  LDA &gt;= max( 1, N ).  
 
   B       (input/output) DOUBLE PRECISION array, dimension (LDB, N)  
           On entry, the N-by-N upper triangular matrix B.  Elements  
           below the diagonal must be zero.  2-by-2 blocks in B  
           corresponding to 2-by-2 blocks in A will be reduced to  
           positive diagonal form.  (I.e., if A(j+1,j) is non-zero,  
           then B(j+1,j)=B(j,j+1)=0 and B(j,j) and B(j+1,j+1) will be  
           positive.)  
           If JOB=&#39;S&#39;, then on exit A and B will have been  
              simultaneously reduced to Schur form.  
           If JOB=&#39;E&#39;, then on exit B will have been destroyed.  
              Elements corresponding to diagonal blocks of A will be  
              correct, but the off-diagonal portion will be meaningless.  
 
   LDB     (input) INTEGER  
           The leading dimension of the array B.  LDB &gt;= max( 1, N ).  
 
   ALPHAR  (output) DOUBLE PRECISION array, dimension (N)  
           ALPHAR(1:N) will be set to real parts of the diagonal  
           elements of A that would result from reducing A and B to  
           Schur form and then further reducing them both to triangular  
           form using unitary transformations s.t. the diagonal of B  
           was non-negative real.  Thus, if A(j,j) is in a 1-by-1 block  
           (i.e., A(j+1,j)=A(j,j+1)=0), then ALPHAR(j)=A(j,j).  
           Note that the (real or complex) values  
           (ALPHAR(j) + i*ALPHAI(j))/BETA(j), j=1,...,N, are the  
           generalized eigenvalues of the matrix pencil A - wB.  
 
   ALPHAI  (output) DOUBLE PRECISION array, dimension (N)  
           ALPHAI(1:N) will be set to imaginary parts of the diagonal  
           elements of A that would result from reducing A and B to  
           Schur form and then further reducing them both to triangular  
           form using unitary transformations s.t. the diagonal of B  
           was non-negative real.  Thus, if A(j,j) is in a 1-by-1 block  
           (i.e., A(j+1,j)=A(j,j+1)=0), then ALPHAR(j)=0.  
           Note that the (real or complex) values  
           (ALPHAR(j) + i*ALPHAI(j))/BETA(j), j=1,...,N, are the  
           generalized eigenvalues of the matrix pencil A - wB.  
 
   BETA    (output) DOUBLE PRECISION array, dimension (N)  
           BETA(1:N) will be set to the (real) diagonal elements of B  
           that would result from reducing A and B to Schur form and  
           then further reducing them both to triangular form using  
           unitary transformations s.t. the diagonal of B was  
           non-negative real.  Thus, if A(j,j) is in a 1-by-1 block  
           (i.e., A(j+1,j)=A(j,j+1)=0), then BETA(j)=B(j,j).  
           Note that the (real or complex) values  
           (ALPHAR(j) + i*ALPHAI(j))/BETA(j), j=1,...,N, are the  
           generalized eigenvalues of the matrix pencil A - wB.  
           (Note that BETA(1:N) will always be non-negative, and no  
           BETAI is necessary.)  
 
   Q       (input/output) DOUBLE PRECISION array, dimension (LDQ, N)  
           If COMPQ=&#39;N&#39;, then Q will not be referenced.  
           If COMPQ=&#39;V&#39; or &#39;I&#39;, then the transpose of the orthogonal  
              transformations which are applied to A and B on the left  
              will be applied to the array Q on the right.  
 
   LDQ     (input) INTEGER  
           The leading dimension of the array Q.  LDQ &gt;= 1.  
           If COMPQ=&#39;V&#39; or &#39;I&#39;, then LDQ &gt;= N.  
 
   Z       (input/output) DOUBLE PRECISION array, dimension (LDZ, N)  
           If COMPZ=&#39;N&#39;, then Z will not be referenced.  
           If COMPZ=&#39;V&#39; or &#39;I&#39;, then the orthogonal transformations  
              which are applied to A and B on the right will be applied  
              to the array Z on the right.  
 
   LDZ     (input) INTEGER  
           The leading dimension of the array Z.  LDZ &gt;= 1.  
           If COMPZ=&#39;V&#39; or &#39;I&#39;, then LDZ &gt;= N.  
 
   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)  
           On exit, if INFO &gt;= 0, WORK(1) returns the optimal LWORK.  
 
   LWORK   (input) INTEGER  
           The dimension of the array WORK.  LWORK &gt;= max(1,N).  
 
           If LWORK = -1, then a workspace query is assumed; the routine  
           only calculates the optimal size of the WORK array, returns  
           this value as the first entry of the WORK array, and no error  
           message related to LWORK is issued by XERBLA.  
 
   INFO    (output) INTEGER  
           = 0: successful exit  
           &lt; 0: if INFO = -i, the i-th argument had an illegal value  
           = 1,...,N: the QZ iteration did not converge.  (A,B) is not  
                      in Schur form, but ALPHAR(i), ALPHAI(i), and  
                      BETA(i), i=INFO+1,...,N should be correct.  
           = N+1,...,2*N: the shift calculation failed.  (A,B) is not  
                      in Schur form, but ALPHAR(i), ALPHAI(i), and  
                      BETA(i), i=INFO-N+1,...,N should be correct.  
           &gt; 2*N:     various &quot;impossible&quot; errors.  
 
   Further Details  
   ===============  
 
   Iteration counters:  
 
   JITER  -- counts iterations.  
   IITER  -- counts iterations run since ILAST was last  
             changed.  This is therefore reset only when a 1-by-1 or  
             2-by-2 block deflates off the bottom.  
 
   =====================================================================  
</PRE><P>

<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>B[size(A, 1), size(A, 1)]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>alphaReal[size(A, 1)]</TD><TD>Real part of alpha (eigenvalue=(alphaReal+i*alphaImag)/beta)</TD></TR>
<TR><TD>alphaImag[size(A, 1)]</TD><TD>Imaginary part of alpha</TD></TR>
<TR><TD>beta[size(A, 1)]</TD><TD>Denominator of eigenvalue</TD></TR>
<TR><TD>info</TD><TD>&nbsp;</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE printMatrix<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.printMatrix"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.printMatrix</H2>
<B>print matrix</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>M[:, :]</TD><TD>&nbsp;</TD></TR>
<TR><TD>significantDigits</TD><TD>Number of significant digits that are shown</TD></TR>
<TR><TD>name</TD><TD>Independent variable name used for printing</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>s</TD><TD>&nbsp;</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE fromFile<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica_LinearSystems2.Math.Matrices.fromFile"></A><A HREF="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</A>.fromFile</H2>
<B>Read matrix from a matlab file</B><p>
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>fileName</TD><TD>&nbsp;</TD></TR>
<TR><TD>matrixName</TD><TD>Name of the matrix</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[n, m]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<address>HTML-documentation generated by <a href="http://www.Dymola.com/">Dymola</a> Wed Oct 27 10:04:47 2010.
</address></BODY>
</HTML>
