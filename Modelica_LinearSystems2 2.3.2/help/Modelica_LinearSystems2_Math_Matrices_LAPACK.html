<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Modelica_LinearSystems2.Math.Matrices.LAPACK</title>
<meta name="HTML-Generator" content="Dymola">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="&quot;Package of LAPACK functions&quot;">
<style type="text/css">
*       { font-size: 10pt; font-family: Arial, sans-serif; }
.modelica, .modelica * { font-size: 9pt; font-family: Courier, monospace; white-space: pre; }
h4      { font-size: 10pt; font-weight: bold; color: green; }
h3      { font-size: 11pt; font-weight: bold; color: green; }
h2      { font-size: 13pt; font-weight: bold; color: green; }
address { font-weight: normal; }
td      { border: 1px solid #808080; vertical-align: top; }
th      { border: 1px solid #808080; vertical-align: top; font-weight: bold; }
table   { border: 1px solid #808080; border-collapse: collapse; }
</style>
</head>
<body>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE LAPACK<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><a name="Modelica_LinearSystems2.Math.Matrices.LAPACK"></a><a href="Modelica_LinearSystems2_Math_Matrices.html#Modelica_LinearSystems2.Math.Matrices"
>Modelica_LinearSystems2.Math.Matrices</a>.LAPACK</h2>
<p>
<b>Package of LAPACK functions</b><br>
</p>
<h3>Information</h3>

<p>
This package contains functions to call routines from software library
<a href="http://www.netlib.org/lapack/">LAPACK </a>
(Linear Algebra PACKage) aimed for numerical linear algebra. The library is
provided by <a href="http://www.netlib.org/">Netlib Repository</a>.
</p>

<p>Extends from Modelica.Icons.Package (Icon for standard packages).</p>
<h3>Package Content</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Package Content">
<tr>
<th>Name</th>
<th>Description</th>
</tr>
<tr>
<td><img src="Modelica_LinearSystems2.Mce8a6d083e700bd7angleS.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgecon" width="20" height="20" align="top">&nbsp;<a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dgecon"
>dgecon</a>
</td>
<td>Estimates the reciprocal of the condition number of a general real matrix A</td>
</tr>
<tr>
<td><img src="Modelica_LinearSystems2.Mce8a6d083e700bd7angleS.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgees" width="20" height="20" align="top">&nbsp;<a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dgees"
>dgees</a>
</td>
<td>Computes real Schur form T of  real nonsymmetric matrix A, and, optionally, the matrix of Schur vectors Z as well as the eigenvalues</td>
</tr>
<tr>
<td><img src="Modelica_LinearSystems2.Mce8a6d083e700bd7angleS.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgeev" width="20" height="20" align="top">&nbsp;<a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dgeev"
>dgeev</a>
</td>
<td>Compute the eigenvalues and the (real) left and right eigenvectors of matrix A</td>
</tr>
<tr>
<td><img src="Modelica_LinearSystems2.Mce8a6d083e700bd7angleS.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgeevx" width="20" height="20" align="top">&nbsp;<a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dgeevx"
>dgeevx</a>
</td>
<td>Compute the eigenvalues and the (real) left and right eigenvectors of matrix A, using lapack routine dgeevx </td>
</tr>
<tr>
<td><img src="Modelica_LinearSystems2.Mce8a6d083e700bd7angleS.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgegv" width="20" height="20" align="top">&nbsp;<a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dgegv"
>dgegv</a>
</td>
<td>Compute generalized eigenvalues for a (A,B) system</td>
</tr>
<tr>
<td><img src="Modelica_LinearSystems2.Mce8a6d083e700bd7angleS.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgehrd" width="20" height="20" align="top">&nbsp;<a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dgehrd"
>dgehrd</a>
</td>
<td>Reduces a real general matrix A to upper Hessenberg form H by an orthogonal similarity transformation:  Q&#39; * A * Q = H</td>
</tr>
<tr>
<td><img src="Modelica_LinearSystems2.Mce8a6d083e700bd7angleS.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgeqp3" width="20" height="20" align="top">&nbsp;<a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dgeqp3"
>dgeqp3</a>
</td>
<td>Computes a QR factorization with column pivoting</td>
</tr>
<tr>
<td><img src="Modelica_LinearSystems2.Mce8a6d083e700bd7angleS.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgeqrf" width="20" height="20" align="top">&nbsp;<a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dgeqrf"
>dgeqrf</a>
</td>
<td>Computes a QR factorization without pivoting</td>
</tr>
<tr>
<td><img src="Modelica_LinearSystems2.M7c6eca9d335f8c8egesddS.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgesdd" width="20" height="20" align="top">&nbsp;<a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dgesdd"
>dgesdd</a>
</td>
<td>Determine singular value decomposition</td>
</tr>
<tr>
<td><img src="Modelica_LinearSystems2.M7c6eca9d335f8c8egesddS.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgesvd" width="20" height="20" align="top">&nbsp;<a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dgesvd"
>dgesvd</a>
</td>
<td>Determine singular value decomposition</td>
</tr>
<tr>
<td><img src="Modelica_LinearSystems2.M7c6eca9d335f8c8egesddS.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgesvx" width="20" height="20" align="top">&nbsp;<a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dgesvx"
>dgesvx</a>
</td>
<td>Solve real system of linear equations op(A) * X = B, op(A) is A or A&#39; according to the boolean input transposed</td>
</tr>
<tr>
<td><img src="Modelica_LinearSystems2.M7c6f14df335f9259getrsS.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgetrs" width="20" height="20" align="top">&nbsp;<a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dgetrs"
>dgetrs</a>
</td>
<td>Solves a system of linear equations with the LU decomposition from dgetrf(..)</td>
</tr>
<tr>
<td><img src="Modelica_LinearSystems2.M7c6f14df335f9259getrsS.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.dggev" width="20" height="20" align="top">&nbsp;<a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dggev"
>dggev</a>
</td>
<td>Compute generalized eigenvalues for a (A,B) system</td>
</tr>
<tr>
<td><img src="Modelica_LinearSystems2.M7c6f14df335f9259getrsS.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.dggevx" width="20" height="20" align="top">&nbsp;<a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dggevx"
>dggevx</a>
</td>
<td>Compute generalized eigenvalues for a (A,B) system, using lapack routine dggevx</td>
</tr>
<tr>
<td><img src="Modelica_LinearSystems2.M7c6f14df335f9259getrsS.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.dhgeqz" width="20" height="20" align="top">&nbsp;<a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dhgeqz"
>dhgeqz</a>
</td>
<td>Compute generalized eigenvalues for a (A,B) system</td>
</tr>
<tr>
<td><img src="Modelica_LinearSystems2.M7c6f14df335f9259getrsS.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.dhseqr" width="20" height="20" align="top">&nbsp;<a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dhseqr"
>dhseqr</a>
</td>
<td>Compute eingenvalues of a matrix A using lapack routine DHSEQR for Hessenberg form matrix</td>
</tr>
<tr>
<td><img src="Modelica_LinearSystems2.M7c6f14df335f9259getrsS.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.dlange" width="20" height="20" align="top">&nbsp;<a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dlange"
>dlange</a>
</td>
<td>Norm of a matrix</td>
</tr>
<tr>
<td><img src="Modelica_LinearSystems2.M7c6f14df335f9259getrsS.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.dlansy" width="20" height="20" align="top">&nbsp;<a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dlansy"
>dlansy</a>
</td>
<td>Norm of a symmetric matrix</td>
</tr>
<tr>
<td><img src="Modelica_LinearSystems2.M7c6f14df335f9259getrsS.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.dorghr" width="20" height="20" align="top">&nbsp;<a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dorghr"
>dorghr</a>
</td>
<td>Generates a real orthogonal matrix Q which is defined as the product of IHI-ILO elementary reflectors of order N, as returned by DGEHRD</td>
</tr>
<tr>
<td><img src="Modelica_LinearSystems2.M7c6f14df335f9259getrsS.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.dorgqr" width="20" height="20" align="top">&nbsp;<a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dorgqr"
>dorgqr</a>
</td>
<td>Generate a real orthogonal matrix Q which is defined as the product of elementary reflectors, as returned by DGEQRF</td>
</tr>
<tr>
<td><img src="Modelica_LinearSystems2.M7c6f14df335f9259getrsS.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.dorgqr_x" width="20" height="20" align="top">&nbsp;<a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dorgqr_x"
>dorgqr_x</a>
</td>
<td>Generates a real orthogonal matrix Q which is defined as the product of elementary reflectors, as returned by DGEQRF</td>
</tr>
<tr>
<td><img src="Modelica_LinearSystems2.M7c6f14df335f9259getrsS.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.dormhr" width="20" height="20" align="top">&nbsp;<a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dormhr"
>dormhr</a>
</td>
<td>Overwrites the general real M-by-N matrix C with Q * C or C * Q or Q&#39; * C or C * Q&#39;, where Q is an orthogonal matrix as returne by dgehrd</td>
</tr>
<tr>
<td><img src="Modelica_LinearSystems2.M7c6f14df335f9259getrsS.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.dormqr" width="20" height="20" align="top">&nbsp;<a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dormqr"
>dormqr</a>
</td>
<td>Overwrites the general real M-by-N matrix C with Q * C or C * Q or Q&#39; * C or C * Q&#39;, where Q is an orthogonal matrix of a QR factorization as returned by dgeqrf</td>
</tr>
<tr>
<td><img src="Modelica_LinearSystems2.M7c6f14df335f9259getrsS.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.dtrevc" width="20" height="20" align="top">&nbsp;<a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dtrevc"
>dtrevc</a>
</td>
<td>Compute the right and/or left eigenvectors of a real upper quasi-triangular matrix T</td>
</tr>
<tr>
<td><img src="Modelica_LinearSystems2.M7c6f14df335f9259getrsS.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.dtrsen" width="20" height="20" align="top">&nbsp;<a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dtrsen"
>dtrsen</a>
</td>
<td>DTRSEN reorders the real Schur factorization of a real matrix</td>
</tr>
<tr>
<td><img src="Modelica_LinearSystems2.M7c6f14df335f9259getrsS.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.dtrsyl" width="20" height="20" align="top">&nbsp;<a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dtrsyl"
>dtrsyl</a>
</td>
<td>DTRSYL solves the real Sylvester matrix equation</td>
</tr>
<tr>
<td><img src="Modelica_LinearSystems2.M7c6cfd1f335ff272gelsxS.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgelsx" width="20" height="20" align="top">&nbsp;<a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dgelsx"
>dgelsx</a>
</td>
<td>Computes the minimum-norm solution to a real linear least squares problem with rank deficient A</td>
</tr>
<tr>
<td><img src="Modelica_LinearSystems2.M4941528a559affaedgemmS.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgemm" width="20" height="20" align="top">&nbsp;<a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dgemm"
>dgemm</a>
</td>
<td>Blas algorithm to perform C:=a*op(A)*op(B) + b*C (a,b scalars, ABC matrices)</td>
</tr>
<tr>
<td><img src="Modelica_LinearSystems2.M1bc185b9322a924cpotrfS.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.dpotrf" width="20" height="20" align="top">&nbsp;<a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dpotrf"
>dpotrf</a>
</td>
<td>Computes the Cholesky factorization of a real symmetric positive definite matrix A</td>
</tr>
<tr>
<td><img src="Modelica_LinearSystems2.M4b02aade559323aedtrmmS.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.dtrmm" width="20" height="20" align="top">&nbsp;<a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dtrmm"
>dtrmm</a>
</td>
<td>Blas algorithm to perform B := alpha*op( A )*B, or   B := alpha*B*op( A ) with triangular matrix A</td>
</tr>
<tr>
<td><img src="Modelica_LinearSystems2.M4b02aade559323aedtrmmS.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.dtrsm" width="20" height="20" align="top">&nbsp;<a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dtrsm"
>dtrsm</a>
</td>
<td>Solve one of the matrix equations  op( A )*X = alpha*B,   or   X*op( A ) = alpha*B, where A is triangular matrix. BLAS routine</td>
</tr>
<tr>
<td><img src="Modelica_LinearSystems2.M4b02aade559323aedtrmmS.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.drot" width="20" height="20" align="top">&nbsp;<a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.drot"
>drot</a>
</td>
<td>Applies a plane rotation</td>
</tr>
<tr>
<td><img src="Modelica_LinearSystems2.M4b02aade559323aedtrmmS.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.drotg" width="20" height="20" align="top">&nbsp;<a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.drotg"
>drotg</a>
</td>
<td>Construct Givens plane rotation</td>
</tr>
<tr>
<td><img src="Modelica_LinearSystems2.M4b02aade559323aedtrmmS.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.dtrsv" width="20" height="20" align="top">&nbsp;<a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dtrsv"
>dtrsv</a>
</td>
<td>Solve one of the matrix equations  op( A )*x = B where A is upper or lower triangular matrix. BLAS routine</td>
</tr>
<tr>
<td><img src="Modelica_LinearSystems2.M4a78ae7255915475dposvS.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.dposv" width="20" height="20" align="top">&nbsp;<a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dposv"
>dposv</a>
</td>
<td>Compute the solution to A * X = B, where A is a symmetric positive definite matrix</td>
</tr>
<tr>
<td><img src="Modelica_LinearSystems2.M1bbd109f322acde4poconS.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.dpocon" width="20" height="20" align="top">&nbsp;<a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dpocon"
>dpocon</a>
</td>
<td>Estimates the reciprocal of the condition number (1-norm) of a real symmetric matrix A using the Cholesky factor</td>
</tr>
<tr>
<td><img src="Modelica_LinearSystems2.M1bbd109f322acde4poconS.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgelqf" width="20" height="20" align="top">&nbsp;<a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dgelqf"
>dgelqf</a>
</td>
<td>Compute LQ factorization of a real matrix A=L*Q</td>
</tr>
<tr>
<td><img src="Modelica_LinearSystems2.M1bbd109f322acde4poconS.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.dorglq" width="20" height="20" align="top">&nbsp;<a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dorglq"
>dorglq</a>
</td>
<td>Generate a matrix Q with orthonormal rows which is defined as the product of elementary reflectors, as returned by DGELQF</td>
</tr>
<tr>
<td><img src="Modelica_LinearSystems2.M625f47d132641243trtriS.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.dtrtri" width="20" height="20" align="top">&nbsp;<a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK.dtrtri"
>dtrtri</a>
</td>
<td>Computes the inverse of a triangular real matrix A</td>
</tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgecon<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><a name="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgecon"></a><a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</a>.dgecon</h2>
<p>
<b>Estimates the reciprocal of the condition number of a general real matrix A</b>
</p>
<h3>Information</h3>
<pre>Lapack documentation:

   Purpose
   =======

   DGECON estimates the reciprocal of the condition number of a general
   real matrix A, in either the 1-norm or the infinity-norm, using
   the LU factorization computed by DGETRF.

   An estimate is obtained for norm(inv(A)), and the reciprocal of the
   condition number is computed as
      RCOND = 1 / ( norm(A) * norm(inv(A)) ).

   Arguments
   =========

   NORM    (input) CHARACTER*1
           Specifies whether the 1-norm condition number or the
           infinity-norm condition number is required:
           = &#39;1&#39; or &#39;O&#39;:  1-norm;
           = &#39;I&#39;:         Infinity-norm.

   N       (input) INTEGER
           The order of the matrix A.  N &gt;= 0.

   A       (input) DOUBLE PRECISION array, dimension (LDA,N)
           The factors L and U from the factorization A = P*L*U
           as computed by DGETRF.

   LDA     (input) INTEGER
           The leading dimension of the array A.  LDA &gt;= max(1,N).

   ANORM   (input) DOUBLE PRECISION
           If NORM = &#39;1&#39; or &#39;O&#39;, the 1-norm of the original matrix A.
           If NORM = &#39;I&#39;, the infinity-norm of the original matrix A.

   RCOND   (output) DOUBLE PRECISION
           The reciprocal of the condition number of the matrix A,
           computed as RCOND = 1/(norm(A) * norm(inv(A))).

   WORK    (workspace) DOUBLE PRECISION array, dimension (4*N)

   IWORK   (workspace) INTEGER array, dimension (N)

   INFO    (output) INTEGER
           = 0:  successful exit
           &lt; 0:  if INFO = -i, the i-th argument had an illegal value

   =====================================================================
</pre>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Inputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>LU_of_A[:, :]</td><td>LU factroization of a real matrix A</td></tr>
<tr><td>inf</td><td>Is true if infinity norm is used and false for 1-norm</td></tr>
<tr><td>anorm</td><td>norm of A</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Outputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>rcond</td><td>Reciprocal condition number of A</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgees<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><a name="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgees"></a><a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</a>.dgees</h2>
<p>
<b>Computes real Schur form T of  real nonsymmetric matrix A, and, optionally, the matrix of Schur vectors Z as well as the eigenvalues</b>
</p>
<h3>Information</h3>
<pre>Lapack documentation:

   Purpose
   =======

   DGEES computes for an N-by-N real nonsymmetric matrix A, the
   eigenvalues, the real Schur form T, and, optionally, the matrix of
   Schur vectors Z.  This gives the Schur factorization A = Z*T*(Z**T).

   Optionally, it also orders the eigenvalues on the diagonal of the
   real Schur form so that selected eigenvalues are at the top left.
   The leading columns of Z then form an orthonormal basis for the
   invariant subspace corresponding to the selected eigenvalues.

   A matrix is in real Schur form if it is upper quasi-triangular with
   1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in the
   form
           [  a  b  ]
           [  c  a  ]

   where b*c &lt; 0. The eigenvalues of such a block are a +- sqrt(bc).

   Arguments
   =========

   JOBVS   (input) CHARACTER*1
           = &#39;N&#39;: Schur vectors are not computed;
           = &#39;V&#39;: Schur vectors are computed.

   SORT    (input) CHARACTER*1
           Specifies whether or not to order the eigenvalues on the
           diagonal of the Schur form.
           = &#39;N&#39;: Eigenvalues are not ordered;
           = &#39;S&#39;: Eigenvalues are ordered (see SELECT).

   SELECT  (external procedure) LOGICAL FUNCTION of two DOUBLE PRECISION arguments
           SELECT must be declared EXTERNAL in the calling subroutine.
           If SORT = &#39;S&#39;, SELECT is used to select eigenvalues to sort
           to the top left of the Schur form.
           If SORT = &#39;N&#39;, SELECT is not referenced.
           An eigenvalue WR(j)+sqrt(-1)*WI(j) is selected if
           SELECT(WR(j),WI(j)) is true; i.e., if either one of a complex
           conjugate pair of eigenvalues is selected, then both complex
           eigenvalues are selected.
           Note that a selected complex eigenvalue may no longer
           satisfy SELECT(WR(j),WI(j)) = .TRUE. after ordering, since
           ordering may change the value of complex eigenvalues
           (especially if the eigenvalue is ill-conditioned); in this
           case INFO is set to N+2 (see INFO below).

   N       (input) INTEGER
           The order of the matrix A. N &gt;= 0.

   A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
           On entry, the N-by-N matrix A.
           On exit, A has been overwritten by its real Schur form T.

   LDA     (input) INTEGER
           The leading dimension of the array A.  LDA &gt;= max(1,N).

   SDIM    (output) INTEGER
           If SORT = &#39;N&#39;, SDIM = 0.
           If SORT = &#39;S&#39;, SDIM = number of eigenvalues (after sorting)
                          for which SELECT is true. (Complex conjugate
                          pairs for which SELECT is true for either
                          eigenvalue count as 2.)

   WR      (output) DOUBLE PRECISION array, dimension (N)
   WI      (output) DOUBLE PRECISION array, dimension (N)
           WR and WI contain the real and imaginary parts,
           respectively, of the computed eigenvalues in the same order
           that they appear on the diagonal of the output Schur form T.
           Complex conjugate pairs of eigenvalues will appear
           consecutively with the eigenvalue having the positive
           imaginary part first.

   VS      (output) DOUBLE PRECISION array, dimension (LDVS,N)
           If JOBVS = &#39;V&#39;, VS contains the orthogonal matrix Z of Schur
           vectors.
           If JOBVS = &#39;N&#39;, VS is not referenced.

   LDVS    (input) INTEGER
           The leading dimension of the array VS.  LDVS &gt;= 1; if
           JOBVS = &#39;V&#39;, LDVS &gt;= N.

   WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
           On exit, if INFO = 0, WORK(1) contains the optimal LWORK.

   LWORK   (input) INTEGER
           The dimension of the array WORK.  LWORK &gt;= max(1,3*N).
           For good performance, LWORK must generally be larger.

           If LWORK = -1, then a workspace query is assumed; the routine
           only calculates the optimal size of the WORK array, returns
           this value as the first entry of the WORK array, and no error
           message related to LWORK is issued by XERBLA.

   BWORK   (workspace) LOGICAL array, dimension (N)
           Not referenced if SORT = &#39;N&#39;.

   INFO    (output) INTEGER
           = 0: successful exit
           &lt; 0: if INFO = -i, the i-th argument had an illegal value.
           &gt; 0: if INFO = i, and i is
              &lt;= N: the QR algorithm failed to compute all the
                    eigenvalues; elements 1:ILO-1 and i+1:N of WR and WI
                    contain those eigenvalues which have converged; if
                    JOBVS = &#39;V&#39;, VS contains the matrix which reduces A
                    to its partially converged Schur form.
              = N+1: the eigenvalues could not be reordered because some
                    eigenvalues were too close to separate (the problem
                    is very ill-conditioned);
              = N+2: after reordering, roundoff changed values of some
                    complex eigenvalues so that leading eigenvalues in
                    the Schur form no longer satisfy SELECT=.TRUE.  This
                    could also be caused by underflow due to scaling.

   =====================================================================  </pre>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Inputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, size(A, 1)]</td><td>Square matrix</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Outputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>T[size(A, 1), size(A, 2)]</td><td>Real Schur form with A = Z*T*Z&#39;</td></tr>
<tr><td>Z[size(A, 1), size(A, 1)]</td><td>orthogonal matrix Z of Schur vectors</td></tr>
<tr><td>eval_real[size(A, 1)]</td><td>real part of the eigenvectors of A</td></tr>
<tr><td>eval_imag[size(A, 1)]</td><td>imaginary part of the eigenvectors of A</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgeev<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><a name="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgeev"></a><a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</a>.dgeev</h2>
<p>
<b>Compute the eigenvalues and the (real) left and right eigenvectors of matrix A</b>
</p>
<h3>Information</h3>
<pre>Lapack documentation:

   Purpose
   =======

   DGEEV computes for an N-by-N real nonsymmetric matrix A, the
   eigenvalues and, optionally, the left and/or right eigenvectors.

   The right eigenvector v(j) of A satisfies
                    A * v(j) = lambda(j) * v(j)
   where lambda(j) is its eigenvalue.
   The left eigenvector u(j) of A satisfies
                 u(j)**H * A = lambda(j) * u(j)**H
   where u(j)**H denotes the conjugate transpose of u(j).

   The computed eigenvectors are normalized to have Euclidean norm
   equal to 1 and largest component real.

   Arguments
   =========

   JOBVL   (input) CHARACTER*1
           = &#39;N&#39;: left eigenvectors of A are not computed;
           = &#39;V&#39;: left eigenvectors of A are computed.

   JOBVR   (input) CHARACTER*1
           = &#39;N&#39;: right eigenvectors of A are not computed;
           = &#39;V&#39;: right eigenvectors of A are computed.

   N       (input) INTEGER
           The order of the matrix A. N &gt;= 0.

   A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
           On entry, the N-by-N matrix A.
           On exit, A has been overwritten.

   LDA     (input) INTEGER
           The leading dimension of the array A.  LDA &gt;= max(1,N).

   WR      (output) DOUBLE PRECISION array, dimension (N)
   WI      (output) DOUBLE PRECISION array, dimension (N)
           WR and WI contain the real and imaginary parts,
           respectively, of the computed eigenvalues.  Complex
           conjugate pairs of eigenvalues appear consecutively
           with the eigenvalue having the positive imaginary part
           first.

   VL      (output) DOUBLE PRECISION array, dimension (LDVL,N)
           If JOBVL = &#39;V&#39;, the left eigenvectors u(j) are stored one
           after another in the columns of VL, in the same order
           as their eigenvalues.
           If JOBVL = &#39;N&#39;, VL is not referenced.
           If the j-th eigenvalue is real, then u(j) = VL(:,j),
           the j-th column of VL.
           If the j-th and (j+1)-st eigenvalues form a complex
           conjugate pair, then u(j) = VL(:,j) + i*VL(:,j+1) and
           u(j+1) = VL(:,j) - i*VL(:,j+1).

   LDVL    (input) INTEGER
           The leading dimension of the array VL.  LDVL &gt;= 1; if
           JOBVL = &#39;V&#39;, LDVL &gt;= N.

   VR      (output) DOUBLE PRECISION array, dimension (LDVR,N)
           If JOBVR = &#39;V&#39;, the right eigenvectors v(j) are stored one
           after another in the columns of VR, in the same order
           as their eigenvalues.
           If JOBVR = &#39;N&#39;, VR is not referenced.
           If the j-th eigenvalue is real, then v(j) = VR(:,j),
           the j-th column of VR.
           If the j-th and (j+1)-st eigenvalues form a complex
           conjugate pair, then v(j) = VR(:,j) + i*VR(:,j+1) and
           v(j+1) = VR(:,j) - i*VR(:,j+1).

   LDVR    (input) INTEGER
           The leading dimension of the array VR.  LDVR &gt;= 1; if
           JOBVR = &#39;V&#39;, LDVR &gt;= N.

   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

   LWORK   (input) INTEGER
           The dimension of the array WORK.  LWORK &gt;= max(1,3*N), and
           if JOBVL = &#39;V&#39; or JOBVR = &#39;V&#39;, LWORK &gt;= 4*N.  For good
           performance, LWORK must generally be larger.

           If LWORK = -1, then a workspace query is assumed; the routine
           only calculates the optimal size of the WORK array, returns
           this value as the first entry of the WORK array, and no error
           message related to LWORK is issued by XERBLA.

   INFO    (output) INTEGER
           = 0:  successful exit
           &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
           &gt; 0:  if INFO = i, the QR algorithm failed to compute all the
                 eigenvalues, and no eigenvectors have been computed;
                 elements i+1:N of WR and WI contain eigenvalues which
                 have converged.

   =====================================================================
</pre>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Inputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, size(A, 1)]</td><td>&nbsp;</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Outputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>alphaReal[size(A, 1)]</td><td>Real part of alpha (eigenvalue=(alphaReal+i*alphaImag))</td></tr>
<tr><td>alphaImag[size(A, 1)]</td><td>Imaginary part of alpha (eigenvalue=(alphaReal+i*alphaImag))</td></tr>
<tr><td>lEigenVectors[size(A, 1), size(A, 1)]</td><td>left eigenvectors of matrix A</td></tr>
<tr><td>rEigenVectors[size(A, 1), size(A, 1)]</td><td>right eigenvectors of matrix A</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgeevx<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><a name="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgeevx"></a><a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</a>.dgeevx</h2>
<p>
<b>Compute the eigenvalues and the (real) left and right eigenvectors of matrix A, using lapack routine dgeevx </b>
</p>
<h3>Information</h3>
<pre>Lapack documentation:

   Purpose
   =======

   DGEEVX computes for an N-by-N real nonsymmetric matrix A, the
   eigenvalues and, optionally, the left and/or right eigenvectors.

   Optionally also, it computes a balancing transformation to improve
   the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
   SCALE, and ABNRM), reciprocal condition numbers for the eigenvalues
   (RCONDE), and reciprocal condition numbers for the right
   eigenvectors (RCONDV).

   The right eigenvector v(j) of A satisfies
                    A * v(j) = lambda(j) * v(j)
   where lambda(j) is its eigenvalue.
   The left eigenvector u(j) of A satisfies
                 u(j)**H * A = lambda(j) * u(j)**H
   where u(j)**H denotes the conjugate transpose of u(j).

   The computed eigenvectors are normalized to have Euclidean norm
   equal to 1 and largest component real.

   Balancing a matrix means permuting the rows and columns to make it
   more nearly upper triangular, and applying a diagonal similarity
   transformation D * A * D**(-1), where D is a diagonal matrix, to
   make its rows and columns closer in norm and the condition numbers
   of its eigenvalues and eigenvectors smaller.  The computed
   reciprocal condition numbers correspond to the balanced matrix.
   Permuting rows and columns will not change the condition numbers
   (in exact arithmetic) but diagonal scaling will.  For further
   explanation of balancing, see section 4.10.2 of the LAPACK
   Users&#39; Guide.

   Arguments
   =========

   BALANC  (input) CHARACTER*1
           Indicates how the input matrix should be diagonally scaled
           and/or permuted to improve the conditioning of its
           eigenvalues.
           = &#39;N&#39;: Do not diagonally scale or permute;
           = &#39;P&#39;: Perform permutations to make the matrix more nearly
                  upper triangular. Do not diagonally scale;
           = &#39;S&#39;: Diagonally scale the matrix, i.e. replace A by
                  D*A*D**(-1), where D is a diagonal matrix chosen
                  to make the rows and columns of A more equal in
                  norm. Do not permute;
           = &#39;B&#39;: Both diagonally scale and permute A.

           Computed reciprocal condition numbers will be for the matrix
           after balancing and/or permuting. Permuting does not change
           condition numbers (in exact arithmetic), but balancing does.

   JOBVL   (input) CHARACTER*1
           = &#39;N&#39;: left eigenvectors of A are not computed;
           = &#39;V&#39;: left eigenvectors of A are computed.
           If SENSE = &#39;E&#39; or &#39;B&#39;, JOBVL must = &#39;V&#39;.

   JOBVR   (input) CHARACTER*1
           = &#39;N&#39;: right eigenvectors of A are not computed;
           = &#39;V&#39;: right eigenvectors of A are computed.
           If SENSE = &#39;E&#39; or &#39;B&#39;, JOBVR must = &#39;V&#39;.

   SENSE   (input) CHARACTER*1
           Determines which reciprocal condition numbers are computed.
           = &#39;N&#39;: None are computed;
           = &#39;E&#39;: Computed for eigenvalues only;
           = &#39;V&#39;: Computed for right eigenvectors only;
           = &#39;B&#39;: Computed for eigenvalues and right eigenvectors.

           If SENSE = &#39;E&#39; or &#39;B&#39;, both left and right eigenvectors
           must also be computed (JOBVL = &#39;V&#39; and JOBVR = &#39;V&#39;).

   N       (input) INTEGER
           The order of the matrix A. N &gt;= 0.

   A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
           On entry, the N-by-N matrix A.
           On exit, A has been overwritten.  If JOBVL = &#39;V&#39; or
           JOBVR = &#39;V&#39;, A contains the real Schur form of the balanced
           version of the input matrix A.

   LDA     (input) INTEGER
           The leading dimension of the array A.  LDA &gt;= max(1,N).

   WR      (output) DOUBLE PRECISION array, dimension (N)
   WI      (output) DOUBLE PRECISION array, dimension (N)
           WR and WI contain the real and imaginary parts,
           respectively, of the computed eigenvalues.  Complex
           conjugate pairs of eigenvalues will appear consecutively
           with the eigenvalue having the positive imaginary part
           first.

   VL      (output) DOUBLE PRECISION array, dimension (LDVL,N)
           If JOBVL = &#39;V&#39;, the left eigenvectors u(j) are stored one
           after another in the columns of VL, in the same order
           as their eigenvalues.
           If JOBVL = &#39;N&#39;, VL is not referenced.
           If the j-th eigenvalue is real, then u(j) = VL(:,j),
           the j-th column of VL.
           If the j-th and (j+1)-st eigenvalues form a complex
           conjugate pair, then u(j) = VL(:,j) + i*VL(:,j+1) and
           u(j+1) = VL(:,j) - i*VL(:,j+1).

   LDVL    (input) INTEGER
           The leading dimension of the array VL.  LDVL &gt;= 1; if
           JOBVL = &#39;V&#39;, LDVL &gt;= N.

   VR      (output) DOUBLE PRECISION array, dimension (LDVR,N)
           If JOBVR = &#39;V&#39;, the right eigenvectors v(j) are stored one
           after another in the columns of VR, in the same order
           as their eigenvalues.
           If JOBVR = &#39;N&#39;, VR is not referenced.
           If the j-th eigenvalue is real, then v(j) = VR(:,j),
           the j-th column of VR.
           If the j-th and (j+1)-st eigenvalues form a complex
           conjugate pair, then v(j) = VR(:,j) + i*VR(:,j+1) and
           v(j+1) = VR(:,j) - i*VR(:,j+1).

   LDVR    (input) INTEGER
           The leading dimension of the array VR.  LDVR &gt;= 1, and if
           JOBVR = &#39;V&#39;, LDVR &gt;= N.

   ILO,IHI (output) INTEGER
           ILO and IHI are integer values determined when A was
           balanced.  The balanced A(i,j) = 0 if I &gt; J and
           J = 1,...,ILO-1 or I = IHI+1,...,N.

   SCALE   (output) DOUBLE PRECISION array, dimension (N)
           Details of the permutations and scaling factors applied
           when balancing A.  If P(j) is the index of the row and column
           interchanged with row and column j, and D(j) is the scaling
           factor applied to row and column j, then
           SCALE(J) = P(J),    for J = 1,...,ILO-1
                    = D(J),    for J = ILO,...,IHI
                    = P(J)     for J = IHI+1,...,N.
           The order in which the interchanges are made is N to IHI+1,
           then 1 to ILO-1.

   ABNRM   (output) DOUBLE PRECISION
           The one-norm of the balanced matrix (the maximum
           of the sum of absolute values of elements of any column).

   RCONDE  (output) DOUBLE PRECISION array, dimension (N)
           RCONDE(j) is the reciprocal condition number of the j-th
           eigenvalue.

   RCONDV  (output) DOUBLE PRECISION array, dimension (N)
           RCONDV(j) is the reciprocal condition number of the j-th
           right eigenvector.

   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

   LWORK   (input) INTEGER
           The dimension of the array WORK.   If SENSE = &#39;N&#39; or &#39;E&#39;,
           LWORK &gt;= max(1,2*N), and if JOBVL = &#39;V&#39; or JOBVR = &#39;V&#39;,
           LWORK &gt;= 3*N.  If SENSE = &#39;V&#39; or &#39;B&#39;, LWORK &gt;= N*(N+6).
           For good performance, LWORK must generally be larger.

           If LWORK = -1, then a workspace query is assumed; the routine
           only calculates the optimal size of the WORK array, returns
           this value as the first entry of the WORK array, and no error
           message related to LWORK is issued by XERBLA.

   IWORK   (workspace) INTEGER array, dimension (2*N-2)
           If SENSE = &#39;N&#39; or &#39;E&#39;, not referenced.

   INFO    (output) INTEGER
           = 0:  successful exit
           &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
           &gt; 0:  if INFO = i, the QR algorithm failed to compute all the
                 eigenvalues, and no eigenvectors or condition numbers
                 have been computed; elements 1:ILO-1 and i+1:N of WR
                 and WI contain eigenvalues which have converged.

   =====================================================================
</pre>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Inputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, size(A, 1)]</td><td>&nbsp;</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Outputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>alphaReal[size(A, 1)]</td><td>Real part of alpha (eigenvalue=(alphaReal+i*alphaImag))</td></tr>
<tr><td>alphaImag[size(A, 1)]</td><td>Imaginary part of alpha (eigenvalue=(alphaReal+i*alphaImag))</td></tr>
<tr><td>lEigenVectors[size(A, 1), size(A, 1)]</td><td>left eigenvectors of matrix A</td></tr>
<tr><td>rEigenVectors[size(A, 1), size(A, 1)]</td><td>right eigenvectors of matrix A</td></tr>
<tr><td>AS[size(A, 1), size(A, 2)]</td><td>AS iss the real Schur form of the balanced version of the input matrix A</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgegv<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><a name="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgegv"></a><a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</a>.dgegv</h2>
<p>
<b>Compute generalized eigenvalues for a (A,B) system</b>
</p>
<h3>Information</h3>

<pre>
Lapack documentation:

   Purpose
   =======

   This routine is deprecated and has been replaced by routine DGGEV.

   DGEGV computes for a pair of n-by-n real nonsymmetric matrices A and
   B, the generalized eigenvalues (alphar +/- alphai*i, beta), and
   optionally, the left and/or right generalized eigenvectors (VL and
   VR).

   A generalized eigenvalue for a pair of matrices (A,B) is, roughly
   speaking, a scalar w or a ratio  alpha/beta = w, such that  A - w*B
   is singular.  It is usually represented as the pair (alpha,beta),
   as there is a reasonable interpretation for beta=0, and even for
   both being zero.  A good beginning reference is the book, "Matrix
   Computations", by G. Golub &amp; C. van Loan (Johns Hopkins U. Press)

   A right generalized eigenvector corresponding to a generalized
   eigenvalue  w  for a pair of matrices (A,B) is a vector  r  such
   that  (A - w B) r = 0 .  A left generalized eigenvector is a vector
   l such that l**H * (A - w B) = 0, where l**H is the
   conjugate-transpose of l.

   Note: this routine performs "full balancing" on A and B -- see
   "Further Details", below.

   Arguments
   =========

   JOBVL   (input) CHARACTER*1
           = 'N':  do not compute the left generalized eigenvectors;
           = 'V':  compute the left generalized eigenvectors.

   JOBVR   (input) CHARACTER*1
           = 'N':  do not compute the right generalized eigenvectors;
           = 'V':  compute the right generalized eigenvectors.

   N       (input) INTEGER
           The order of the matrices A, B, VL, and VR.  N &gt;= 0.

   A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)
           On entry, the first of the pair of matrices whose
           generalized eigenvalues and (optionally) generalized
           eigenvectors are to be computed.
           On exit, the contents will have been destroyed.  (For a
           description of the contents of A on exit, see "Further
           Details", below.)

   LDA     (input) INTEGER
           The leading dimension of A.  LDA &gt;= max(1,N).

   B       (input/output) DOUBLE PRECISION array, dimension (LDB, N)
           On entry, the second of the pair of matrices whose
           generalized eigenvalues and (optionally) generalized
           eigenvectors are to be computed.
           On exit, the contents will have been destroyed.  (For a
           description of the contents of B on exit, see "Further
           Details", below.)

   LDB     (input) INTEGER
           The leading dimension of B.  LDB &gt;= max(1,N).

   ALPHAR  (output) DOUBLE PRECISION array, dimension (N)
   ALPHAI  (output) DOUBLE PRECISION array, dimension (N)
   BETA    (output) DOUBLE PRECISION array, dimension (N)
           On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will
           be the generalized eigenvalues.  If ALPHAI(j) is zero, then
           the j-th eigenvalue is real; if positive, then the j-th and
           (j+1)-st eigenvalues are a complex conjugate pair, with
           ALPHAI(j+1) negative.

           Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
           may easily over- or underflow, and BETA(j) may even be zero.
           Thus, the user should avoid naively computing the ratio
           alpha/beta.  However, ALPHAR and ALPHAI will be always less
           than and usually comparable with norm(A) in magnitude, and
           BETA always less than and usually comparable with norm(B).

   VL      (output) DOUBLE PRECISION array, dimension (LDVL,N)
           If JOBVL = 'V', the left generalized eigenvectors.  (See
           "Purpose", above.)  Real eigenvectors take one column,
           complex take two columns, the first for the real part and
           the second for the imaginary part.  Complex eigenvectors
           correspond to an eigenvalue with positive imaginary part.
           Each eigenvector will be scaled so the largest component
           will have abs(real part) + abs(imag. part) = 1, *except*
           that for eigenvalues with alpha=beta=0, a zero vector will
           be returned as the corresponding eigenvector.
           Not referenced if JOBVL = 'N'.

   LDVL    (input) INTEGER
           The leading dimension of the matrix VL. LDVL &gt;= 1, and
           if JOBVL = 'V', LDVL &gt;= N.

   VR      (output) DOUBLE PRECISION array, dimension (LDVR,N)
           If JOBVR = 'V', the right generalized eigenvectors.  (See
           "Purpose", above.)  Real eigenvectors take one column,
           complex take two columns, the first for the real part and
           the second for the imaginary part.  Complex eigenvectors
           correspond to an eigenvalue with positive imaginary part.
           Each eigenvector will be scaled so the largest component
           will have abs(real part) + abs(imag. part) = 1, *except*
           that for eigenvalues with alpha=beta=0, a zero vector will
           be returned as the corresponding eigenvector.
           Not referenced if JOBVR = 'N'.

   LDVR    (input) INTEGER
           The leading dimension of the matrix VR. LDVR &gt;= 1, and
           if JOBVR = 'V', LDVR &gt;= N.

   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

   LWORK   (input) INTEGER
           The dimension of the array WORK.  LWORK &gt;= max(1,8*N).
           For good performance, LWORK must generally be larger.
           To compute the optimal value of LWORK, call ILAENV to get
           blocksizes (for DGEQRF, DORMQR, and DORGQR.)  Then compute:
           NB  -- MAX of the blocksizes for DGEQRF, DORMQR, and DORGQR;
           The optimal LWORK is:
               2*N + MAX( 6*N, N*(NB+1) ).

           If LWORK = -1, then a workspace query is assumed; the routine
           only calculates the optimal size of the WORK array, returns
           this value as the first entry of the WORK array, and no error
           message related to LWORK is issued by XERBLA.

   INFO    (output) INTEGER
           = 0:  successful exit
           &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
           = 1,...,N:
                 The QZ iteration failed.  No eigenvectors have been
                 calculated, but ALPHAR(j), ALPHAI(j), and BETA(j)
                 should be correct for j=INFO+1,...,N.
           &gt; N:  errors that usually indicate LAPACK problems:
                 =N+1: error return from DGGBAL
                 =N+2: error return from DGEQRF
                 =N+3: error return from DORMQR
                 =N+4: error return from DORGQR
                 =N+5: error return from DGGHRD
                 =N+6: error return from DHGEQZ (other than failed
                                                 iteration)
                 =N+7: error return from DTGEVC
                 =N+8: error return from DGGBAK (computing VL)
                 =N+9: error return from DGGBAK (computing VR)
                 =N+10: error return from DLASCL (various calls)

   Further Details
   ===============

   Balancing
   ---------

   This driver calls DGGBAL to both permute and scale rows and columns
   of A and B.  The permutations PL and PR are chosen so that PL*A*PR
   and PL*B*R will be upper triangular except for the diagonal blocks
   A(i:j,i:j) and B(i:j,i:j), with i and j as close together as
   possible.  The diagonal scaling matrices DL and DR are chosen so
   that the pair  DL*PL*A*PR*DR, DL*PL*B*PR*DR have elements close to
   one (except for the elements that start out zero.)

   After the eigenvalues and eigenvectors of the balanced matrices
   have been computed, DGGBAK transforms the eigenvectors back to what
   they would have been (in perfect arithmetic) if they had not been
   balanced.

   Contents of A and B on Exit
   -------- -- - --- - -- ----

   If any eigenvectors are computed (either JOBVL='V' or JOBVR='V' or
   both), then on exit the arrays A and B will contain the real Schur
   form[*] of the "balanced" versions of A and B.  If no eigenvectors
   are computed, then only the diagonal blocks will be correct.

   [*] See DHGEQZ, DGEGS, or read the book "Matrix Computations",
       by Golub &amp; van Loan, pub. by Johns Hopkins U. Press.

   =====================================================================
</pre>

<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Inputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, size(A, 1)]</td><td>&nbsp;</td></tr>
<tr><td>B[size(A, 1), size(A, 1)]</td><td>&nbsp;</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Outputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>alphaReal[size(A, 1)]</td><td>Real part of alpha (eigenvalue=(alphaReal+i*alphaImag)/beta)</td></tr>
<tr><td>alphaImag[size(A, 1)]</td><td>Imaginary part of alpha</td></tr>
<tr><td>beta[size(A, 1)]</td><td>Denominator of eigenvalue</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgehrd<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><a name="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgehrd"></a><a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</a>.dgehrd</h2>
<p>
<b>Reduces a real general matrix A to upper Hessenberg form H by an orthogonal similarity transformation:  Q&#39; * A * Q = H</b>
</p>
<h3>Information</h3>
<pre>Lapack documentation:

   Purpose
   =======

   DGEHRD reduces a real general matrix A to upper Hessenberg form H by
   an orthogonal similarity transformation:  Q&#39; * A * Q = H .

   Arguments
   =========

   N       (input) INTEGER
           The order of the matrix A.  N &gt;= 0.

   ILO     (input) INTEGER
   IHI     (input) INTEGER
           It is assumed that A is already upper triangular in rows
           and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
           set by a previous call to DGEBAL; otherwise they should be
           set to 1 and N respectively. See Further Details.
           1 &lt;= ILO &lt;= IHI &lt;= N, if N &gt; 0; ILO=1 and IHI=0, if N=0.

   A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
           On entry, the N-by-N general matrix to be reduced.
           On exit, the upper triangle and the first subdiagonal of A
           are overwritten with the upper Hessenberg matrix H, and the
           elements below the first subdiagonal, with the array TAU,
           represent the orthogonal matrix Q as a product of elementary
           reflectors. See Further Details.

   LDA     (input) INTEGER
           The leading dimension of the array A.  LDA &gt;= max(1,N).

   TAU     (output) DOUBLE PRECISION array, dimension (N-1)
           The scalar factors of the elementary reflectors (see Further
           Details). Elements 1:ILO-1 and IHI:N-1 of TAU are set to
           zero.

   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

   LWORK   (input) INTEGER
           The length of the array WORK.  LWORK &gt;= max(1,N).
           For optimum performance LWORK &gt;= N*NB, where NB is the
           optimal blocksize.

           If LWORK = -1, then a workspace query is assumed; the routine
           only calculates the optimal size of the WORK array, returns
           this value as the first entry of the WORK array, and no error
           message related to LWORK is issued by XERBLA.

   INFO    (output) INTEGER
           = 0:  successful exit
           &lt; 0:  if INFO = -i, the i-th argument had an illegal value.

   Further Details
   ===============

   The matrix Q is represented as a product of (ihi-ilo) elementary
   reflectors

      Q = H(ilo) H(ilo+1) . . . H(ihi-1).

   Each H(i) has the form

      H(i) = I - tau * v * v&#39;

   where tau is a real scalar, and v is a real vector with
   v(1:i) = 0, v(i+1) = 1 and v(ihi+1:n) = 0; v(i+2:ihi) is stored on
   exit in A(i+2:ihi,i), and tau in TAU(i).

   The contents of A are illustrated by the following example, with
   n = 7, ilo = 2 and ihi = 6:

   on entry,                        on exit,

   ( a   a   a   a   a   a   a )    (  a   a   h   h   h   h   a )
   (     a   a   a   a   a   a )    (      a   h   h   h   h   a )
   (     a   a   a   a   a   a )    (      h   h   h   h   h   h )
   (     a   a   a   a   a   a )    (      v2  h   h   h   h   h )
   (     a   a   a   a   a   a )    (      v2  v3  h   h   h   h )
   (     a   a   a   a   a   a )    (      v2  v3  v4  h   h   h )
   (                         a )    (                          a )

   where a denotes an element of the original matrix A, h denotes a
   modified element of the upper Hessenberg matrix H, and vi denotes an
   element of the vector defining H(i).

   =====================================================================
</pre>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Inputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, size(A, 2)]</td><td>&nbsp;</td></tr>
<tr><td>ilo</td><td>lowest index where the original matrix had been Hessenbergform</td></tr>
<tr><td>ihi</td><td>highest index where the original matrix had been Hessenbergform</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Outputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>Aout[size(A, 1), size(A, 2)]</td><td>contains the Hessenberg form in the upper triangle and the first subdiagonal and below the first subdiagonal it contains the elementary reflectors which represents (with array tau) as a product the orthogonal matrix Q</td></tr>
<tr><td>tau[max(size(A, 1), 1) - 1]</td><td>scalar factors of the elementary reflectors</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgeqp3<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><a name="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgeqp3"></a><a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</a>.dgeqp3</h2>
<p>
<b>Computes a QR factorization with column pivoting</b>
</p>
<h3>Information</h3>
<pre>Lapack documentation:

   Purpose
   =======

   DGEQP3 computes a QR factorization with column pivoting of a
   matrix A:  A*P = Q*R  using Level 3 BLAS.

   Arguments
   =========

   M       (input) INTEGER
           The number of rows of the matrix A. M &gt;= 0.

   N       (input) INTEGER
           The number of columns of the matrix A.  N &gt;= 0.

   A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
           On entry, the M-by-N matrix A.
           On exit, the upper triangle of the array contains the
           min(M,N)-by-N upper trapezoidal matrix R; the elements below
           the diagonal, together with the array TAU, represent the
           orthogonal matrix Q as a product of min(M,N) elementary
           reflectors.

   LDA     (input) INTEGER
           The leading dimension of the array A. LDA &gt;= max(1,M).

   JPVT    (input/output) INTEGER array, dimension (N)
           On entry, if JPVT(J).ne.0, the J-th column of A is permuted
           to the front of A*P (a leading column); if JPVT(J)=0,
           the J-th column of A is a free column.
           On exit, if JPVT(J)=K, then the J-th column of A*P was the
           the K-th column of A.

   TAU     (output) DOUBLE PRECISION array, dimension (min(M,N))
           The scalar factors of the elementary reflectors.

   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
           On exit, if INFO=0, WORK(1) returns the optimal LWORK.

   LWORK   (input) INTEGER
           The dimension of the array WORK. LWORK &gt;= 3*N+1.
           For optimal performance LWORK &gt;= 2*N+( N+1 )*NB, where NB
           is the optimal blocksize.

           If LWORK = -1, then a workspace query is assumed; the routine
           only calculates the optimal size of the WORK array, returns
           this value as the first entry of the WORK array, and no error
           message related to LWORK is issued by XERBLA.

   INFO    (output) INTEGER
           = 0: successful exit.
           &lt; 0: if INFO = -i, the i-th argument had an illegal value.

   Further Details
   ===============

   The matrix Q is represented as a product of elementary reflectors

      Q = H(1) H(2) . . . H(k), where k = min(m,n).

   Each H(i) has the form

      H(i) = I - tau * v * v&#39;

   where tau is a real/complex scalar, and v is a real/complex vector
   with v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in
   A(i+1:m,i), and tau in TAU(i).

   Based on contributions by
     G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain
     X. Sun, Computer Science Dept., Duke University, USA

   =====================================================================
</pre>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Inputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, :]</td><td>&nbsp;</td></tr>
<tr><td>lwork1</td><td>size of work array; should be optimized with Modelica_LinearSystems2.Math.Matrices.Internal.dgeqp3_workdim</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Outputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>Aout[size(A, 1), size(A, 2)]</td><td>the upper triangle of the array contains the upper trapezoidal matrix R; the elements below the diagonal, together with the array TAU, represent the orthogonal matrix Q as a product of elementary reflectors</td></tr>
<tr><td>jpvt[size(A, 2)]</td><td>pivoting indices</td></tr>
<tr><td>tau[min(size(A, 1), size(A, 2))]</td><td>scalar factors of the elementary reflectors</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
<tr><td>work[max(lwork1, 3*size(A, 2) + 1)]</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgeqrf<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><a name="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgeqrf"></a><a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</a>.dgeqrf</h2>
<p>
<b>Computes a QR factorization without pivoting</b>
</p>
<h3>Information</h3>
<pre>Lapack documentation:

   Purpose
   =======

   DGEQRF computes a QR factorization of a real M-by-N matrix A:
   A = Q * R.

   Arguments
   =========

   M       (input) INTEGER
           The number of rows of the matrix A.  M &gt;= 0.

   N       (input) INTEGER
           The number of columns of the matrix A.  N &gt;= 0.

   A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
           On entry, the M-by-N matrix A.
           On exit, the elements on and above the diagonal of the array
           contain the min(M,N)-by-N upper trapezoidal matrix R (R is
           upper triangular if m &gt;= n); the elements below the diagonal,
           with the array TAU, represent the orthogonal matrix Q as a
           product of min(m,n) elementary reflectors (see Further
           Details).

   LDA     (input) INTEGER
           The leading dimension of the array A.  LDA &gt;= max(1,M).

   TAU     (output) DOUBLE PRECISION array, dimension (min(M,N))
           The scalar factors of the elementary reflectors (see Further
           Details).

   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

   LWORK   (input) INTEGER
           The dimension of the array WORK.  LWORK &gt;= max(1,N).
           For optimum performance LWORK &gt;= N*NB, where NB is
           the optimal blocksize.

           If LWORK = -1, then a workspace query is assumed; the routine
           only calculates the optimal size of the WORK array, returns
           this value as the first entry of the WORK array, and no error
           message related to LWORK is issued by XERBLA.

   INFO    (output) INTEGER
           = 0:  successful exit
           &lt; 0:  if INFO = -i, the i-th argument had an illegal value

   Further Details
   ===============

   The matrix Q is represented as a product of elementary reflectors

      Q = H(1) H(2) . . . H(k), where k = min(m,n).

   Each H(i) has the form

      H(i) = I - tau * v * v&#39;

   where tau is a real scalar, and v is a real vector with
   v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i),
   and tau in TAU(i).

   =====================================================================  </pre>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Inputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, :]</td><td>&nbsp;</td></tr>
<tr><td>lwork1</td><td>size of work array; should be optimized with Modelica_LinearSystems2.Math.Matrices.Internal.dgeqp3_workdim</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Outputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>Aout[size(A, 1), size(A, 2)]</td><td>the upper triangle of the array contains the upper trapezoidal matrix R; the elements below the diagonal, together with the array TAU, represent the orthogonal matrix Q as a product of elementary reflectors</td></tr>
<tr><td>tau[min(size(A, 1), size(A, 2))]</td><td>scalar factors of the elementary reflectors</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
<tr><td>work[max(lwork1, 3*size(A, 2) + 1)]</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgesdd<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica_LinearSystems2.M7c6eca9d335f8c8egesddI.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgesdd" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgesdd"></a><a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</a>.dgesdd</h2>
<p>
<b>Determine singular value decomposition</b>
</p>
<h3>Information</h3>
<pre>Lapack documentation:

   Purpose
   =======

   DGESDD computes the singular value decomposition (SVD) of a real
   M-by-N matrix A, optionally computing the left and right singular
   vectors.  If singular vectors are desired, it uses a
   divide-and-conquer algorithm.

   The SVD is written

        A = U * SIGMA * transpose(V)

   where SIGMA is an M-by-N matrix which is zero except for its
   min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
   V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
   are the singular values of A; they are real and non-negative, and
   are returned in descending order.  The first min(m,n) columns of
   U and V are the left and right singular vectors of A.

   Note that the routine returns VT = V**T, not V.

   The divide and conquer algorithm makes very mild assumptions about
   floating point arithmetic. It will work on machines with a guard
   digit in add/subtract, or on those binary machines without guard
   digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
   Cray-2. It could conceivably fail on hexadecimal or decimal machines
   without guard digits, but we know of none.

   Arguments
   =========

   JOBZ    (input) CHARACTER*1
           Specifies options for computing all or part of the matrix U:
           = &#39;A&#39;:  all M columns of U and all N rows of V**T are
                   returned in the arrays U and VT;
           = &#39;S&#39;:  the first min(M,N) columns of U and the first
                   min(M,N) rows of V**T are returned in the arrays U
                   and VT;
           = &#39;O&#39;:  If M &gt;= N, the first N columns of U are overwritten
                   on the array A and all rows of V**T are returned in
                   the array VT;
                   otherwise, all columns of U are returned in the
                   array U and the first M rows of V**T are overwritten
                   in the array VT;
           = &#39;N&#39;:  no columns of U or rows of V**T are computed.

   M       (input) INTEGER
           The number of rows of the input matrix A.  M &gt;= 0.

   N       (input) INTEGER
           The number of columns of the input matrix A.  N &gt;= 0.

   A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
           On entry, the M-by-N matrix A.
           On exit,
           if JOBZ = &#39;O&#39;,  A is overwritten with the first N columns
                           of U (the left singular vectors, stored
                           columnwise) if M &gt;= N;
                           A is overwritten with the first M rows
                           of V**T (the right singular vectors, stored
                           rowwise) otherwise.
           if JOBZ .ne. &#39;O&#39;, the contents of A are destroyed.

   LDA     (input) INTEGER
           The leading dimension of the array A.  LDA &gt;= max(1,M).

   S       (output) DOUBLE PRECISION array, dimension (min(M,N))
           The singular values of A, sorted so that S(i) &gt;= S(i+1).

   U       (output) DOUBLE PRECISION array, dimension (LDU,UCOL)
           UCOL = M if JOBZ = &#39;A&#39; or JOBZ = &#39;O&#39; and M &lt; N;
           UCOL = min(M,N) if JOBZ = &#39;S&#39;.
           If JOBZ = &#39;A&#39; or JOBZ = &#39;O&#39; and M &lt; N, U contains the M-by-M
           orthogonal matrix U;
           if JOBZ = &#39;S&#39;, U contains the first min(M,N) columns of U
           (the left singular vectors, stored columnwise);
           if JOBZ = &#39;O&#39; and M &gt;= N, or JOBZ = &#39;N&#39;, U is not referenced.

   LDU     (input) INTEGER
           The leading dimension of the array U.  LDU &gt;= 1; if
           JOBZ = &#39;S&#39; or &#39;A&#39; or JOBZ = &#39;O&#39; and M &lt; N, LDU &gt;= M.

   VT      (output) DOUBLE PRECISION array, dimension (LDVT,N)
           If JOBZ = &#39;A&#39; or JOBZ = &#39;O&#39; and M &gt;= N, VT contains the
           N-by-N orthogonal matrix V**T;
           if JOBZ = &#39;S&#39;, VT contains the first min(M,N) rows of
           V**T (the right singular vectors, stored rowwise);
           if JOBZ = &#39;O&#39; and M &lt; N, or JOBZ = &#39;N&#39;, VT is not referenced.

   LDVT    (input) INTEGER
           The leading dimension of the array VT.  LDVT &gt;= 1; if
           JOBZ = &#39;A&#39; or JOBZ = &#39;O&#39; and M &gt;= N, LDVT &gt;= N;
           if JOBZ = &#39;S&#39;, LDVT &gt;= min(M,N).

   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK;

   LWORK   (input) INTEGER
           The dimension of the array WORK. LWORK &gt;= 1.
           If JOBZ = &#39;N&#39;,
             LWORK &gt;= 3*min(M,N) + max(max(M,N),6*min(M,N)).
           If JOBZ = &#39;O&#39;,
             LWORK &gt;= 3*min(M,N)*min(M,N) +
                      max(max(M,N),5*min(M,N)*min(M,N)+4*min(M,N)).
           If JOBZ = &#39;S&#39; or &#39;A&#39;
             LWORK &gt;= 3*min(M,N)*min(M,N) +
                      max(max(M,N),4*min(M,N)*min(M,N)+4*min(M,N)).
           For good performance, LWORK should generally be larger.
           If LWORK &lt; 0 but other input arguments are legal, WORK(1)
           returns the optimal LWORK.

   IWORK   (workspace) INTEGER array, dimension (8*min(M,N))

   INFO    (output) INTEGER
           = 0:  successful exit.
           &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
           &gt; 0:  DBDSDC did not converge, updating process failed.

   Further Details
   ===============

   Based on contributions by
      Ming Gu and Huan Ren, Computer Science Division, University of
      California at Berkeley, USA

   =====================================================================  </pre>
<p>Extends from Modelica.Icons.Function (Icon for functions).</p>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Inputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, :]</td><td>&nbsp;</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Outputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>sigma[min(size(A, 1), size(A, 2))]</td><td>&nbsp;</td></tr>
<tr><td>U[size(A, 1), size(A, 1)]</td><td>&nbsp;</td></tr>
<tr><td>VT[size(A, 2), size(A, 2)]</td><td>&nbsp;</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgesvd<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica_LinearSystems2.M7c6eca9d335f8c8egesddI.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgesvd" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgesvd"></a><a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</a>.dgesvd</h2>
<p>
<b>Determine singular value decomposition</b>
</p>
<h3>Information</h3>
<pre>Lapack documentation:

   Purpose
   =======

   DGESVD computes the singular value decomposition (SVD) of a real
   M-by-N matrix A, optionally computing the left and/or right singular

   vectors. The SVD is written
        A = U * SIGMA * transpose(V)
   where SIGMA is an M-by-N matrix which is zero except for its
   min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
   V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
   are the singular values of A; they are real and non-negative, and
   are returned in descending order.  The first min(m,n) columns of
   U and V are the left and right singular vectors of A.
   Note that the routine returns V**T, not V.

   Arguments
   =========

   JOBU    (input) CHARACTER*1
           Specifies options for computing all or part of the matrix U:

           = &#39;A&#39;:  all M columns of U are returned in array U:
           = &#39;S&#39;:  the first min(m,n) columns of U (the left singular
                   vectors) are returned in the array U;
           = &#39;O&#39;:  the first min(m,n) columns of U (the left singular
                   vectors) are overwritten on the array A;
           = &#39;N&#39;:  no columns of U (no left singular vectors) are
                   computed.
   JOBVT   (input) CHARACTER*1
           Specifies options for computing all or part of the matrix
           V**T:
           = &#39;A&#39;:  all N rows of V**T are returned in the array VT;
           = &#39;S&#39;:  the first min(m,n) rows of V**T (the right singular
                   vectors) are returned in the array VT;
           = &#39;O&#39;:  the first min(m,n) rows of V**T (the right singular
                   vectors) are overwritten on the array A;
           = &#39;N&#39;:  no rows of V**T (no right singular vectors) are
                   computed.
           JOBVT and JOBU cannot both be &#39;O&#39;.
   M       (input) INTEGER
           The number of rows of the input matrix A.  M &gt;= 0.
   N       (input) INTEGER
           The number of columns of the input matrix A.  N &gt;= 0.
   A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
           On entry, the M-by-N matrix A.
           On exit,
           if JOBU = &#39;O&#39;,  A is overwritten with the first min(m,n)
                           columns of U (the left singular vectors,
                           stored columnwise);
           if JOBVT = &#39;O&#39;, A is overwritten with the first min(m,n)
                           rows of V**T (the right singular vectors,
                           stored rowwise);
           if JOBU .ne. &#39;O&#39; and JOBVT .ne. &#39;O&#39;, the contents of A
                           are destroyed.
   LDA     (input) INTEGER
           The leading dimension of the array A.  LDA &gt;= max(1,M).
   S       (output) DOUBLE PRECISION array, dimension (min(M,N))
           The singular values of A, sorted so that S(i) &gt;= S(i+1).
   U       (output) DOUBLE PRECISION array, dimension (LDU,UCOL)
           (LDU,M) if JOBU = &#39;A&#39; or (LDU,min(M,N)) if JOBU = &#39;S&#39;.
           If JOBU = &#39;A&#39;, U contains the M-by-M orthogonal matrix U;
           if JOBU = &#39;S&#39;, U contains the first min(m,n) columns of U
           (the left singular vectors, stored columnwise);
           if JOBU = &#39;N&#39; or &#39;O&#39;, U is not referenced.
   LDU     (input) INTEGER
           The leading dimension of the array U.  LDU &gt;= 1; if
           JOBU = &#39;S&#39; or &#39;A&#39;, LDU &gt;= M.
   VT      (output) DOUBLE PRECISION array, dimension (LDVT,N)
           If JOBVT = &#39;A&#39;, VT contains the N-by-N orthogonal matrix
           V**T;
           if JOBVT = &#39;S&#39;, VT contains the first min(m,n) rows of
           V**T (the right singular vectors, stored rowwise);
           if JOBVT = &#39;N&#39; or &#39;O&#39;, VT is not referenced.
   LDVT    (input) INTEGER
           The leading dimension of the array VT.  LDVT &gt;= 1; if
           JOBVT = &#39;A&#39;, LDVT &gt;= N; if JOBVT = &#39;S&#39;, LDVT &gt;= min(M,N).
   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)

           On exit, if INFO = 0, WORK(1) returns the optimal LWORK;
           if INFO &gt; 0, WORK(2:MIN(M,N)) contains the unconverged
           superdiagonal elements of an upper bidiagonal matrix B
           whose diagonal is in S (not necessarily sorted). B
           satisfies A = U * B * VT, so it has the same singular values

           as A, and singular vectors related by U and VT.
   LWORK   (input) INTEGER
           The dimension of the array WORK. LWORK &gt;= 1.
           LWORK &gt;= MAX(3*MIN(M,N)+MAX(M,N),5*MIN(M,N)-4).
           For good performance, LWORK should generally be larger.
   INFO    (output) INTEGER
           = 0:  successful exit.
           &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
           &gt; 0:  if DBDSQR did not converge, INFO specifies how many
                 superdiagonals of an intermediate bidiagonal form B
                 did not converge to zero. See the description of WORK
                 above for details.

   =====================================================================  </pre>
<p>Extends from Modelica.Icons.Function (Icon for functions).</p>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Inputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, :]</td><td>&nbsp;</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Outputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>sigma[min(size(A, 1), size(A, 2))]</td><td>&nbsp;</td></tr>
<tr><td>U[size(A, 1), size(A, 1)]</td><td>&nbsp;</td></tr>
<tr><td>VT[size(A, 2), size(A, 2)]</td><td>&nbsp;</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgesvx<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica_LinearSystems2.M7c6eca9d335f8c8egesddI.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgesvx" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgesvx"></a><a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</a>.dgesvx</h2>
<p>
<b>Solve real system of linear equations op(A) * X = B, op(A) is A or A&#39; according to the boolean input transposed</b>
</p>
<h3>Information</h3>
<pre>Lapack documentation (April 2012):

   Purpose:
   ========

   DGESVX uses the LU factorization to compute the solution to a real
   system of linear equations
      A * X = B,
   where A is an N-by-N matrix and X and B are N-by-NRHS matrices.
  
   Error bounds on the solution and a condition estimate are also
   provided.

   Description:
   ============

   The following steps are performed:
  
   1. If FACT = &#39;E&#39;, real scaling factors are computed to equilibrate
      the system:
         TRANS = &#39;N&#39;:  diag(R)*A*diag(C)     *inv(diag(C))*X = diag(R)*B
         TRANS = &#39;T&#39;: (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B
         TRANS = &#39;C&#39;: (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B
      Whether or not the system will be equilibrated depends on the
      scaling of the matrix A, but if equilibration is used, A is
      overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS=&#39;N&#39;)
      or diag(C)*B (if TRANS = &#39;T&#39; or &#39;C&#39;).
  
   2. If FACT = &#39;N&#39; or &#39;E&#39;, the LU decomposition is used to factor the
      matrix A (after equilibration if FACT = &#39;E&#39;) as
         A = P * L * U,
      where P is a permutation matrix, L is a unit lower triangular
      matrix, and U is upper triangular.
  
   3. If some U(i,i)=0, so that U is exactly singular, then the routine
      returns with INFO = i. Otherwise, the factored form of A is used
      to estimate the condition number of the matrix A.  If the
      reciprocal of the condition number is less than machine precision,
      INFO = N+1 is returned as a warning, but the routine still goes on
      to solve for X and compute error bounds as described below.
  
   4. The system of equations is solved for X using the factored form
      of A.
  
   5. Iterative refinement is applied to improve the computed solution
      matrix and calculate error bounds and backward error estimates
      for it.
  
   6. If equilibration was used, the matrix X is premultiplied by
      diag(C) (if TRANS = &#39;N&#39;) or diag(R) (if TRANS = &#39;T&#39; or &#39;C&#39;) so
      that it solves the original system before equilibration.

   Arguments:
   ==========
  
   FACT   (input) CHARACTER*1
          Specifies whether or not the factored form of the matrix A is
          supplied on entry, and if not, whether the matrix A should be
          equilibrated before it is factored.
          = &#39;F&#39;:  On entry, AF and IPIV contain the factored form of A.
                  If EQUED is not &#39;N&#39;, the matrix A has been
                  equilibrated with scaling factors given by R and C.
                  A, AF, and IPIV are not modified.
          = &#39;N&#39;:  The matrix A will be copied to AF and factored.
          = &#39;E&#39;:  The matrix A will be equilibrated if necessary, then
                  copied to AF and factored.

   TRANS  (input) CHARACTER*1
          Specifies the form of the system of equations:
          = &#39;N&#39;:  A * X = B     (No transpose)
          = &#39;T&#39;:  A**T * X = B  (Transpose)
          = &#39;C&#39;:  A**H * X = B  (Transpose)

   N      (input) INTEGER
          The number of linear equations, i.e., the order of the
          matrix A.  N &gt;= 0.

   NRHS   (input) INTEGER
          The number of right hand sides, i.e., the number of columns
          of the matrices B and X.  NRHS &gt;= 0.

   A      (input, output) DOUBLE PRECISION array, dimension (LDA,N)
          On entry, the N-by-N matrix A.  If FACT = &#39;F&#39; and EQUED is
          not &#39;N&#39;, then A must have been equilibrated by the scaling
          factors in R and/or C.  A is not modified if FACT = &#39;F&#39; or
          &#39;N&#39;, or if FACT = &#39;E&#39; and EQUED = &#39;N&#39; on exit.

          On exit, if EQUED .ne. &#39;N&#39;, A is scaled as follows:
          EQUED = &#39;R&#39;:  A := diag(R) * A
          EQUED = &#39;C&#39;:  A := A * diag(C)
          EQUED = &#39;B&#39;:  A := diag(R) * A * diag(C).

   LDA    (input) INTEGER
          The leading dimension of the array A.  LDA &gt;= max(1,N).

   AF     (input, output) DOUBLE PRECISION array, dimension (LDAF,N)
          If FACT = &#39;F&#39;, then AF is an input argument and on entry
          contains the factors L and U from the factorization
          A = P*L*U as computed by DGETRF.  If EQUED .ne. &#39;N&#39;, then
          AF is the factored form of the equilibrated matrix A.

          If FACT = &#39;N&#39;, then AF is an output argument and on exit
          returns the factors L and U from the factorization A = P*L*U
          of the original matrix A.

          If FACT = &#39;E&#39;, then AF is an output argument and on exit
          returns the factors L and U from the factorization A = P*L*U
          of the equilibrated matrix A (see the description of A for
          the form of the equilibrated matrix).

   LDAF   (input) INTEGER
          The leading dimension of the array AF.  LDAF &gt;= max(1,N).

   IPIV   (input, output) INTEGER array, dimension (N)
          If FACT = &#39;F&#39;, then IPIV is an input argument and on entry
          contains the pivot indices from the factorization A = P*L*U
          as computed by DGETRF; row i of the matrix was interchanged
          with row IPIV(i).

          If FACT = &#39;N&#39;, then IPIV is an output argument and on exit
          contains the pivot indices from the factorization A = P*L*U
          of the original matrix A.

          If FACT = &#39;E&#39;, then IPIV is an output argument and on exit
          contains the pivot indices from the factorization A = P*L*U
          of the equilibrated matrix A.

   EQUED  (input, output) CHARACTER*1
          Specifies the form of equilibration that was done.
          = &#39;N&#39;:  No equilibration (always true if FACT = &#39;N&#39;).
          = &#39;R&#39;:  Row equilibration, i.e., A has been premultiplied by
                  diag(R).
          = &#39;C&#39;:  Column equilibration, i.e., A has been postmultiplied
                  by diag(C).
          = &#39;B&#39;:  Both row and column equilibration, i.e., A has been
                  replaced by diag(R) * A * diag(C).
          EQUED is an input argument if FACT = &#39;F&#39;; otherwise, it is an
          output argument.

   R      (input, output) DOUBLE PRECISION array, dimension (N)
          The row scale factors for A.  If EQUED = &#39;R&#39; or &#39;B&#39;, A is
          multiplied on the left by diag(R); if EQUED = &#39;N&#39; or &#39;C&#39;, R
          is not accessed.  R is an input argument if FACT = &#39;F&#39;;
          otherwise, R is an output argument.  If FACT = &#39;F&#39; and
          EQUED = &#39;R&#39; or &#39;B&#39;, each element of R must be positive.

   C      (input, output) DOUBLE PRECISION array, dimension (N)
          The column scale factors for A.  If EQUED = &#39;C&#39; or &#39;B&#39;, A is
          multiplied on the right by diag(C); if EQUED = &#39;N&#39; or &#39;R&#39;, C
          is not accessed.  C is an input argument if FACT = &#39;F&#39;;
          otherwise, C is an output argument.  If FACT = &#39;F&#39; and
          EQUED = &#39;C&#39; or &#39;B&#39;, each element of C must be positive.

   B      (input, output) DOUBLE PRECISION array, dimension (LDB,NRHS)
          On entry, the N-by-NRHS right hand side matrix B.
          On exit,
          if EQUED = &#39;N&#39;, B is not modified;
          if TRANS = &#39;N&#39; and EQUED = &#39;R&#39; or &#39;B&#39;, B is overwritten by
          diag(R)*B;
          if TRANS = &#39;T&#39; or &#39;C&#39; and EQUED = &#39;C&#39; or &#39;B&#39;, B is
          overwritten by diag(C)*B.

   LDB    (input) INTEGER
          The leading dimension of the array B.  LDB &gt;= max(1,N).

   X      (output) DOUBLE PRECISION array, dimension (LDX,NRHS)
          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X
          to the original system of equations.  Note that A and B are
          modified on exit if EQUED .ne. &#39;N&#39;, and the solution to the
          equilibrated system is inv(diag(C))*X if TRANS = &#39;N&#39; and
          EQUED = &#39;C&#39; or &#39;B&#39;, or inv(diag(R))*X if TRANS = &#39;T&#39; or &#39;C&#39;
          and EQUED = &#39;R&#39; or &#39;B&#39;.

   LDX    (input) INTEGER
          The leading dimension of the array X.  LDX &gt;= max(1,N).

   RCOND  (output) DOUBLE PRECISION
          The estimate of the reciprocal condition number of the matrix
          A after equilibration (if done).  If RCOND is less than the
          machine precision (in particular, if RCOND = 0), the matrix
          is singular to working precision.  This condition is
          indicated by a return code of INFO &gt; 0.

   FERR   (output) DOUBLE PRECISION array, dimension (NRHS)
          The estimated forward error bound for each solution vector
          X(j) (the j-th column of the solution matrix X).
          If XTRUE is the true solution corresponding to X(j), FERR(j)
          is an estimated upper bound for the magnitude of the largest
          element in (X(j) - XTRUE) divided by the magnitude of the
          largest element in X(j).  The estimate is as reliable as
          the estimate for RCOND, and is almost always a slight
          overestimate of the true error.

   BERR   (output) DOUBLE PRECISION array, dimension (NRHS)
          The componentwise relative backward error of each solution
          vector X(j) (i.e., the smallest relative change in
          any element of A or B that makes X(j) an exact solution).

   WORK   (output) DOUBLE PRECISION array, dimension (4*N)
          On exit, WORK(1) contains the reciprocal pivot growth
          factor norm(A)/norm(U). The &quot;max absolute element&quot; norm is
          used. If WORK(1) is much less than 1, then the stability
          of the LU factorization of the (equilibrated) matrix A
          could be poor. This also means that the solution X, condition
          estimator RCOND, and forward error bound FERR could be
          unreliable. If factorization fails with 0&lt;INFO&lt;=N, then
          WORK(1) contains the reciprocal pivot growth factor for the
          leading INFO columns of A.

   IWORK  (output) INTEGER array, dimension (N)

   INFO   (output) INTEGER
          = 0:  successful exit
          &lt; 0:  if INFO = -i, the i-th argument had an illegal value
          &gt; 0:  if INFO = i, and i is
                &lt;= N:  U(i,i) is exactly zero.  The factorization has
                       been completed, but the factor U is exactly
                       singular, so the solution and error bounds
                       could not be computed. RCOND = 0 is returned.
                = N+1: U is nonsingular, but RCOND is less than machine
                       precision, meaning that the matrix is singular
                       to working precision.  Nevertheless, the
                       solution and error bounds are computed because
                       there are a number of situations where the
                       computed solution can be more accurate than the
                       value of RCOND would suggest.

   =====================================================================  </pre>
<p>Extends from Modelica.Icons.Function (Icon for functions).</p>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Inputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, size(A, 1)]</td><td>Matrix A[n,n]</td></tr>
<tr><td>B[size(A, 1), :]</td><td>Matrix B[n,nrhs]</td></tr>
<tr><td>transposed</td><td>True, if matrix A is transformed on input, i.e. system is A**T * X = B</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Outputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>X[size(A, 1), size(B, 2)]</td><td>Matrix X[n,nrhs]</td></tr>
<tr><td>info</td><td>Info: =0: successful exit, otherwise see documentation</td></tr>
<tr><td>rcond</td><td>Estimate of the reciprocal condition number of the matrix A after equilibration</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgetrs<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><a name="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgetrs"></a><a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</a>.dgetrs</h2>
<p>
<b>Solves a system of linear equations with the LU decomposition from dgetrf(..)</b>
</p>
<h3>Information</h3>
<pre>Lapack documentation:

   Purpose
   =======

   DGETRS solves a system of linear equations
      A * X = B  or  A&#39; * X = B
   with a general N-by-N matrix A using the LU factorization computed
   by DGETRF.

   Arguments
   =========

   TRANS   (input) CHARACTER*1
           Specifies the form of the system of equations:
           = &#39;N&#39;:  A * X = B  (No transpose)
           = &#39;T&#39;:  A&#39;* X = B  (Transpose)
           = &#39;C&#39;:  A&#39;* X = B  (Conjugate transpose = Transpose)
   N       (input) INTEGER
           The order of the matrix A.  N &gt;= 0.
   NRHS    (input) INTEGER
           The number of right hand sides, i.e., the number of columns
           of the matrix B.  NRHS &gt;= 0.
   A       (input) DOUBLE PRECISION array, dimension (LDA,N)
           The factors L and U from the factorization A = P*L*U
           as computed by DGETRF.
   LDA     (input) INTEGER
           The leading dimension of the array A.  LDA &gt;= max(1,N).
   IPIV    (input) INTEGER array, dimension (N)
           The pivot indices from DGETRF; for 1&lt;=i&lt;=N, row i of the
           matrix was interchanged with row IPIV(i).
   B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
           On entry, the right hand side matrix B.
           On exit, the solution matrix X.
   LDB     (input) INTEGER
           The leading dimension of the array B.  LDB &gt;= max(1,N).
   INFO    (output) INTEGER
           = 0:  successful exit
           &lt; 0:  if INFO = -i, the i-th argument had an illegal value

   =====================================================================  </pre>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Inputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>LU[:, size(LU, 1)]</td><td>LU factorization of dgetrf of a square matrix</td></tr>
<tr><td>pivots[size(LU, 1)]</td><td>Pivot vector of dgetrf</td></tr>
<tr><td>B[size(LU, 1), :]</td><td>Right hand side matrix B</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Outputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>X[size(B, 1), size(B, 2)]</td><td>Solution matrix X</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dggev<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><a name="Modelica_LinearSystems2.Math.Matrices.LAPACK.dggev"></a><a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</a>.dggev</h2>
<p>
<b>Compute generalized eigenvalues for a (A,B) system</b>
</p>
<h3>Information</h3>
<pre>Lapack documentation:

   Purpose
   =======

   DGGEV computes for a pair of N-by-N real nonsymmetric matrices (A,B)
   the generalized eigenvalues, and optionally, the left and/or right
   generalized eigenvectors.

   A generalized eigenvalue for a pair of matrices (A,B) is a scalar
   lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
   singular. It is usually represented as the pair (alpha,beta), as
   there is a reasonable interpretation for beta=0, and even for both
   being zero.

   The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
   of (A,B) satisfies

                    A * v(j) = lambda(j) * B * v(j).

   The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
   of (A,B) satisfies

                    u(j)**H * A  = lambda(j) * u(j)**H * B .

   where u(j)**H is the conjugate-transpose of u(j).

   Arguments
   =========

   JOBVL   (input) CHARACTER*1
           = &#39;N&#39;:  do not compute the left generalized eigenvectors;
           = &#39;V&#39;:  compute the left generalized eigenvectors.

   JOBVR   (input) CHARACTER*1
           = &#39;N&#39;:  do not compute the right generalized eigenvectors;
           = &#39;V&#39;:  compute the right generalized eigenvectors.

   N       (input) INTEGER
           The order of the matrices A, B, VL, and VR.  N &gt;= 0.

   A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)
           On entry, the matrix A in the pair (A,B).
           On exit, A has been overwritten.

   LDA     (input) INTEGER
           The leading dimension of A.  LDA &gt;= max(1,N).

   B       (input/output) DOUBLE PRECISION array, dimension (LDB, N)
           On entry, the matrix B in the pair (A,B).
           On exit, B has been overwritten.

   LDB     (input) INTEGER
           The leading dimension of B.  LDB &gt;= max(1,N).

   ALPHAR  (output) DOUBLE PRECISION array, dimension (N)
   ALPHAI  (output) DOUBLE PRECISION array, dimension (N)
   BETA    (output) DOUBLE PRECISION array, dimension (N)
           On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will
           be the generalized eigenvalues.  If ALPHAI(j) is zero, then
           the j-th eigenvalue is real; if positive, then the j-th and
           (j+1)-st eigenvalues are a complex conjugate pair, with
           ALPHAI(j+1) negative.

           Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
           may easily over- or underflow, and BETA(j) may even be zero.
           Thus, the user should avoid naively computing the ratio
           alpha/beta.  However, ALPHAR and ALPHAI will be always less
           than and usually comparable with norm(A) in magnitude, and
           BETA always less than and usually comparable with norm(B).

   VL      (output) DOUBLE PRECISION array, dimension (LDVL,N)
           If JOBVL = &#39;V&#39;, the left eigenvectors u(j) are stored one
           after another in the columns of VL, in the same order as
           their eigenvalues. If the j-th eigenvalue is real, then
           u(j) = VL(:,j), the j-th column of VL. If the j-th and
           (j+1)-th eigenvalues form a complex conjugate pair, then
           u(j) = VL(:,j)+i*VL(:,j+1) and u(j+1) = VL(:,j)-i*VL(:,j+1).
           Each eigenvector will be scaled so the largest component have
           abs(real part)+abs(imag. part)=1.
           Not referenced if JOBVL = &#39;N&#39;.

   LDVL    (input) INTEGER
           The leading dimension of the matrix VL. LDVL &gt;= 1, and
           if JOBVL = &#39;V&#39;, LDVL &gt;= N.

   VR      (output) DOUBLE PRECISION array, dimension (LDVR,N)
           If JOBVR = &#39;V&#39;, the right eigenvectors v(j) are stored one
           after another in the columns of VR, in the same order as
           their eigenvalues. If the j-th eigenvalue is real, then
           v(j) = VR(:,j), the j-th column of VR. If the j-th and
           (j+1)-th eigenvalues form a complex conjugate pair, then
           v(j) = VR(:,j)+i*VR(:,j+1) and v(j+1) = VR(:,j)-i*VR(:,j+1).
           Each eigenvector will be scaled so the largest component have
           abs(real part)+abs(imag. part)=1.
           Not referenced if JOBVR = &#39;N&#39;.

   LDVR    (input) INTEGER
           The leading dimension of the matrix VR. LDVR &gt;= 1, and
           if JOBVR = &#39;V&#39;, LDVR &gt;= N.

   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

   LWORK   (input) INTEGER
           The dimension of the array WORK.  LWORK &gt;= max(1,8*N).
           For good performance, LWORK must generally be larger.

           If LWORK = -1, then a workspace query is assumed; the routine
           only calculates the optimal size of the WORK array, returns
           this value as the first entry of the WORK array, and no error
           message related to LWORK is issued by XERBLA.

   INFO    (output) INTEGER
           = 0:  successful exit
           &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
           = 1,...,N:
                 The QZ iteration failed.  No eigenvectors have been
                 calculated, but ALPHAR(j), ALPHAI(j), and BETA(j)
                 should be correct for j=INFO+1,...,N.
           &gt; N:  =N+1: other than QZ iteration failed in DHGEQZ.
                 =N+2: error return from DTGEVC.

   =====================================================================
</pre>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Inputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, size(A, 1)]</td><td>&nbsp;</td></tr>
<tr><td>B[size(A, 1), size(A, 1)]</td><td>&nbsp;</td></tr>
<tr><td>nA</td><td>&nbsp;</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Outputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>alphaReal[size(A, 1)]</td><td>Real part of alpha (eigenvalue=(alphaReal+i*alphaImag)/beta)</td></tr>
<tr><td>alphaImag[size(A, 1)]</td><td>Imaginary part of alpha</td></tr>
<tr><td>beta[size(A, 1)]</td><td>Denominator of eigenvalue</td></tr>
<tr><td>lEigenVectors[size(A, 1), size(A, 1)]</td><td>left eigenvectors of matrix A</td></tr>
<tr><td>rEigenVectors[size(A, 1), size(A, 1)]</td><td>right eigenvectors of matrix A</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dggevx<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><a name="Modelica_LinearSystems2.Math.Matrices.LAPACK.dggevx"></a><a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</a>.dggevx</h2>
<p>
<b>Compute generalized eigenvalues for a (A,B) system, using lapack routine dggevx</b>
</p>
<h3>Information</h3>
<pre>Lapack documentation:

   Purpose
   =======

   DGGEVX computes for a pair of N-by-N real nonsymmetric matrices (A,B)
   the generalized eigenvalues, and optionally, the left and/or right
   generalized eigenvectors.

   Optionally also, it computes a balancing transformation to improve
   the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
   LSCALE, RSCALE, ABNRM, and BBNRM), reciprocal condition numbers for
   the eigenvalues (RCONDE), and reciprocal condition numbers for the
   right eigenvectors (RCONDV).

   A generalized eigenvalue for a pair of matrices (A,B) is a scalar
   lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
   singular. It is usually represented as the pair (alpha,beta), as
   there is a reasonable interpretation for beta=0, and even for both
   being zero.

   The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
   of (A,B) satisfies

                    A * v(j) = lambda(j) * B * v(j) .

   The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
   of (A,B) satisfies

                    u(j)**H * A  = lambda(j) * u(j)**H * B.

   where u(j)**H is the conjugate-transpose of u(j).

   Arguments
   =========

   BALANC  (input) CHARACTER*1
           Specifies the balance option to be performed.
           = &#39;N&#39;:  do not diagonally scale or permute;
           = &#39;P&#39;:  permute only;
           = &#39;S&#39;:  scale only;
           = &#39;B&#39;:  both permute and scale.
           Computed reciprocal condition numbers will be for the
           matrices after permuting and/or balancing. Permuting does
           not change condition numbers (in exact arithmetic), but
           balancing does.

   JOBVL   (input) CHARACTER*1
           = &#39;N&#39;:  do not compute the left generalized eigenvectors;
           = &#39;V&#39;:  compute the left generalized eigenvectors.

   JOBVR   (input) CHARACTER*1
           = &#39;N&#39;:  do not compute the right generalized eigenvectors;
           = &#39;V&#39;:  compute the right generalized eigenvectors.

   SENSE   (input) CHARACTER*1
           Determines which reciprocal condition numbers are computed.
           = &#39;N&#39;: none are computed;
           = &#39;E&#39;: computed for eigenvalues only;
           = &#39;V&#39;: computed for eigenvectors only;
           = &#39;B&#39;: computed for eigenvalues and eigenvectors.

   N       (input) INTEGER
           The order of the matrices A, B, VL, and VR.  N &gt;= 0.

   A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)
           On entry, the matrix A in the pair (A,B).
           On exit, A has been overwritten. If JOBVL=&#39;V&#39; or JOBVR=&#39;V&#39;
           or both, then A contains the first part of the real Schur
           form of the &quot;balanced&quot; versions of the input A and B.

   LDA     (input) INTEGER
           The leading dimension of A.  LDA &gt;= max(1,N).

   B       (input/output) DOUBLE PRECISION array, dimension (LDB, N)
           On entry, the matrix B in the pair (A,B).
           On exit, B has been overwritten. If JOBVL=&#39;V&#39; or JOBVR=&#39;V&#39;
           or both, then B contains the second part of the real Schur
           form of the &quot;balanced&quot; versions of the input A and B.

   LDB     (input) INTEGER
           The leading dimension of B.  LDB &gt;= max(1,N).

   ALPHAR  (output) DOUBLE PRECISION array, dimension (N)
   ALPHAI  (output) DOUBLE PRECISION array, dimension (N)
   BETA    (output) DOUBLE PRECISION array, dimension (N)
           On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will
           be the generalized eigenvalues.  If ALPHAI(j) is zero, then
           the j-th eigenvalue is real; if positive, then the j-th and
           (j+1)-st eigenvalues are a complex conjugate pair, with
           ALPHAI(j+1) negative.

           Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
           may easily over- or underflow, and BETA(j) may even be zero.
           Thus, the user should avoid naively computing the ratio
           ALPHA/BETA. However, ALPHAR and ALPHAI will be always less
           than and usually comparable with norm(A) in magnitude, and
           BETA always less than and usually comparable with norm(B).

   VL      (output) DOUBLE PRECISION array, dimension (LDVL,N)
           If JOBVL = &#39;V&#39;, the left eigenvectors u(j) are stored one
           after another in the columns of VL, in the same order as
           their eigenvalues. If the j-th eigenvalue is real, then
           u(j) = VL(:,j), the j-th column of VL. If the j-th and
           (j+1)-th eigenvalues form a complex conjugate pair, then
           u(j) = VL(:,j)+i*VL(:,j+1) and u(j+1) = VL(:,j)-i*VL(:,j+1).
           Each eigenvector will be scaled so the largest component have
           abs(real part) + abs(imag. part) = 1.
           Not referenced if JOBVL = &#39;N&#39;.

   LDVL    (input) INTEGER
           The leading dimension of the matrix VL. LDVL &gt;= 1, and
           if JOBVL = &#39;V&#39;, LDVL &gt;= N.

   VR      (output) DOUBLE PRECISION array, dimension (LDVR,N)
           If JOBVR = &#39;V&#39;, the right eigenvectors v(j) are stored one
           after another in the columns of VR, in the same order as
           their eigenvalues. If the j-th eigenvalue is real, then
           v(j) = VR(:,j), the j-th column of VR. If the j-th and
           (j+1)-th eigenvalues form a complex conjugate pair, then
           v(j) = VR(:,j)+i*VR(:,j+1) and v(j+1) = VR(:,j)-i*VR(:,j+1).
           Each eigenvector will be scaled so the largest component have
           abs(real part) + abs(imag. part) = 1.
           Not referenced if JOBVR = &#39;N&#39;.

   LDVR    (input) INTEGER
           The leading dimension of the matrix VR. LDVR &gt;= 1, and
           if JOBVR = &#39;V&#39;, LDVR &gt;= N.

   ILO,IHI (output) INTEGER
           ILO and IHI are integer values such that on exit
           A(i,j) = 0 and B(i,j) = 0 if i &gt; j and
           j = 1,...,ILO-1 or i = IHI+1,...,N.
           If BALANC = &#39;N&#39; or &#39;S&#39;, ILO = 1 and IHI = N.

   LSCALE  (output) DOUBLE PRECISION array, dimension (N)
           Details of the permutations and scaling factors applied
           to the left side of A and B.  If PL(j) is the index of the
           row interchanged with row j, and DL(j) is the scaling
           factor applied to row j, then
             LSCALE(j) = PL(j)  for j = 1,...,ILO-1
                       = DL(j)  for j = ILO,...,IHI
                       = PL(j)  for j = IHI+1,...,N.
           The order in which the interchanges are made is N to IHI+1,
           then 1 to ILO-1.

   RSCALE  (output) DOUBLE PRECISION array, dimension (N)
           Details of the permutations and scaling factors applied
           to the right side of A and B.  If PR(j) is the index of the
           column interchanged with column j, and DR(j) is the scaling
           factor applied to column j, then
             RSCALE(j) = PR(j)  for j = 1,...,ILO-1
                       = DR(j)  for j = ILO,...,IHI
                       = PR(j)  for j = IHI+1,...,N
           The order in which the interchanges are made is N to IHI+1,
           then 1 to ILO-1.

   ABNRM   (output) DOUBLE PRECISION
           The one-norm of the balanced matrix A.

   BBNRM   (output) DOUBLE PRECISION
           The one-norm of the balanced matrix B.

   RCONDE  (output) DOUBLE PRECISION array, dimension (N)
           If SENSE = &#39;E&#39; or &#39;B&#39;, the reciprocal condition numbers of
           the selected eigenvalues, stored in consecutive elements of
           the array. For a complex conjugate pair of eigenvalues two
           consecutive elements of RCONDE are set to the same value.
           Thus RCONDE(j), RCONDV(j), and the j-th columns of VL and VR
           all correspond to the same eigenpair (but not in general the
           j-th eigenpair, unless all eigenpairs are selected).
           If SENSE = &#39;V&#39;, RCONDE is not referenced.

   RCONDV  (output) DOUBLE PRECISION array, dimension (N)
           If SENSE = &#39;V&#39; or &#39;B&#39;, the estimated reciprocal condition
           numbers of the selected eigenvectors, stored in consecutive
           elements of the array. For a complex eigenvector two
           consecutive elements of RCONDV are set to the same value. If
           the eigenvalues cannot be reordered to compute RCONDV(j),
           RCONDV(j) is set to 0; this can only occur when the true
           value would be very small anyway.
           If SENSE = &#39;E&#39;, RCONDV is not referenced.

   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

   LWORK   (input) INTEGER
           The dimension of the array WORK. LWORK &gt;= max(1,6*N).
           If SENSE = &#39;E&#39;, LWORK &gt;= 12*N.
           If SENSE = &#39;V&#39; or &#39;B&#39;, LWORK &gt;= 2*N*N+12*N+16.

           If LWORK = -1, then a workspace query is assumed; the routine
           only calculates the optimal size of the WORK array, returns
           this value as the first entry of the WORK array, and no error
           message related to LWORK is issued by XERBLA.

   IWORK   (workspace) INTEGER array, dimension (N+6)
           If SENSE = &#39;E&#39;, IWORK is not referenced.

   BWORK   (workspace) LOGICAL array, dimension (N)
           If SENSE = &#39;N&#39;, BWORK is not referenced.

   INFO    (output) INTEGER
           = 0:  successful exit
           &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
           = 1,...,N:
                 The QZ iteration failed.  No eigenvectors have been
                 calculated, but ALPHAR(j), ALPHAI(j), and BETA(j)
                 should be correct for j=INFO+1,...,N.
           &gt; N:  =N+1: other than QZ iteration failed in DHGEQZ.
                 =N+2: error return from DTGEVC.

   Further Details
   ===============

   Balancing a matrix pair (A,B) includes, first, permuting rows and
   columns to isolate eigenvalues, second, applying diagonal similarity
   transformation to the rows and columns to make the rows and columns
   as close in norm as possible. The computed reciprocal condition
   numbers correspond to the balanced matrix. Permuting rows and columns
   will not change the condition numbers (in exact arithmetic) but
   diagonal scaling will.  For further explanation of balancing, see
   section 4.11.1.2 of LAPACK Users&#39; Guide.

   An approximate error bound on the chordal distance between the i-th
   computed generalized eigenvalue w and the corresponding exact
   eigenvalue lambda is

        chord(w, lambda) &lt;= EPS * norm(ABNRM, BBNRM) / RCONDE(I)

   An approximate error bound for the angle between the i-th computed
   eigenvector VL(i) or VR(i) is given by

        EPS * norm(ABNRM, BBNRM) / DIF(i).

   For further explanation of the reciprocal condition numbers RCONDE
   and RCONDV, see section 4.11 of LAPACK User&#39;s Guide.

   =====================================================================
</pre>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Inputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, size(A, 1)]</td><td>&nbsp;</td></tr>
<tr><td>B[size(A, 1), size(A, 1)]</td><td>&nbsp;</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Outputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>alphaReal[size(A, 1)]</td><td>Real part of alpha (eigenvalue=(alphaReal+i*alphaImag)/beta)</td></tr>
<tr><td>alphaImag[size(A, 1)]</td><td>Imaginary part of alpha</td></tr>
<tr><td>beta[size(A, 1)]</td><td>Denominator of eigenvalue</td></tr>
<tr><td>lEigenVectors[size(A, 1), size(A, 1)]</td><td>left eigenvectors of matrix A</td></tr>
<tr><td>rEigenVectors[size(A, 1), size(A, 1)]</td><td>right eigenvectors of matrix A</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dhgeqz<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><a name="Modelica_LinearSystems2.Math.Matrices.LAPACK.dhgeqz"></a><a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</a>.dhgeqz</h2>
<p>
<b>Compute generalized eigenvalues for a (A,B) system</b>
</p>
<h3>Information</h3>
<pre>Lapack documentation:

   Purpose
   =======

   DHGEQZ implements a single-/double-shift version of the QZ method for
   finding the generalized eigenvalues

   w(j)=(ALPHAR(j) + i*ALPHAI(j))/BETAR(j)   of the equation

        det( A - w(i) B ) = 0

   In addition, the pair A,B may be reduced to generalized Schur form:
   B is upper triangular, and A is block upper triangular, where the
   diagonal blocks are either 1-by-1 or 2-by-2, the 2-by-2 blocks having
   complex generalized eigenvalues (see the description of the argument
   JOB.)

   If JOB=&#39;S&#39;, then the pair (A,B) is simultaneously reduced to Schur
   form by applying one orthogonal tranformation (usually called Q) on
   the left and another (usually called Z) on the right.  The 2-by-2
   upper-triangular diagonal blocks of B corresponding to 2-by-2 blocks
   of A will be reduced to positive diagonal matrices.  (I.e.,
   if A(j+1,j) is non-zero, then B(j+1,j)=B(j,j+1)=0 and B(j,j) and
   B(j+1,j+1) will be positive.)

   If JOB=&#39;E&#39;, then at each iteration, the same transformations
   are computed, but they are only applied to those parts of A and B
   which are needed to compute ALPHAR, ALPHAI, and BETAR.

   If JOB=&#39;S&#39; and COMPQ and COMPZ are &#39;V&#39; or &#39;I&#39;, then the orthogonal
   transformations used to reduce (A,B) are accumulated into the arrays
   Q and Z s.t.:

        Q(in) A(in) Z(in)* = Q(out) A(out) Z(out)*
        Q(in) B(in) Z(in)* = Q(out) B(out) Z(out)*

   Ref: C.B. Moler &amp; G.W. Stewart, &quot;An Algorithm for Generalized Matrix
        Eigenvalue Problems&quot;, SIAM J. Numer. Anal., 10(1973),
        pp. 241--256.

   Arguments
   =========

   JOB     (input) CHARACTER*1
           = &#39;E&#39;: compute only ALPHAR, ALPHAI, and BETA.  A and B will
                  not necessarily be put into generalized Schur form.
           = &#39;S&#39;: put A and B into generalized Schur form, as well
                  as computing ALPHAR, ALPHAI, and BETA.

   COMPQ   (input) CHARACTER*1
           = &#39;N&#39;: do not modify Q.
           = &#39;V&#39;: multiply the array Q on the right by the transpose of
                  the orthogonal tranformation that is applied to the
                  left side of A and B to reduce them to Schur form.
           = &#39;I&#39;: like COMPQ=&#39;V&#39;, except that Q will be initialized to
                  the identity first.

   COMPZ   (input) CHARACTER*1
           = &#39;N&#39;: do not modify Z.
           = &#39;V&#39;: multiply the array Z on the right by the orthogonal
                  tranformation that is applied to the right side of
                  A and B to reduce them to Schur form.
           = &#39;I&#39;: like COMPZ=&#39;V&#39;, except that Z will be initialized to
                  the identity first.

   N       (input) INTEGER
           The order of the matrices A, B, Q, and Z.  N &gt;= 0.

   ILO     (input) INTEGER
   IHI     (input) INTEGER
           It is assumed that A is already upper triangular in rows and
           columns 1:ILO-1 and IHI+1:N.
           1 &lt;= ILO &lt;= IHI &lt;= N, if N &gt; 0; ILO=1 and IHI=0, if N=0.

   A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)
           On entry, the N-by-N upper Hessenberg matrix A.  Elements
           below the subdiagonal must be zero.
           If JOB=&#39;S&#39;, then on exit A and B will have been
              simultaneously reduced to generalized Schur form.
           If JOB=&#39;E&#39;, then on exit A will have been destroyed.
              The diagonal blocks will be correct, but the off-diagonal
              portion will be meaningless.

   LDA     (input) INTEGER
           The leading dimension of the array A.  LDA &gt;= max( 1, N ).

   B       (input/output) DOUBLE PRECISION array, dimension (LDB, N)
           On entry, the N-by-N upper triangular matrix B.  Elements
           below the diagonal must be zero.  2-by-2 blocks in B
           corresponding to 2-by-2 blocks in A will be reduced to
           positive diagonal form.  (I.e., if A(j+1,j) is non-zero,
           then B(j+1,j)=B(j,j+1)=0 and B(j,j) and B(j+1,j+1) will be
           positive.)
           If JOB=&#39;S&#39;, then on exit A and B will have been
              simultaneously reduced to Schur form.
           If JOB=&#39;E&#39;, then on exit B will have been destroyed.
              Elements corresponding to diagonal blocks of A will be
              correct, but the off-diagonal portion will be meaningless.

   LDB     (input) INTEGER
           The leading dimension of the array B.  LDB &gt;= max( 1, N ).

   ALPHAR  (output) DOUBLE PRECISION array, dimension (N)
           ALPHAR(1:N) will be set to real parts of the diagonal
           elements of A that would result from reducing A and B to
           Schur form and then further reducing them both to triangular
           form using unitary transformations s.t. the diagonal of B
           was non-negative real.  Thus, if A(j,j) is in a 1-by-1 block
           (i.e., A(j+1,j)=A(j,j+1)=0), then ALPHAR(j)=A(j,j).
           Note that the (real or complex) values
           (ALPHAR(j) + i*ALPHAI(j))/BETA(j), j=1,...,N, are the
           generalized eigenvalues of the matrix pencil A - wB.

   ALPHAI  (output) DOUBLE PRECISION array, dimension (N)
           ALPHAI(1:N) will be set to imaginary parts of the diagonal
           elements of A that would result from reducing A and B to
           Schur form and then further reducing them both to triangular
           form using unitary transformations s.t. the diagonal of B
           was non-negative real.  Thus, if A(j,j) is in a 1-by-1 block
           (i.e., A(j+1,j)=A(j,j+1)=0), then ALPHAR(j)=0.
           Note that the (real or complex) values
           (ALPHAR(j) + i*ALPHAI(j))/BETA(j), j=1,...,N, are the
           generalized eigenvalues of the matrix pencil A - wB.

   BETA    (output) DOUBLE PRECISION array, dimension (N)
           BETA(1:N) will be set to the (real) diagonal elements of B
           that would result from reducing A and B to Schur form and
           then further reducing them both to triangular form using
           unitary transformations s.t. the diagonal of B was
           non-negative real.  Thus, if A(j,j) is in a 1-by-1 block
           (i.e., A(j+1,j)=A(j,j+1)=0), then BETA(j)=B(j,j).
           Note that the (real or complex) values
           (ALPHAR(j) + i*ALPHAI(j))/BETA(j), j=1,...,N, are the
           generalized eigenvalues of the matrix pencil A - wB.
           (Note that BETA(1:N) will always be non-negative, and no
           BETAI is necessary.)

   Q       (input/output) DOUBLE PRECISION array, dimension (LDQ, N)
           If COMPQ=&#39;N&#39;, then Q will not be referenced.
           If COMPQ=&#39;V&#39; or &#39;I&#39;, then the transpose of the orthogonal
              transformations which are applied to A and B on the left
              will be applied to the array Q on the right.

   LDQ     (input) INTEGER
           The leading dimension of the array Q.  LDQ &gt;= 1.
           If COMPQ=&#39;V&#39; or &#39;I&#39;, then LDQ &gt;= N.

   Z       (input/output) DOUBLE PRECISION array, dimension (LDZ, N)
           If COMPZ=&#39;N&#39;, then Z will not be referenced.
           If COMPZ=&#39;V&#39; or &#39;I&#39;, then the orthogonal transformations
              which are applied to A and B on the right will be applied
              to the array Z on the right.

   LDZ     (input) INTEGER
           The leading dimension of the array Z.  LDZ &gt;= 1.
           If COMPZ=&#39;V&#39; or &#39;I&#39;, then LDZ &gt;= N.

   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
           On exit, if INFO &gt;= 0, WORK(1) returns the optimal LWORK.

   LWORK   (input) INTEGER
           The dimension of the array WORK.  LWORK &gt;= max(1,N).

           If LWORK = -1, then a workspace query is assumed; the routine
           only calculates the optimal size of the WORK array, returns
           this value as the first entry of the WORK array, and no error
           message related to LWORK is issued by XERBLA.

   INFO    (output) INTEGER
           = 0: successful exit
           &lt; 0: if INFO = -i, the i-th argument had an illegal value
           = 1,...,N: the QZ iteration did not converge.  (A,B) is not
                      in Schur form, but ALPHAR(i), ALPHAI(i), and
                      BETA(i), i=INFO+1,...,N should be correct.
           = N+1,...,2*N: the shift calculation failed.  (A,B) is not
                      in Schur form, but ALPHAR(i), ALPHAI(i), and
                      BETA(i), i=INFO-N+1,...,N should be correct.
           &gt; 2*N:     various &quot;impossible&quot; errors.

   Further Details
   ===============

   Iteration counters:

   JITER  -- counts iterations.
   IITER  -- counts iterations run since ILAST was last
             changed.  This is therefore reset only when a 1-by-1 or
             2-by-2 block deflates off the bottom.

   =====================================================================
</pre>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Inputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, size(A, 1)]</td><td>&nbsp;</td></tr>
<tr><td>B[size(A, 1), size(A, 1)]</td><td>&nbsp;</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Outputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>alphaReal[size(A, 1)]</td><td>Real part of alpha (eigenvalue=(alphaReal+i*alphaImag)/beta)</td></tr>
<tr><td>alphaImag[size(A, 1)]</td><td>Imaginary part of alpha</td></tr>
<tr><td>beta[size(A, 1)]</td><td>Denominator of eigenvalue</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dhseqr<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><a name="Modelica_LinearSystems2.Math.Matrices.LAPACK.dhseqr"></a><a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</a>.dhseqr</h2>
<p>
<b>Compute eingenvalues of a matrix A using lapack routine DHSEQR for Hessenberg form matrix</b>
</p>
<h3>Information</h3>
<pre>Lapack documentation:

   Purpose
   =======

   DHSEQR computes the eigenvalues of a real upper Hessenberg matrix H
   and, optionally, the matrices T and Z from the Schur decomposition
   H = Z T Z**T, where T is an upper quasi-triangular matrix (the Schur
   form), and Z is the orthogonal matrix of Schur vectors.

   Optionally Z may be postmultiplied into an input orthogonal matrix Q,
   so that this routine can give the Schur factorization of a matrix A
   which has been reduced to the Hessenberg form H by the orthogonal
   matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.

   Arguments
   =========

   JOB     (input) CHARACTER*1
           = &#39;E&#39;:  compute eigenvalues only;
           = &#39;S&#39;:  compute eigenvalues and the Schur form T.

   COMPZ   (input) CHARACTER*1
           = &#39;N&#39;:  no Schur vectors are computed;
           = &#39;I&#39;:  Z is initialized to the unit matrix and the matrix Z
                   of Schur vectors of H is returned;
           = &#39;V&#39;:  Z must contain an orthogonal matrix Q on entry, and
                   the product Q*Z is returned.

   N       (input) INTEGER
           The order of the matrix H.  N &gt;= 0.

   ILO     (input) INTEGER
   IHI     (input) INTEGER
           It is assumed that H is already upper triangular in rows
           and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
           set by a previous call to DGEBAL, and then passed to SGEHRD
           when the matrix output by DGEBAL is reduced to Hessenberg
           form. Otherwise ILO and IHI should be set to 1 and N
           respectively.
           1 &lt;= ILO &lt;= IHI &lt;= N, if N &gt; 0; ILO=1 and IHI=0, if N=0.

   H       (input/output) DOUBLE PRECISION array, dimension (LDH,N)
           On entry, the upper Hessenberg matrix H.
           On exit, if JOB = &#39;S&#39;, H contains the upper quasi-triangular
           matrix T from the Schur decomposition (the Schur form);
           2-by-2 diagonal blocks (corresponding to complex conjugate
           pairs of eigenvalues) are returned in standard form, with
           H(i,i) = H(i+1,i+1) and H(i+1,i)*H(i,i+1) &lt; 0. If JOB = &#39;E&#39;,
           the contents of H are unspecified on exit.

   LDH     (input) INTEGER
           The leading dimension of the array H. LDH &gt;= max(1,N).

   WR      (output) DOUBLE PRECISION array, dimension (N)
   WI      (output) DOUBLE PRECISION array, dimension (N)
           The real and imaginary parts, respectively, of the computed
           eigenvalues. If two eigenvalues are computed as a complex
           conjugate pair, they are stored in consecutive elements of
           WR and WI, say the i-th and (i+1)th, with WI(i) &gt; 0 and
           WI(i+1) &lt; 0. If JOB = &#39;S&#39;, the eigenvalues are stored in the
           same order as on the diagonal of the Schur form returned in
           H, with WR(i) = H(i,i) and, if H(i:i+1,i:i+1) is a 2-by-2
           diagonal block, WI(i) = sqrt(H(i+1,i)*H(i,i+1)) and
           WI(i+1) = -WI(i).

   Z       (input/output) DOUBLE PRECISION array, dimension (LDZ,N)
           If COMPZ = &#39;N&#39;: Z is not referenced.
           If COMPZ = &#39;I&#39;: on entry, Z need not be set, and on exit, Z
           contains the orthogonal matrix Z of the Schur vectors of H.
           If COMPZ = &#39;V&#39;: on entry Z must contain an N-by-N matrix Q,
           which is assumed to be equal to the unit matrix except for
           the submatrix Z(ILO:IHI,ILO:IHI); on exit Z contains Q*Z.
           Normally Q is the orthogonal matrix generated by DORGHR after
           the call to DGEHRD which formed the Hessenberg matrix H.

   LDZ     (input) INTEGER
           The leading dimension of the array Z.
           LDZ &gt;= max(1,N) if COMPZ = &#39;I&#39; or &#39;V&#39;; LDZ &gt;= 1 otherwise.

   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

   LWORK   (input) INTEGER
           The dimension of the array WORK.  LWORK &gt;= max(1,N).

           If LWORK = -1, then a workspace query is assumed; the routine
           only calculates the optimal size of the WORK array, returns
           this value as the first entry of the WORK array, and no error
           message related to LWORK is issued by XERBLA.

   INFO    (output) INTEGER
           = 0:  successful exit
           &lt; 0:  if INFO = -i, the i-th argument had an illegal value
           &gt; 0:  if INFO = i, DHSEQR failed to compute all of the
                 eigenvalues in a total of 30*(IHI-ILO+1) iterations;
                 elements 1:ilo-1 and i+1:n of WR and WI contain those
                 eigenvalues which have been successfully computed.

   =====================================================================  </pre>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Inputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>H[:, size(H, 1)]</td><td>&nbsp;</td></tr>
<tr><td>lwork</td><td>&nbsp;</td></tr>
<tr><td>eigenValuesOnly</td><td>&nbsp;</td></tr>
<tr><td>compz</td><td>&nbsp;</td></tr>
<tr><td>Z[:, :]</td><td>&nbsp;</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Outputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>alphaReal[size(H, 1)]</td><td>Real part of alpha (eigenvalue=(alphaReal+i*alphaImag))</td></tr>
<tr><td>alphaImag[size(H, 1)]</td><td>Imaginary part of alpha (eigenvalue=(alphaReal+i*alphaImag))</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
<tr><td>Ho[:, :]</td><td>&nbsp;</td></tr>
<tr><td>Zo[:, :]</td><td>&nbsp;</td></tr>
<tr><td>work[max({lwork,size(H, 1),1})]</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dlange<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><a name="Modelica_LinearSystems2.Math.Matrices.LAPACK.dlange"></a><a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</a>.dlange</h2>
<p>
<b>Norm of a matrix</b>
</p>
<h3>Information</h3>
<pre>Lapack documentation:

   Purpose
   =======

   DLANGE  returns the value of the one norm,  or the Frobenius norm, or
   the  infinity norm,  or the  element of  largest absolute value  of a
   real matrix A.

   Description
   ===========

   DLANGE returns the value

      DLANGE = ( max(abs(A(i,j))), NORM = &#39;M&#39; or &#39;m&#39;
               (
               ( norm1(A),         NORM = &#39;1&#39;, &#39;O&#39; or &#39;o&#39;
               (
               ( normI(A),         NORM = &#39;I&#39; or &#39;i&#39;
               (
               ( normF(A),         NORM = &#39;F&#39;, &#39;f&#39;, &#39;E&#39; or &#39;e&#39;

   where  norm1  denotes the  one norm of a matrix (maximum column sum),
   normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
   normF  denotes the  Frobenius norm of a matrix (square root of sum of
   squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.

   Arguments
   =========

   NORM    (input) CHARACTER*1
           Specifies the value to be returned in DLANGE as described
           above.

   M       (input) INTEGER
           The number of rows of the matrix A.  M &gt;= 0.  When M = 0,
           DLANGE is set to zero.

   N       (input) INTEGER
           The number of columns of the matrix A.  N &gt;= 0.  When N = 0,
           DLANGE is set to zero.

   A       (input) DOUBLE PRECISION array, dimension (LDA,N)
           The m by n matrix A.

   LDA     (input) INTEGER
           The leading dimension of the array A.  LDA &gt;= max(M,1).

   WORK    (workspace) DOUBLE PRECISION array, dimension (MAX(1,LWORK)),
           where LWORK &gt;= M when NORM = &#39;I&#39;; otherwise, WORK is not
           referenced.

   =====================================================================
</pre>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Inputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, :]</td><td>Real matrix A</td></tr>
<tr><td>norm</td><td>specifies the norm, i.e. 1, I, F, M</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Outputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>anorm</td><td>norm of A</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dlansy<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><a name="Modelica_LinearSystems2.Math.Matrices.LAPACK.dlansy"></a><a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</a>.dlansy</h2>
<p>
<b>Norm of a symmetric matrix</b>
</p>
<h3>Information</h3>
<pre>Lapack documentation:

   Purpose
   =======

   DLANSY  returns the value of the one norm,  or the Frobenius norm, or
   the  infinity norm,  or the  element of  largest absolute value  of a
   real symmetric matrix A.

   Description
   ===========

   DLANSY returns the value

      DLANSY = ( max(abs(A(i,j))), NORM = &#39;M&#39; or &#39;m&#39;
               (
               ( norm1(A),         NORM = &#39;1&#39;, &#39;O&#39; or &#39;o&#39;
               (
               ( normI(A),         NORM = &#39;I&#39; or &#39;i&#39;
               (
               ( normF(A),         NORM = &#39;F&#39;, &#39;f&#39;, &#39;E&#39; or &#39;e&#39;

   where  norm1  denotes the  one norm of a matrix (maximum column sum),
   normI  denotes the  infinity norm  of a matrix  (maximum row sum) and
   normF  denotes the  Frobenius norm of a matrix (square root of sum of
   squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.

   Arguments
   =========

   NORM    (input) CHARACTER*1
           Specifies the value to be returned in DLANSY as described
           above.

   UPLO    (input) CHARACTER*1
           Specifies whether the upper or lower triangular part of the
           symmetric matrix A is to be referenced.
           = &#39;U&#39;:  Upper triangular part of A is referenced
           = &#39;L&#39;:  Lower triangular part of A is referenced

   N       (input) INTEGER
           The order of the matrix A.  N &gt;= 0.  When N = 0, DLANSY is
           set to zero.

   A       (input) DOUBLE PRECISION array, dimension (LDA,N)
           The symmetric matrix A.  If UPLO = &#39;U&#39;, the leading n by n
           upper triangular part of A contains the upper triangular part
           of the matrix A, and the strictly lower triangular part of A
           is not referenced.  If UPLO = &#39;L&#39;, the leading n by n lower
           triangular part of A contains the lower triangular part of
           the matrix A, and the strictly upper triangular part of A is
           not referenced.

   LDA     (input) INTEGER
           The leading dimension of the array A.  LDA &gt;= max(N,1).

   WORK    (workspace) DOUBLE PRECISION array, dimension (MAX(1,LWORK)),
           where LWORK &gt;= N when NORM = &#39;I&#39; or &#39;1&#39; or &#39;O&#39;; otherwise,
           WORK is not referenced.

   =====================================================================
</pre>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Inputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, :]</td><td>Real symmetric matrix A</td></tr>
<tr><td>norm</td><td>Specifies the norm, i.e. 1, I, F, M</td></tr>
<tr><td>upper</td><td>Specifies whether the upper or lower triangular part of A is referenced</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Outputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>anorm</td><td>Norm of A</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dorghr<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><a name="Modelica_LinearSystems2.Math.Matrices.LAPACK.dorghr"></a><a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</a>.dorghr</h2>
<p>
<b>Generates a real orthogonal matrix Q which is defined as the product of IHI-ILO elementary reflectors of order N, as returned by DGEHRD</b>
</p>
<h3>Information</h3>
<pre>Lapack documentation:

   Purpose
   =======

   DORGHR generates a real orthogonal matrix Q which is defined as the
   product of IHI-ILO elementary reflectors of order N, as returned by
   DGEHRD:

   Q = H(ilo) H(ilo+1) . . . H(ihi-1).

   Arguments
   =========

   N       (input) INTEGER
           The order of the matrix Q. N &gt;= 0.

   ILO     (input) INTEGER
   IHI     (input) INTEGER
           ILO and IHI must have the same values as in the previous call
           of DGEHRD. Q is equal to the unit matrix except in the
           submatrix Q(ilo+1:ihi,ilo+1:ihi).
           1 &lt;= ILO &lt;= IHI &lt;= N, if N &gt; 0; ILO=1 and IHI=0, if N=0.

   A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
           On entry, the vectors which define the elementary reflectors,
           as returned by DGEHRD.
           On exit, the N-by-N orthogonal matrix Q.

   LDA     (input) INTEGER
           The leading dimension of the array A. LDA &gt;= max(1,N).

   TAU     (input) DOUBLE PRECISION array, dimension (N-1)
           TAU(i) must contain the scalar factor of the elementary
           reflector H(i), as returned by DGEHRD.

   WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

   LWORK   (input) INTEGER
           The dimension of the array WORK. LWORK &gt;= IHI-ILO.
           For optimum performance LWORK &gt;= (IHI-ILO)*NB, where NB is
           the optimal blocksize.

           If LWORK = -1, then a workspace query is assumed; the routine
           only calculates the optimal size of the WORK array, returns
           this value as the first entry of the WORK array, and no error
           message related to LWORK is issued by XERBLA.

   INFO    (output) INTEGER
           = 0:  successful exit
           &lt; 0:  if INFO = -i, the i-th argument had an illegal value

   =====================================================================
</pre>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Inputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, size(A, 1)]</td><td>Square matrix A</td></tr>
<tr><td>ilo</td><td>lowest index where the original matrix had been Hessenbergform - ilo must have the same value as in the previous call of DGEHRD</td></tr>
<tr><td>ihi</td><td>highest index where the original matrix had been Hessenbergform  - ihi must have the same value as in the previous call of DGEHRD</td></tr>
<tr><td>tau[max(0, size(A, 1) - 1)]</td><td>scalar factors of the elementary reflectors</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Outputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>Aout[size(A, 1), size(A, 2)]</td><td>Orthogonal matrix as a result of elementary reflectors</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dorgqr<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><a name="Modelica_LinearSystems2.Math.Matrices.LAPACK.dorgqr"></a><a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</a>.dorgqr</h2>
<p>
<b>Generate a real orthogonal matrix Q which is defined as the product of elementary reflectors, as returned by DGEQRF</b>
</p>
<h3>Information</h3>
<pre>Lapack documentation:

   Purpose
   =======

   DORGQR generates an M-by-N real matrix Q with orthonormal columns,
   which is defined as the first N columns of a product of K elementary
   reflectors of order M

         Q  =  H(1) H(2) . . . H(k)

   as returned by DGEQRF.

   Arguments
   =========

   M       (input) INTEGER
           The number of rows of the matrix Q. M &gt;= 0.

   N       (input) INTEGER
           The number of columns of the matrix Q. M &gt;= N &gt;= 0.

   K       (input) INTEGER
           The number of elementary reflectors whose product defines the
           matrix Q. N &gt;= K &gt;= 0.

   A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
           On entry, the i-th column must contain the vector which
           defines the elementary reflector H(i), for i = 1,2,...,k, as
           returned by DGEQRF in the first k columns of its array
           argument A.
           On exit, the M-by-N matrix Q.

   LDA     (input) INTEGER
           The first dimension of the array A. LDA &gt;= max(1,M).

   TAU     (input) DOUBLE PRECISION array, dimension (K)
           TAU(i) must contain the scalar factor of the elementary
           reflector H(i), as returned by DGEQRF.

   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

   LWORK   (input) INTEGER
           The dimension of the array WORK. LWORK &gt;= max(1,N).
           For optimum performance LWORK &gt;= N*NB, where NB is the
           optimal blocksize.

           If LWORK = -1, then a workspace query is assumed; the routine
           only calculates the optimal size of the WORK array, returns
           this value as the first entry of the WORK array, and no error
           message related to LWORK is issued by XERBLA.

   INFO    (output) INTEGER
           = 0:  successful exit
           &lt; 0:  if INFO = -i, the i-th argument has an illegal value

   =====================================================================
</pre>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Inputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>Q[:, :]</td><td>Orthogonal matrix of elementary reflectors</td></tr>
<tr><td>tau[:]</td><td>Scalar factors of the elementary reflectors</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Outputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>Qout[size(Q, 1), size(Q, 2)]</td><td>&nbsp;</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dorgqr_x<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><a name="Modelica_LinearSystems2.Math.Matrices.LAPACK.dorgqr_x"></a><a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</a>.dorgqr_x</h2>
<p>
<b>Generates a real orthogonal matrix Q which is defined as the product of elementary reflectors, as returned by DGEQRF</b>
</p>
<h3>Information</h3>
<pre>Lapack documentation:

   Purpose
   =======

   DORGQR generates an M-by-N real matrix Q with orthonormal columns,
   which is defined as the first N columns of a product of K elementary
   reflectors of order M

         Q  =  H(1) H(2) . . . H(k)

   as returned by DGEQRF.

   Arguments
   =========

   M       (input) INTEGER
           The number of rows of the matrix Q. M &gt;= 0.

   N       (input) INTEGER
           The number of columns of the matrix Q. M &gt;= N &gt;= 0.

   K       (input) INTEGER
           The number of elementary reflectors whose product defines the
           matrix Q. N &gt;= K &gt;= 0.

   A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
           On entry, the i-th column must contain the vector which
           defines the elementary reflector H(i), for i = 1,2,...,k, as
           returned by DGEQRF in the first k columns of its array
           argument A.
           On exit, the M-by-N matrix Q.

   LDA     (input) INTEGER
           The first dimension of the array A. LDA &gt;= max(1,M).

   TAU     (input) DOUBLE PRECISION array, dimension (K)
           TAU(i) must contain the scalar factor of the elementary
           reflector H(i), as returned by DGEQRF.

   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

   LWORK   (input) INTEGER
           The dimension of the array WORK. LWORK &gt;= max(1,N).
           For optimum performance LWORK &gt;= N*NB, where NB is the
           optimal blocksize.

           If LWORK = -1, then a workspace query is assumed; the routine
           only calculates the optimal size of the WORK array, returns
           this value as the first entry of the WORK array, and no error
           message related to LWORK is issued by XERBLA.

   INFO    (output) INTEGER
           = 0:  successful exit
           &lt; 0:  if INFO = -i, the i-th argument has an illegal value

   =====================================================================
</pre>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Inputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>Q[:, :]</td><td>Orthogonal matrix as a result of elementary reflectors</td></tr>
<tr><td>tau[:]</td><td>scalar factors of the elementary reflectors</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Outputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>Aout[size(Q, 1), size(Q, 1)]</td><td>&nbsp;</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dormhr<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><a name="Modelica_LinearSystems2.Math.Matrices.LAPACK.dormhr"></a><a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</a>.dormhr</h2>
<p>
<b>Overwrites the general real M-by-N matrix C with Q * C or C * Q or Q&#39; * C or C * Q&#39;, where Q is an orthogonal matrix as returne by dgehrd</b>
</p>
<h3>Information</h3>
<pre>Lapack documentation:

   Purpose
   =======

   DORMHR overwrites the general real M-by-N matrix C with

                   SIDE = &#39;L&#39;     SIDE = &#39;R&#39;
   TRANS = &#39;N&#39;:      Q * C          C * Q
   TRANS = &#39;T&#39;:      Q**T * C       C * Q**T

   where Q is a real orthogonal matrix of order nq, with nq = m if
   SIDE = &#39;L&#39; and nq = n if SIDE = &#39;R&#39;. Q is defined as the product of
   IHI-ILO elementary reflectors, as returned by DGEHRD:

   Q = H(ilo) H(ilo+1) . . . H(ihi-1).

   Arguments
   =========

   SIDE    (input) CHARACTER*1
           = &#39;L&#39;: apply Q or Q**T from the Left;
           = &#39;R&#39;: apply Q or Q**T from the Right.

   TRANS   (input) CHARACTER*1
           = &#39;N&#39;:  No transpose, apply Q;
           = &#39;T&#39;:  Transpose, apply Q**T.

   M       (input) INTEGER
           The number of rows of the matrix C. M &gt;= 0.

   N       (input) INTEGER
           The number of columns of the matrix C. N &gt;= 0.

   ILO     (input) INTEGER
   IHI     (input) INTEGER
           ILO and IHI must have the same values as in the previous call
           of DGEHRD. Q is equal to the unit matrix except in the
           submatrix Q(ilo+1:ihi,ilo+1:ihi).
           If SIDE = &#39;L&#39;, then 1 &lt;= ILO &lt;= IHI &lt;= M, if M &gt; 0, and
           ILO = 1 and IHI = 0, if M = 0;
           if SIDE = &#39;R&#39;, then 1 &lt;= ILO &lt;= IHI &lt;= N, if N &gt; 0, and
           ILO = 1 and IHI = 0, if N = 0.

   A       (input) DOUBLE PRECISION array, dimension
                                (LDA,M) if SIDE = &#39;L&#39;
                                (LDA,N) if SIDE = &#39;R&#39;
           The vectors which define the elementary reflectors, as
           returned by DGEHRD.

   LDA     (input) INTEGER
           The leading dimension of the array A.
           LDA &gt;= max(1,M) if SIDE = &#39;L&#39;; LDA &gt;= max(1,N) if SIDE = &#39;R&#39;.

   TAU     (input) DOUBLE PRECISION array, dimension
                                (M-1) if SIDE = &#39;L&#39;
                                (N-1) if SIDE = &#39;R&#39;
           TAU(i) must contain the scalar factor of the elementary
           reflector H(i), as returned by DGEHRD.

   C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)
           On entry, the M-by-N matrix C.
           On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.

   LDC     (input) INTEGER
           The leading dimension of the array C. LDC &gt;= max(1,M).

   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

   LWORK   (input) INTEGER
           The dimension of the array WORK.
           If SIDE = &#39;L&#39;, LWORK &gt;= max(1,N);
           if SIDE = &#39;R&#39;, LWORK &gt;= max(1,M).
           For optimum performance LWORK &gt;= N*NB if SIDE = &#39;L&#39;, and
           LWORK &gt;= M*NB if SIDE = &#39;R&#39;, where NB is the optimal
           blocksize.

           If LWORK = -1, then a workspace query is assumed; the routine
           only calculates the optimal size of the WORK array, returns
           this value as the first entry of the WORK array, and no error
           message related to LWORK is issued by XERBLA.

   INFO    (output) INTEGER
           = 0:  successful exit
           &lt; 0:  if INFO = -i, the i-th argument had an illegal value

   =====================================================================  </pre>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Inputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>C[:, :]</td><td>&nbsp;</td></tr>
<tr><td>A[:, :]</td><td>&nbsp;</td></tr>
<tr><td>tau[if side == &quot;L&quot; then size(C, 2) - 1 else size(C, 1) - 1]</td><td>&nbsp;</td></tr>
<tr><td>side</td><td>&nbsp;</td></tr>
<tr><td>trans</td><td>&nbsp;</td></tr>
<tr><td>ilo</td><td>lowest index where the original matrix had been Hessenbergform</td></tr>
<tr><td>ihi</td><td>highest index where the original matrix had been Hessenbergform</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Outputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>Cout[size(C, 1), size(C, 2)]</td><td>contains the Hessenberg form in the upper triangle and the first subdiagonal and below the first subdiagonal it contains the elementary reflectors which represents (with array tau) as a product the orthogonal matrix Q</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dormqr<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><a name="Modelica_LinearSystems2.Math.Matrices.LAPACK.dormqr"></a><a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</a>.dormqr</h2>
<p>
<b>Overwrites the general real M-by-N matrix C with Q * C or C * Q or Q&#39; * C or C * Q&#39;, where Q is an orthogonal matrix of a QR factorization as returned by dgeqrf</b>
</p>
<h3>Information</h3>
<pre>Lapack documentation:

   Purpose
   =======

   DORMQR overwrites the general real M-by-N matrix C with

                   SIDE = &#39;L&#39;     SIDE = &#39;R&#39;
   TRANS = &#39;N&#39;:      Q * C          C * Q
   TRANS = &#39;T&#39;:      Q**T * C       C * Q**T

   where Q is a real orthogonal matrix defined as the product of k
   elementary reflectors

         Q = H(1) H(2) . . . H(k)

   as returned by DGEQRF. Q is of order M if SIDE = &#39;L&#39; and of order N
   if SIDE = &#39;R&#39;.

   Arguments
   =========

   SIDE    (input) CHARACTER*1
           = &#39;L&#39;: apply Q or Q**T from the Left;
           = &#39;R&#39;: apply Q or Q**T from the Right.

   TRANS   (input) CHARACTER*1
           = &#39;N&#39;:  No transpose, apply Q;
           = &#39;T&#39;:  Transpose, apply Q**T.

   M       (input) INTEGER
           The number of rows of the matrix C. M &gt;= 0.

   N       (input) INTEGER
           The number of columns of the matrix C. N &gt;= 0.

   K       (input) INTEGER
           The number of elementary reflectors whose product defines
           the matrix Q.
           If SIDE = &#39;L&#39;, M &gt;= K &gt;= 0;
           if SIDE = &#39;R&#39;, N &gt;= K &gt;= 0.

   A       (input) DOUBLE PRECISION array, dimension (LDA,K)
           The i-th column must contain the vector which defines the
           elementary reflector H(i), for i = 1,2,...,k, as returned by
           DGEQRF in the first k columns of its array argument A.
           A is modified by the routine but restored on exit.

   LDA     (input) INTEGER
           The leading dimension of the array A.
           If SIDE = &#39;L&#39;, LDA &gt;= max(1,M);
           if SIDE = &#39;R&#39;, LDA &gt;= max(1,N).

   TAU     (input) DOUBLE PRECISION array, dimension (K)
           TAU(i) must contain the scalar factor of the elementary
           reflector H(i), as returned by DGEQRF.

   C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)
           On entry, the M-by-N matrix C.
           On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.

   LDC     (input) INTEGER
           The leading dimension of the array C. LDC &gt;= max(1,M).

   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

   LWORK   (input) INTEGER
           The dimension of the array WORK.
           If SIDE = &#39;L&#39;, LWORK &gt;= max(1,N);
           if SIDE = &#39;R&#39;, LWORK &gt;= max(1,M).
           For optimum performance LWORK &gt;= N*NB if SIDE = &#39;L&#39;, and
           LWORK &gt;= M*NB if SIDE = &#39;R&#39;, where NB is the optimal
           blocksize.

           If LWORK = -1, then a workspace query is assumed; the routine
           only calculates the optimal size of the WORK array, returns
           this value as the first entry of the WORK array, and no error
           message related to LWORK is issued by XERBLA.

   INFO    (output) INTEGER
           = 0:  successful exit
           &lt; 0:  if INFO = -i, the i-th argument had an illegal value

   =====================================================================  </pre>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Inputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>C[:, :]</td><td>&nbsp;</td></tr>
<tr><td>A[:, :]</td><td>&nbsp;</td></tr>
<tr><td>tau[:]</td><td>&nbsp;</td></tr>
<tr><td>side</td><td>&nbsp;</td></tr>
<tr><td>trans</td><td>&nbsp;</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Outputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>Cout[size(C, 1), size(C, 2)]</td><td>contains Q*C or Q**T*C or C*Q**T or C*Q</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dtrevc<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><a name="Modelica_LinearSystems2.Math.Matrices.LAPACK.dtrevc"></a><a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</a>.dtrevc</h2>
<p>
<b>Compute the right and/or left eigenvectors of a real upper quasi-triangular matrix T</b>
</p>
<h3>Information</h3>
<pre>Lapack documentation:

   Purpose
   =======

   DTREVC computes some or all of the right and/or left eigenvectors of
   a real upper quasi-triangular matrix T.
   Matrices of this type are produced by the Schur factorization of
   a real general matrix:  A = Q*T*Q**T, as computed by DHSEQR.

   The right eigenvector x and the left eigenvector y of T corresponding
   to an eigenvalue w are defined by:

      T*x = w*x,     (y**H)*T = w*(y**H)

   where y**H denotes the conjugate transpose of y.
   The eigenvalues are not input to this routine, but are read directly
   from the diagonal blocks of T.

   This routine returns the matrices X and/or Y of right and left
   eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
   input matrix.  If Q is the orthogonal factor that reduces a matrix
   A to Schur form T, then Q*X and Q*Y are the matrices of right and
   left eigenvectors of A.

   Arguments
   =========

   SIDE    (input) CHARACTER*1
           = &#39;R&#39;:  compute right eigenvectors only;
           = &#39;L&#39;:  compute left eigenvectors only;
           = &#39;B&#39;:  compute both right and left eigenvectors.

   HOWMNY  (input) CHARACTER*1
           = &#39;A&#39;:  compute all right and/or left eigenvectors;
           = &#39;B&#39;:  compute all right and/or left eigenvectors,
                   backtransformed by the matrices in VR and/or VL;
           = &#39;S&#39;:  compute selected right and/or left eigenvectors,
                   as indicated by the logical array SELECT.

   SELECT  (input/output) LOGICAL array, dimension (N)
           If HOWMNY = &#39;S&#39;, SELECT specifies the eigenvectors to be
           computed.
           If w(j) is a real eigenvalue, the corresponding real
           eigenvector is computed if SELECT(j) is .TRUE..
           If w(j) and w(j+1) are the real and imaginary parts of a
           complex eigenvalue, the corresponding complex eigenvector is
           computed if either SELECT(j) or SELECT(j+1) is .TRUE., and
           on exit SELECT(j) is set to .TRUE. and SELECT(j+1) is set to
           .FALSE..
           Not referenced if HOWMNY = &#39;A&#39; or &#39;B&#39;.

   N       (input) INTEGER
           The order of the matrix T. N &gt;= 0.

   T       (input) DOUBLE PRECISION array, dimension (LDT,N)
           The upper quasi-triangular matrix T in Schur canonical form.

   LDT     (input) INTEGER
           The leading dimension of the array T. LDT &gt;= max(1,N).

   VL      (input/output) DOUBLE PRECISION array, dimension (LDVL,MM)
           On entry, if SIDE = &#39;L&#39; or &#39;B&#39; and HOWMNY = &#39;B&#39;, VL must
           contain an N-by-N matrix Q (usually the orthogonal matrix Q
           of Schur vectors returned by DHSEQR).
           On exit, if SIDE = &#39;L&#39; or &#39;B&#39;, VL contains:
           if HOWMNY = &#39;A&#39;, the matrix Y of left eigenvectors of T;
           if HOWMNY = &#39;B&#39;, the matrix Q*Y;
           if HOWMNY = &#39;S&#39;, the left eigenvectors of T specified by
                            SELECT, stored consecutively in the columns
                            of VL, in the same order as their
                            eigenvalues.
           A complex eigenvector corresponding to a complex eigenvalue
           is stored in two consecutive columns, the first holding the
           real part, and the second the imaginary part.
           Not referenced if SIDE = &#39;R&#39;.

   LDVL    (input) INTEGER
           The leading dimension of the array VL.  LDVL &gt;= 1, and if
           SIDE = &#39;L&#39; or &#39;B&#39;, LDVL &gt;= N.

   VR      (input/output) DOUBLE PRECISION array, dimension (LDVR,MM)
           On entry, if SIDE = &#39;R&#39; or &#39;B&#39; and HOWMNY = &#39;B&#39;, VR must
           contain an N-by-N matrix Q (usually the orthogonal matrix Q
           of Schur vectors returned by DHSEQR).
           On exit, if SIDE = &#39;R&#39; or &#39;B&#39;, VR contains:
           if HOWMNY = &#39;A&#39;, the matrix X of right eigenvectors of T;
           if HOWMNY = &#39;B&#39;, the matrix Q*X;
           if HOWMNY = &#39;S&#39;, the right eigenvectors of T specified by
                            SELECT, stored consecutively in the columns
                            of VR, in the same order as their
                            eigenvalues.
           A complex eigenvector corresponding to a complex eigenvalue
           is stored in two consecutive columns, the first holding the
           real part and the second the imaginary part.
           Not referenced if SIDE = &#39;L&#39;.

   LDVR    (input) INTEGER
           The leading dimension of the array VR.  LDVR &gt;= 1, and if
           SIDE = &#39;R&#39; or &#39;B&#39;, LDVR &gt;= N.

   MM      (input) INTEGER
           The number of columns in the arrays VL and/or VR. MM &gt;= M.

   M       (output) INTEGER
           The number of columns in the arrays VL and/or VR actually
           used to store the eigenvectors.
           If HOWMNY = &#39;A&#39; or &#39;B&#39;, M is set to N.
           Each selected real eigenvector occupies one column and each
           selected complex eigenvector occupies two columns.

   WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)

   INFO    (output) INTEGER
           = 0:  successful exit
           &lt; 0:  if INFO = -i, the i-th argument had an illegal value

   Further Details
   ===============

   The algorithm used in this program is basically backward (forward)
   substitution, with scaling to make the the code robust against
   possible overflow.

   Each eigenvector is normalized so that the element of largest
   magnitude has magnitude 1; here the magnitude of a complex number
   (x,y) is taken to be |x| + |y|.

   =====================================================================  </pre>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Inputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>T[:, size(T, 1)]</td><td>&nbsp;</td></tr>
<tr><td>side</td><td>&nbsp;</td></tr>
<tr><td>howmny</td><td>&nbsp;</td></tr>
<tr><td>Q[size(T, 1), size(T, 1)]</td><td>&nbsp;</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Outputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>lEigenVectors[size(T, 1), size(T, 1)]</td><td>left eigenvectors of matrix T</td></tr>
<tr><td>rEigenVectors[size(T, 1), size(T, 1)]</td><td>right eigenvectors of matrix T</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dtrsen<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><a name="Modelica_LinearSystems2.Math.Matrices.LAPACK.dtrsen"></a><a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</a>.dtrsen</h2>
<p>
<b>DTRSEN reorders the real Schur factorization of a real matrix</b>
</p>
<h3>Information</h3>
<pre>Lapack documentation:

   Purpose
   =======

   DTRSEN reorders the real Schur factorization of a real matrix
   A = Q*T*Q**T, so that a selected cluster of eigenvalues appears in
   the leading diagonal blocks of the upper quasi-triangular matrix T,
   and the leading columns of Q form an orthonormal basis of the
   corresponding right invariant subspace.

   Optionally the routine computes the reciprocal condition numbers of
   the cluster of eigenvalues and/or the invariant subspace.

   T must be in Schur canonical form (as returned by DHSEQR), that is,
   block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
   2-by-2 diagonal block has its diagonal elemnts equal and its
   off-diagonal elements of opposite sign.

   Arguments
   =========

   JOB     (input) CHARACTER*1
           Specifies whether condition numbers are required for the
           cluster of eigenvalues (S) or the invariant subspace (SEP):
           = &#39;N&#39;: none;
           = &#39;E&#39;: for eigenvalues only (S);
           = &#39;V&#39;: for invariant subspace only (SEP);
           = &#39;B&#39;: for both eigenvalues and invariant subspace (S and
                  SEP).

   COMPQ   (input) CHARACTER*1
           = &#39;V&#39;: update the matrix Q of Schur vectors;
           = &#39;N&#39;: do not update Q.

   SELECT  (input) LOGICAL array, dimension (N)
           SELECT specifies the eigenvalues in the selected cluster. To
           select a real eigenvalue w(j), SELECT(j) must be set to
           .TRUE.. To select a complex conjugate pair of eigenvalues
           w(j) and w(j+1), corresponding to a 2-by-2 diagonal block,
           either SELECT(j) or SELECT(j+1) or both must be set to
           .TRUE.; a complex conjugate pair of eigenvalues must be
           either both included in the cluster or both excluded.

   N       (input) INTEGER
           The order of the matrix T. N &gt;= 0.

   T       (input/output) DOUBLE PRECISION array, dimension (LDT,N)
           On entry, the upper quasi-triangular matrix T, in Schur
           canonical form.
           On exit, T is overwritten by the reordered matrix T, again in
           Schur canonical form, with the selected eigenvalues in the
           leading diagonal blocks.

   LDT     (input) INTEGER
           The leading dimension of the array T. LDT &gt;= max(1,N).

   Q       (input/output) DOUBLE PRECISION array, dimension (LDQ,N)
           On entry, if COMPQ = &#39;V&#39;, the matrix Q of Schur vectors.
           On exit, if COMPQ = &#39;V&#39;, Q has been postmultiplied by the
           orthogonal transformation matrix which reorders T; the
           leading M columns of Q form an orthonormal basis for the
           specified invariant subspace.
           If COMPQ = &#39;N&#39;, Q is not referenced.

   LDQ     (input) INTEGER
           The leading dimension of the array Q.
           LDQ &gt;= 1; and if COMPQ = &#39;V&#39;, LDQ &gt;= N.

   WR      (output) DOUBLE PRECISION array, dimension (N)
   WI      (output) DOUBLE PRECISION array, dimension (N)
           The real and imaginary parts, respectively, of the reordered
           eigenvalues of T. The eigenvalues are stored in the same
           order as on the diagonal of T, with WR(i) = T(i,i) and, if
           T(i:i+1,i:i+1) is a 2-by-2 diagonal block, WI(i) &gt; 0 and
           WI(i+1) = -WI(i). Note that if a complex eigenvalue is
           sufficiently ill-conditioned, then its value may differ
           significantly from its value before reordering.

   M       (output) INTEGER
           The dimension of the specified invariant subspace.
           0 &lt; = M &lt;= N.

   S       (output) DOUBLE PRECISION
           If JOB = &#39;E&#39; or &#39;B&#39;, S is a lower bound on the reciprocal
           condition number for the selected cluster of eigenvalues.
           S cannot underestimate the true reciprocal condition number
           by more than a factor of sqrt(N). If M = 0 or N, S = 1.
           If JOB = &#39;N&#39; or &#39;V&#39;, S is not referenced.

   SEP     (output) DOUBLE PRECISION
           If JOB = &#39;V&#39; or &#39;B&#39;, SEP is the estimated reciprocal
           condition number of the specified invariant subspace. If
           M = 0 or N, SEP = norm(T).
           If JOB = &#39;N&#39; or &#39;E&#39;, SEP is not referenced.

   WORK    (workspace/output) DOUBLE PRECISION array, dimension (LWORK)
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

   LWORK   (input) INTEGER
           The dimension of the array WORK.
           If JOB = &#39;N&#39;, LWORK &gt;= max(1,N);
           if JOB = &#39;E&#39;, LWORK &gt;= M*(N-M);
           if JOB = &#39;V&#39; or &#39;B&#39;, LWORK &gt;= 2*M*(N-M).

           If LWORK = -1, then a workspace query is assumed; the routine
           only calculates the optimal size of the WORK array, returns
           this value as the first entry of the WORK array, and no error
           message related to LWORK is issued by XERBLA.

   IWORK   (workspace) INTEGER array, dimension (LIWORK)
           IF JOB = &#39;N&#39; or &#39;E&#39;, IWORK is not referenced.

   LIWORK  (input) INTEGER
           The dimension of the array IWORK.
           If JOB = &#39;N&#39; or &#39;E&#39;, LIWORK &gt;= 1;
           if JOB = &#39;V&#39; or &#39;B&#39;, LIWORK &gt;= M*(N-M).

           If LIWORK = -1, then a workspace query is assumed; the
           routine only calculates the optimal size of the IWORK array,
           returns this value as the first entry of the IWORK array, and
           no error message related to LIWORK is issued by XERBLA.

   INFO    (output) INTEGER
           = 0: successful exit
           &lt; 0: if INFO = -i, the i-th argument had an illegal value
           = 1: reordering of T failed because some eigenvalues are too
                close to separate (the problem is very ill-conditioned);
                T may have been partially reordered, and WR and WI
                contain the eigenvalues in the same order as in T; S and
                SEP (if requested) are set to zero.

   Further Details
   ===============

   DTRSEN first collects the selected eigenvalues by computing an
   orthogonal transformation Z to move them to the top left corner of T.
   In other words, the selected eigenvalues are the eigenvalues of T11
   in:

                 Z&#39;*T*Z = ( T11 T12 ) n1
                          (  0  T22 ) n2
                             n1  n2

   where N = n1+n2 and Z&#39; means the transpose of Z. The first n1 columns
   of Z span the specified invariant subspace of T.

   If T has been obtained from the real Schur factorization of a matrix
   A = Q*T*Q&#39;, then the reordered real Schur factorization of A is given
   by A = (Q*Z)*(Z&#39;*T*Z)*(Q*Z)&#39;, and the first n1 columns of Q*Z span
   the corresponding invariant subspace of A.

   The reciprocal condition number of the average of the eigenvalues of
   T11 may be returned in S. S lies between 0 (very badly conditioned)
   and 1 (very well conditioned). It is computed as follows. First we
   compute R so that

                          P = ( I  R ) n1
                              ( 0  0 ) n2
                                n1 n2

   is the projector on the invariant subspace associated with T11.
   R is the solution of the Sylvester equation:

                         T11*R - R*T22 = T12.

   Let F-norm(M) denote the Frobenius-norm of M and 2-norm(M) denote
   the two-norm of M. Then S is computed as the lower bound

                       (1 + F-norm(R)**2)**(-1/2)

   on the reciprocal of 2-norm(P), the true reciprocal condition number.
   S cannot underestimate 1 / 2-norm(P) by more than a factor of
   sqrt(N).

   An approximate error bound for the computed average of the
   eigenvalues of T11 is

                          EPS * norm(T) / S

   where EPS is the machine precision.

   The reciprocal condition number of the right invariant subspace
   spanned by the first n1 columns of Z (or of Q*Z) is returned in SEP.
   SEP is defined as the separation of T11 and T22:

                      sep( T11, T22 ) = sigma-min( C )

   where sigma-min(C) is the smallest singular value of the
   n1*n2-by-n1*n2 matrix

      C  = kprod( I(n2), T11 ) - kprod( transpose(T22), I(n1) )

   I(m) is an m by m identity matrix, and kprod denotes the Kronecker
   product. We estimate sigma-min(C) by the reciprocal of an estimate of
   the 1-norm of inverse(C). The true reciprocal 1-norm of inverse(C)
   cannot differ from sigma-min(C) by more than a factor of sqrt(n1*n2).

   When SEP is small, small changes in T can cause large changes in
   the invariant subspace. An approximate bound on the maximum angular
   error in the computed right invariant subspace is

                       EPS * norm(T) / SEP

   =====================================================================  </pre>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Inputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>job</td><td>&nbsp;</td></tr>
<tr><td>compq</td><td>&nbsp;</td></tr>
<tr><td>select[:]</td><td>&nbsp;</td></tr>
<tr><td>T[:, :]</td><td>&nbsp;</td></tr>
<tr><td>Q[:, size(T, 2)]</td><td>&nbsp;</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Outputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>To[:, :]</td><td>&nbsp;</td></tr>
<tr><td>Qo[:, :]</td><td>&nbsp;</td></tr>
<tr><td>wr[size(T, 2)]</td><td>&nbsp;</td></tr>
<tr><td>wi[size(T, 2)]</td><td>&nbsp;</td></tr>
<tr><td>m</td><td>&nbsp;</td></tr>
<tr><td>s</td><td>&nbsp;</td></tr>
<tr><td>sep</td><td>&nbsp;</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dtrsyl<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><a name="Modelica_LinearSystems2.Math.Matrices.LAPACK.dtrsyl"></a><a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</a>.dtrsyl</h2>
<p>
<b>DTRSYL solves the real Sylvester matrix equation</b>
</p>
<h3>Information</h3>
<pre>Lapack documentation:

   Purpose
   =======

   DTRSYL solves the real Sylvester matrix equation:

      op(A)*X + X*op(B) = scale*C or
      op(A)*X - X*op(B) = scale*C,

   where op(A) = A or A**T, and  A and B are both upper quasi-
   triangular. A is M-by-M and B is N-by-N; the right hand side C and
   the solution X are M-by-N; and scale is an output scale factor, set
   &lt;= 1 to avoid overflow in X.

   A and B must be in Schur canonical form (as returned by DHSEQR), that
   is, block upper triangular with 1-by-1 and 2-by-2 diagonal blocks;
   each 2-by-2 diagonal block has its diagonal elements equal and its
   off-diagonal elements of opposite sign.

   Arguments
   =========

   TRANA   (input) CHARACTER*1
           Specifies the option op(A):
           = &#39;N&#39;: op(A) = A    (No transpose)
           = &#39;T&#39;: op(A) = A**T (Transpose)
           = &#39;C&#39;: op(A) = A**H (Conjugate transpose = Transpose)

   TRANB   (input) CHARACTER*1
           Specifies the option op(B):
           = &#39;N&#39;: op(B) = B    (No transpose)
           = &#39;T&#39;: op(B) = B**T (Transpose)
           = &#39;C&#39;: op(B) = B**H (Conjugate transpose = Transpose)

   ISGN    (input) INTEGER
           Specifies the sign in the equation:
           = +1: solve op(A)*X + X*op(B) = scale*C
           = -1: solve op(A)*X - X*op(B) = scale*C

   M       (input) INTEGER
           The order of the matrix A, and the number of rows in the
           matrices X and C. M &gt;= 0.

   N       (input) INTEGER
           The order of the matrix B, and the number of columns in the
           matrices X and C. N &gt;= 0.

   A       (input) DOUBLE PRECISION array, dimension (LDA,M)
           The upper quasi-triangular matrix A, in Schur canonical form.

   LDA     (input) INTEGER
           The leading dimension of the array A. LDA &gt;= max(1,M).

   B       (input) DOUBLE PRECISION array, dimension (LDB,N)
           The upper quasi-triangular matrix B, in Schur canonical form.

   LDB     (input) INTEGER
           The leading dimension of the array B. LDB &gt;= max(1,N).

   C       (input/output) DOUBLE PRECISION array, dimension (LDC,N)
           On entry, the M-by-N right hand side matrix C.
           On exit, C is overwritten by the solution matrix X.

   LDC     (input) INTEGER
           The leading dimension of the array C. LDC &gt;= max(1,M)

   SCALE   (output) DOUBLE PRECISION
           The scale factor, scale, set &lt;= 1 to avoid overflow in X.

   INFO    (output) INTEGER
           = 0: successful exit
           &lt; 0: if INFO = -i, the i-th argument had an illegal value
           = 1: A and B have common or very close eigenvalues; perturbed
                values were used to solve the equation (but the matrices
                A and B are unchanged).

   =====================================================================
</pre>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Inputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, :]</td><td>&nbsp;</td></tr>
<tr><td>B[:, :]</td><td>&nbsp;</td></tr>
<tr><td>C[if tranA then size(A, 1) else size(A, 2), if tranB then size(B, 1) else size(B, 2)]</td><td>&nbsp;</td></tr>
<tr><td>tranA</td><td>&nbsp;</td></tr>
<tr><td>tranB</td><td>&nbsp;</td></tr>
<tr><td>isgn</td><td>&nbsp;</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Outputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>X[size(C, 1), size(C, 2)]</td><td>&nbsp;</td></tr>
<tr><td>scale</td><td>&nbsp;</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgelsx<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica_LinearSystems2.M7c6cfd1f335ff272gelsxI.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgelsx" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgelsx"></a><a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</a>.dgelsx</h2>
<p>
<b>Computes the minimum-norm solution to a real linear least squares problem with rank deficient A</b>
</p>
<h3>Information</h3>
<pre>Lapack documentation:

   Purpose
   =======

   DGELSX computes the minimum-norm solution to a real linear least
   squares problem:
       minimize || A * X - B ||
   using a complete orthogonal factorization of A.  A is an M-by-N
   matrix which may be rank-deficient.

   Several right hand side vectors b and solution vectors x can be
   handled in a single call; they are stored as the columns of the
   M-by-NRHS right hand side matrix B and the N-by-NRHS solution
   matrix X.

   The routine first computes a QR factorization with column pivoting:
       A * P = Q * [ R11 R12 ]
                   [  0  R22 ]
   with R11 defined as the largest leading submatrix whose estimated
   condition number is less than 1/RCOND.  The order of R11, RANK,
   is the effective rank of A.

   Then, R22 is considered to be negligible, and R12 is annihilated
   by orthogonal transformations from the right, arriving at the
   complete orthogonal factorization:
      A * P = Q * [ T11 0 ] * Z
                  [  0  0 ]
   The minimum-norm solution is then
      X = P * Z&#39; [ inv(T11)*Q1&#39;*B ]
                 [        0       ]
   where Q1 consists of the first RANK columns of Q.

   Arguments
   =========

   M       (input) INTEGER
           The number of rows of the matrix A.  M &gt;= 0.

   N       (input) INTEGER
           The number of columns of the matrix A.  N &gt;= 0.

   NRHS    (input) INTEGER
           The number of right hand sides, i.e., the number of
           columns of matrices B and X. NRHS &gt;= 0.

   A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
           On entry, the M-by-N matrix A.
           On exit, A has been overwritten by details of its
           complete orthogonal factorization.

   LDA     (input) INTEGER
           The leading dimension of the array A.  LDA &gt;= max(1,M).

   B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
           On entry, the M-by-NRHS right hand side matrix B.
           On exit, the N-by-NRHS solution matrix X.
           If m &gt;= n and RANK = n, the residual sum-of-squares for
           the solution in the i-th column is given by the sum of
           squares of elements N+1:M in that column.

   LDB     (input) INTEGER
           The leading dimension of the array B. LDB &gt;= max(1,M,N).

   JPVT    (input/output) INTEGER array, dimension (N)
           On entry, if JPVT(i) .ne. 0, the i-th column of A is an
           initial column, otherwise it is a free column.  Before
           the QR factorization of A, all initial columns are
           permuted to the leading positions; only the remaining
           free columns are moved as a result of column pivoting
           during the factorization.
           On exit, if JPVT(i) = k, then the i-th column of A*P
           was the k-th column of A.

   RCOND   (input) DOUBLE PRECISION
           RCOND is used to determine the effective rank of A, which
           is defined as the order of the largest leading triangular
           submatrix R11 in the QR factorization with pivoting of A,
           whose estimated condition number &lt; 1/RCOND.

   RANK    (output) INTEGER
           The effective rank of A, i.e., the order of the submatrix
           R11.  This is the same as the order of the submatrix T11
           in the complete orthogonal factorization of A.

   WORK    (workspace) DOUBLE PRECISION array, dimension
                       (max( min(M,N)+3*N, 2*min(M,N)+NRHS )),

   INFO    (output) INTEGER
           = 0:  successful exit
           &lt; 0:  if INFO = -i, the i-th argument had an illegal value

   =====================================================================  </pre>
<p>Extends from Modelica.Icons.Function (Icon for functions).</p>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Inputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, :]</td><td>&nbsp;</td></tr>
<tr><td>B[size(A, 1), :]</td><td>&nbsp;</td></tr>
<tr><td>rcond</td><td>Reciprocal condition number to estimate rank</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Outputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>X[max(nrow, ncol), nrhs]</td><td>Solution is in first size(A,2) rows</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
<tr><td>rank</td><td>Effective rank of A</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgemm<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><a name="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgemm"></a><a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</a>.dgemm</h2>
<p>
<b>Blas algorithm to perform C:=a*op(A)*op(B) + b*C (a,b scalars, ABC matrices)</b>
</p>
<h3>Information</h3>
<pre>Lapack documentation:

   Purpose
   =======

   DGEMM  performs one of the matrix-matrix operations
      C := alpha*op( A )*op( B ) + beta*C,
   where  op( X ) is one of
      op( X ) = X   or   op( X ) = X&#39;,
   alpha and beta are scalars, and A, B and C are matrices, with op( A )
   an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.

   Arguments
   ==========

   TRANSA - CHARACTER*1.
            On entry, TRANSA specifies the form of op( A ) to be used in
            the matrix multiplication as follows:
               TRANSA = &#39;N&#39; or &#39;n&#39;,  op( A ) = A.
               TRANSA = &#39;T&#39; or &#39;t&#39;,  op( A ) = A&#39;.
               TRANSA = &#39;C&#39; or &#39;c&#39;,  op( A ) = A&#39;.
            Unchanged on exit.
   TRANSB - CHARACTER*1.
            On entry, TRANSB specifies the form of op( B ) to be used in
            the matrix multiplication as follows:
               TRANSB = &#39;N&#39; or &#39;n&#39;,  op( B ) = B.
               TRANSB = &#39;T&#39; or &#39;t&#39;,  op( B ) = B&#39;.
               TRANSB = &#39;C&#39; or &#39;c&#39;,  op( B ) = B&#39;.
            Unchanged on exit.
   M      - INTEGER.
            On entry,  M  specifies  the number  of rows  of the  matrix
            op( A )  and of the  matrix  C.  M  must  be at least  zero.
            Unchanged on exit.
   N      - INTEGER.
            On entry,  N  specifies the number  of columns of the matrix
            op( B ) and the number of columns of the matrix C. N must be
            at least zero.
            Unchanged on exit.
   K      - INTEGER.
            On entry,  K  specifies  the number of columns of the matrix
            op( A ) and the number of rows of the matrix op( B ). K must
            be at least  zero.
            Unchanged on exit.
   ALPHA  - DOUBLE PRECISION.
            On entry, ALPHA specifies the scalar alpha.
            Unchanged on exit.
   A      - DOUBLE PRECISION array of DIMENSION ( LDA, ka ), where ka is
            k  when  TRANSA = &#39;N&#39; or &#39;n&#39;,  and is  m  otherwise.
            Before entry with  TRANSA = &#39;N&#39; or &#39;n&#39;,  the leading  m by k
            part of the array  A  must contain the matrix  A,  otherwise
            the leading  k by m  part of the array  A  must contain  the
            matrix A.
            Unchanged on exit.
   LDA    - INTEGER.
            On entry, LDA specifies the first dimension of A as declared
            in the calling (sub) program. When  TRANSA = &#39;N&#39; or &#39;n&#39; then
            LDA must be at least  max( 1, m ), otherwise  LDA must be at
            least  max( 1, k ).
            Unchanged on exit.
   B      - DOUBLE PRECISION array of DIMENSION ( LDB, kb ), where kb is
            n  when  TRANSB = &#39;N&#39; or &#39;n&#39;,  and is  k  otherwise.
            Before entry with  TRANSB = &#39;N&#39; or &#39;n&#39;,  the leading  k by n
            part of the array  B  must contain the matrix  B,  otherwise
            the leading  n by k  part of the array  B  must contain  the
            matrix B.
            Unchanged on exit.
   LDB    - INTEGER.
            On entry, LDB specifies the first dimension of B as declared
            in the calling (sub) program. When  TRANSB = &#39;N&#39; or &#39;n&#39; then
            LDB must be at least  max( 1, k ), otherwise  LDB must be at
            least  max( 1, n ).
            Unchanged on exit.
   BETA   - DOUBLE PRECISION.
            On entry,  BETA  specifies the scalar  beta.  When  BETA  is
            supplied as zero then C need not be set on input.
            Unchanged on exit.
   C      - DOUBLE PRECISION array of DIMENSION ( LDC, n ).
            Before entry, the leading  m by n  part of the array  C must
            contain the matrix  C,  except when  beta  is zero, in which
            case C need not be set on entry.
            On exit, the array  C  is overwritten by the  m by n  matrix
            ( alpha*op( A )*op( B ) + beta*C ).
   LDC    - INTEGER.
            On entry, LDC specifies the first dimension of C as declared
            in  the  calling  (sub)  program.   LDC  must  be  at  least
            max( 1, m ).
            Unchanged on exit.

   Further Details
   ===============

   Level 3 Blas routine.

   =====================================================================  </pre>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Inputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, :]</td><td>Input matrix A</td></tr>
<tr><td>B[:, :]</td><td>Input matrix B</td></tr>
<tr><td>C[:, :]</td><td>Input matrix C</td></tr>
<tr><td>a</td><td>Factor a</td></tr>
<tr><td>b</td><td>Factor b</td></tr>
<tr><td>transA</td><td>True if transformed A is used</td></tr>
<tr><td>transB</td><td>True if transformed B is used</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Outputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>Cout[size(C, 1), size(C, 2)]</td><td>Matrix Cout</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dpotrf<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica_LinearSystems2.M1bc185b9322a924cpotrfI.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.dpotrf" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica_LinearSystems2.Math.Matrices.LAPACK.dpotrf"></a><a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</a>.dpotrf</h2>
<p>
<b>Computes the Cholesky factorization of a real symmetric positive definite matrix A</b>
</p>
<h3>Information</h3>
<pre>Lapack documentation:

   Purpose
   =======

   DPOTRF computes the Cholesky factorization of a real symmetric
   positive definite matrix A.

   The factorization has the form
      A = U**T * U,  if UPLO = &#39;U&#39;, or
      A = L  * L**T,  if UPLO = &#39;L&#39;,
   where U is an upper triangular matrix and L is lower triangular.

   This is the block version of the algorithm, calling Level 3 BLAS.

   Arguments
   =========

   UPLO    (input) CHARACTER*1
           = &#39;U&#39;:  Upper triangle of A is stored;
           = &#39;L&#39;:  Lower triangle of A is stored.

   N       (input) INTEGER
           The order of the matrix A.  N &gt;= 0.

   A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
           On entry, the symmetric matrix A.  If UPLO = &#39;U&#39;, the leading
           N-by-N upper triangular part of A contains the upper
           triangular part of the matrix A, and the strictly lower
           triangular part of A is not referenced.  If UPLO = &#39;L&#39;, the
           leading N-by-N lower triangular part of A contains the lower
           triangular part of the matrix A, and the strictly upper
           triangular part of A is not referenced.

           On exit, if INFO = 0, the factor U or L from the Cholesky
           factorization A = U**T*U or A = L*L**T.

   LDA     (input) INTEGER
           The leading dimension of the array A.  LDA &gt;= max(1,N).

   INFO    (output) INTEGER
           = 0:  successful exit
           &lt; 0:  if INFO = -i, the i-th argument had an illegal value
           &gt; 0:  if INFO = i, the leading minor of order i is not
                 positive definite, and the factorization could not be
                 completed.

   =====================================================================  </pre>
<p>Extends from Modelica.Icons.Function (Icon for functions).</p>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Inputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, size(A, 1)]</td><td>Real symmetric positive definite matrix A</td></tr>
<tr><td>upper</td><td>True if the upper triangle of A is provided</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Outputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>Acholesky[size(A, 1), size(A, 1)]</td><td>Cholesky factor</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dtrmm<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><a name="Modelica_LinearSystems2.Math.Matrices.LAPACK.dtrmm"></a><a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</a>.dtrmm</h2>
<p>
<b>Blas algorithm to perform B := alpha*op( A )*B, or   B := alpha*B*op( A ) with triangular matrix A</b>
</p>
<h3>Information</h3>
<pre>Lapack documentation:

   Purpose
   =======

   DTRMM  performs one of the matrix-matrix operations
      B := alpha*op( A )*B,   or   B := alpha*B*op( A ),
   where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or
   non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
      op( A ) = A   or   op( A ) = A&#39;.

   Arguments
   ==========

   SIDE   - CHARACTER*1.
            On entry,  SIDE specifies whether  op( A ) multiplies B from
            the left or right as follows:
               SIDE = &#39;L&#39; or &#39;l&#39;   B := alpha*op( A )*B.
               SIDE = &#39;R&#39; or &#39;r&#39;   B := alpha*B*op( A ).
            Unchanged on exit.
   UPLO   - CHARACTER*1.
            On entry, UPLO specifies whether the matrix A is an upper or
            lower triangular matrix as follows:
               UPLO = &#39;U&#39; or &#39;u&#39;   A is an upper triangular matrix.
               UPLO = &#39;L&#39; or &#39;l&#39;   A is a lower triangular matrix.
            Unchanged on exit.
   TRANSA - CHARACTER*1.
            On entry, TRANSA specifies the form of op( A ) to be used in
            the matrix multiplication as follows:
               TRANSA = &#39;N&#39; or &#39;n&#39;   op( A ) = A.
               TRANSA = &#39;T&#39; or &#39;t&#39;   op( A ) = A&#39;.
               TRANSA = &#39;C&#39; or &#39;c&#39;   op( A ) = A&#39;.
            Unchanged on exit.
   DIAG   - CHARACTER*1.
            On entry, DIAG specifies whether or not A is unit triangular
            as follows:
               DIAG = &#39;U&#39; or &#39;u&#39;   A is assumed to be unit triangular.
               DIAG = &#39;N&#39; or &#39;n&#39;   A is not assumed to be unit
                                   triangular.
            Unchanged on exit.
   M      - INTEGER.
            On entry, M specifies the number of rows of B. M must be at
            least zero.
            Unchanged on exit.
   N      - INTEGER.
            On entry, N specifies the number of columns of B.  N must be
            at least zero.
            Unchanged on exit.
   ALPHA  - DOUBLE PRECISION.
            On entry,  ALPHA specifies the scalar  alpha. When  alpha is
            zero then  A is not referenced and  B need not be set before
            entry.
            Unchanged on exit.
   A      - DOUBLE PRECISION array of DIMENSION ( LDA, k ), where k is m
            when  SIDE = &#39;L&#39; or &#39;l&#39;  and is  n  when  SIDE = &#39;R&#39; or &#39;r&#39;.
            Before entry  with  UPLO = &#39;U&#39; or &#39;u&#39;,  the  leading  k by k
            upper triangular part of the array  A must contain the upper
            triangular matrix  and the strictly lower triangular part of
            A is not referenced.
            Before entry  with  UPLO = &#39;L&#39; or &#39;l&#39;,  the  leading  k by k
            lower triangular part of the array  A must contain the lower
            triangular matrix  and the strictly upper triangular part of
            A is not referenced.
            Note that when  DIAG = &#39;U&#39; or &#39;u&#39;,  the diagonal elements of
            A  are not referenced either,  but are assumed to be  unity.
            Unchanged on exit.
   LDA    - INTEGER.
            On entry, LDA specifies the first dimension of A as declared
            in the calling (sub) program.  When  SIDE = &#39;L&#39; or &#39;l&#39;  then
            LDA  must be at least  max( 1, m ),  when  SIDE = &#39;R&#39; or &#39;r&#39;
            then LDA must be at least max( 1, n ).
            Unchanged on exit.
   B      - DOUBLE PRECISION array of DIMENSION ( LDB, n ).
            Before entry,  the leading  m by n part of the array  B must
            contain the matrix  B,  and  on exit  is overwritten  by the
            transformed matrix.
   LDB    - INTEGER.
            On entry, LDB specifies the first dimension of B as declared
            in  the  calling  (sub)  program.   LDB  must  be  at  least
            max( 1, m ).
            Unchanged on exit.

   Further Details
   ===============

   Level 3 Blas routine.

   =====================================================================  </pre>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Inputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, :]</td><td>Input matrix A</td></tr>
<tr><td>B[:, :]</td><td>Input matrix B</td></tr>
<tr><td>alpha</td><td>Factor alpha</td></tr>
<tr><td>right</td><td>True if A is right multiplication</td></tr>
<tr><td>upper</td><td>True if A is upper triangular</td></tr>
<tr><td>trans</td><td>True if op(A) means transposed(A)</td></tr>
<tr><td>unitTriangular</td><td>True if A is unit triangular, i.e. all diagonal elements of A are equal to 1</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Outputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>Bout[size(B, 1), size(B, 2)]</td><td>Matrix Bout=alpha*op( A )*B,   or   B := alpha*B*op( A )</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dtrsm<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><a name="Modelica_LinearSystems2.Math.Matrices.LAPACK.dtrsm"></a><a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</a>.dtrsm</h2>
<p>
<b>Solve one of the matrix equations  op( A )*X = alpha*B,   or   X*op( A ) = alpha*B, where A is triangular matrix. BLAS routine</b>
</p>
<h3>Information</h3>
<pre>Lapack documentation:

   Purpose
   =======

   DTRSM  solves one of the matrix equations
      op( A )*X = alpha*B,   or   X*op( A ) = alpha*B,
   where alpha is a scalar, X and B are m by n matrices, A is a unit, or
   non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
      op( A ) = A   or   op( A ) = A&#39;.
   The matrix X is overwritten on B.
   Arguments
   ==========
   SIDE   - CHARACTER*1.
            On entry, SIDE specifies whether op( A ) appears on the left
            or right of X as follows:
               SIDE = &#39;L&#39; or &#39;l&#39;   op( A )*X = alpha*B.
               SIDE = &#39;R&#39; or &#39;r&#39;   X*op( A ) = alpha*B.
            Unchanged on exit.
   UPLO   - CHARACTER*1.
            On entry, UPLO specifies whether the matrix A is an upper or
            lower triangular matrix as follows:
               UPLO = &#39;U&#39; or &#39;u&#39;   A is an upper triangular matrix.
               UPLO = &#39;L&#39; or &#39;l&#39;   A is a lower triangular matrix.
            Unchanged on exit.
   TRANSA - CHARACTER*1.
            On entry, TRANSA specifies the form of op( A ) to be used in
            the matrix multiplication as follows:
               TRANSA = &#39;N&#39; or &#39;n&#39;   op( A ) = A.
               TRANSA = &#39;T&#39; or &#39;t&#39;   op( A ) = A&#39;.
               TRANSA = &#39;C&#39; or &#39;c&#39;   op( A ) = A&#39;.
            Unchanged on exit.
   DIAG   - CHARACTER*1.
            On entry, DIAG specifies whether or not A is unit triangular
            as follows:
               DIAG = &#39;U&#39; or &#39;u&#39;   A is assumed to be unit triangular.
               DIAG = &#39;N&#39; or &#39;n&#39;   A is not assumed to be unit
                                   triangular.
            Unchanged on exit.
   M      - INTEGER.
            On entry, M specifies the number of rows of B. M must be at
            least zero.
            Unchanged on exit.
   N      - INTEGER.
            On entry, N specifies the number of columns of B.  N must be
            at least zero.
            Unchanged on exit.
   ALPHA  - DOUBLE PRECISION.
            On entry,  ALPHA specifies the scalar  alpha. When  alpha is
            zero then  A is not referenced and  B need not be set before
            entry.
            Unchanged on exit.
   A      - DOUBLE PRECISION array of DIMENSION ( LDA, k ), where k is m
            when  SIDE = &#39;L&#39; or &#39;l&#39;  and is  n  when  SIDE = &#39;R&#39; or &#39;r&#39;.
            Before entry  with  UPLO = &#39;U&#39; or &#39;u&#39;,  the  leading  k by k
            upper triangular part of the array  A must contain the upper
            triangular matrix  and the strictly lower triangular part of
            A is not referenced.
            Before entry  with  UPLO = &#39;L&#39; or &#39;l&#39;,  the  leading  k by k
            lower triangular part of the array  A must contain the lower
            triangular matrix  and the strictly upper triangular part of
            A is not referenced.
            Note that when  DIAG = &#39;U&#39; or &#39;u&#39;,  the diagonal elements of
            A  are not referenced either,  but are assumed to be  unity.
            Unchanged on exit.
   LDA    - INTEGER.
            On entry, LDA specifies the first dimension of A as declared
            in the calling (sub) program.  When  SIDE = &#39;L&#39; or &#39;l&#39;  then
            LDA  must be at least  max( 1, m ),  when  SIDE = &#39;R&#39; or &#39;r&#39;
            then LDA must be at least max( 1, n ).
            Unchanged on exit.
   B      - DOUBLE PRECISION array of DIMENSION ( LDB, n ).
            Before entry,  the leading  m by n part of the array  B must
            contain  the  right-hand  side  matrix  B,  and  on exit  is
            overwritten by the solution matrix  X.
   LDB    - INTEGER.
            On entry, LDB specifies the first dimension of B as declared
            in  the  calling  (sub)  program.   LDB  must  be  at  least
            max( 1, m ).
            Unchanged on exit.

   Further Details
   ===============

   Level 3 Blas routine.

   =====================================================================  </pre>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Inputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, :]</td><td>Input matrix A</td></tr>
<tr><td>B[:, :]</td><td>Input matrix B</td></tr>
<tr><td>alpha</td><td>Factor alpha</td></tr>
<tr><td>right</td><td>True if A is right multiplication</td></tr>
<tr><td>upper</td><td>True if A is upper triangular</td></tr>
<tr><td>trans</td><td>True if op(A) means transposed(A)</td></tr>
<tr><td>unitTriangular</td><td>True if A is unit triangular, i.e. all diagonal elements of A are equal to 1</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Outputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>X[size(B, 1), size(B, 2)]</td><td>Solution X</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE drot<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><a name="Modelica_LinearSystems2.Math.Matrices.LAPACK.drot"></a><a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</a>.drot</h2>
<p>
<b>Applies a plane rotation</b>
</p>
<h3>Information</h3>
<pre>Lapack documentation:

   Purpose
   =======

   applies a plane rotation.

   =====================================================================  </pre>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Inputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>x[:]</td><td>&nbsp;</td></tr>
<tr><td>y[size(x, 1)]</td><td>&nbsp;</td></tr>
<tr><td>c</td><td>&nbsp;</td></tr>
<tr><td>s</td><td>&nbsp;</td></tr>
<tr><td>incx</td><td>&nbsp;</td></tr>
<tr><td>incy</td><td>&nbsp;</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Outputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>xr[size(x, 1)]</td><td>&nbsp;</td></tr>
<tr><td>yr[size(x, 1)]</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE drotg<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><a name="Modelica_LinearSystems2.Math.Matrices.LAPACK.drotg"></a><a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</a>.drotg</h2>
<p>
<b>Construct Givens plane rotation</b>
</p>
<h3>Information</h3>
<pre>Lapack documentation:

   Purpose
   =======

   construct givens plane rotation.

   =====================================================================  </pre>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Inputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>a</td><td>&nbsp;</td></tr>
<tr><td>b</td><td>&nbsp;</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Outputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>c</td><td>&nbsp;</td></tr>
<tr><td>s</td><td>&nbsp;</td></tr>
<tr><td>r</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dtrsv<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><a name="Modelica_LinearSystems2.Math.Matrices.LAPACK.dtrsv"></a><a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</a>.dtrsv</h2>
<p>
<b>Solve one of the matrix equations  op( A )*x = B where A is upper or lower triangular matrix. BLAS routine</b>
</p>
<h3>Information</h3>
<pre>Lapack documentation:

   Purpose
   =======

   DTRSV  solves one of the systems of equations
      A*x = b,   or   A&#39;*x = b,
   where b and x are n element vectors and A is an n by n unit, or
   non-unit, upper or lower triangular matrix.
   No test for singularity or near-singularity is included in this
   routine. Such tests must be performed before calling this routine.
   Arguments
   ==========
   UPLO   - CHARACTER*1.
            On entry, UPLO specifies whether the matrix is an upper or
            lower triangular matrix as follows:
               UPLO = &#39;U&#39; or &#39;u&#39;   A is an upper triangular matrix.
               UPLO = &#39;L&#39; or &#39;l&#39;   A is a lower triangular matrix.
            Unchanged on exit.
   TRANS  - CHARACTER*1.
            On entry, TRANS specifies the equations to be solved as
            follows:
               TRANS = &#39;N&#39; or &#39;n&#39;   A*x = b.
               TRANS = &#39;T&#39; or &#39;t&#39;   A&#39;*x = b.
               TRANS = &#39;C&#39; or &#39;c&#39;   A&#39;*x = b.
            Unchanged on exit.
   DIAG   - CHARACTER*1.
            On entry, DIAG specifies whether or not A is unit
            triangular as follows:
               DIAG = &#39;U&#39; or &#39;u&#39;   A is assumed to be unit triangular.
               DIAG = &#39;N&#39; or &#39;n&#39;   A is not assumed to be unit
                                   triangular.
            Unchanged on exit.
   N      - INTEGER.
            On entry, N specifies the order of the matrix A.
            N must be at least zero.
            Unchanged on exit.
   A      - DOUBLE PRECISION array of DIMENSION ( LDA, n ).
            Before entry with  UPLO = &#39;U&#39; or &#39;u&#39;, the leading n by n
            upper triangular part of the array A must contain the upper
            triangular matrix and the strictly lower triangular part of
            A is not referenced.
            Before entry with UPLO = &#39;L&#39; or &#39;l&#39;, the leading n by n
            lower triangular part of the array A must contain the lower
            triangular matrix and the strictly upper triangular part of
            A is not referenced.
            Note that when  DIAG = &#39;U&#39; or &#39;u&#39;, the diagonal elements of
            A are not referenced either, but are assumed to be unity.
            Unchanged on exit.
   LDA    - INTEGER.
            On entry, LDA specifies the first dimension of A as declared
            in the calling (sub) program. LDA must be at least
            max( 1, n ).
            Unchanged on exit.
   X      - DOUBLE PRECISION array of dimension at least
            ( 1 + ( n - 1 )*abs( INCX ) ).
            Before entry, the incremented array X must contain the n
            element right-hand side vector b. On exit, X is overwritten
            with the solution vector x.
   INCX   - INTEGER.
            On entry, INCX specifies the increment for the elements of
            X. INCX must not be zero.
            Unchanged on exit.

   Further Details
   ===============

   Level 2 Blas routine.

   =====================================================================  </pre>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Inputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, :]</td><td>Input matrix A</td></tr>
<tr><td>b[size(A, 2)]</td><td>Input vector b</td></tr>
<tr><td>upper</td><td>True if A is upper triangular</td></tr>
<tr><td>trans</td><td>True if op(A) means transposed(A)</td></tr>
<tr><td>unitTriangular</td><td>True if A is unit triangular, i.e. all diagonal elements of A are equal to 1</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Outputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>x[size(b, 1)]</td><td>Solution x</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dposv<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica_LinearSystems2.M4a78ae7255915475dposvI.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.dposv" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica_LinearSystems2.Math.Matrices.LAPACK.dposv"></a><a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</a>.dposv</h2>
<p>
<b>Compute the solution to A * X = B, where A is a symmetric positive definite matrix</b>
</p>
<h3>Information</h3>
<pre>Lapack documentation:

   Purpose
   =======

   DPOSV computes the solution to a real system of linear equations
      A * X = B,
   where A is an N-by-N symmetric positive definite matrix and X and B
   are N-by-NRHS matrices.

   The Cholesky decomposition is used to factor A as
      A = U**T* U,  if UPLO = &#39;U&#39;, or
      A = L * L**T,  if UPLO = &#39;L&#39;,
   where U is an upper triangular matrix and L is a lower triangular
   matrix.  The factored form of A is then used to solve the system of
   equations A * X = B.

   Arguments
   =========

   UPLO    (input) CHARACTER*1
           = &#39;U&#39;:  Upper triangle of A is stored;
           = &#39;L&#39;:  Lower triangle of A is stored.

   N       (input) INTEGER
           The number of linear equations, i.e., the order of the
           matrix A.  N &gt;= 0.

   NRHS    (input) INTEGER
           The number of right hand sides, i.e., the number of columns
           of the matrix B.  NRHS &gt;= 0.

   A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
           On entry, the symmetric matrix A.  If UPLO = &#39;U&#39;, the leading
           N-by-N upper triangular part of A contains the upper
           triangular part of the matrix A, and the strictly lower
           triangular part of A is not referenced.  If UPLO = &#39;L&#39;, the
           leading N-by-N lower triangular part of A contains the lower
           triangular part of the matrix A, and the strictly upper
           triangular part of A is not referenced.

           On exit, if INFO = 0, the factor U or L from the Cholesky
           factorization A = U**T*U or A = L*L**T.

   LDA     (input) INTEGER
           The leading dimension of the array A.  LDA &gt;= max(1,N).

   B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)
           On entry, the N-by-NRHS right hand side matrix B.
           On exit, if INFO = 0, the N-by-NRHS solution matrix X.

   LDB     (input) INTEGER
           The leading dimension of the array B.  LDB &gt;= max(1,N).

   INFO    (output) INTEGER
           = 0:  successful exit
           &lt; 0:  if INFO = -i, the i-th argument had an illegal value
           &gt; 0:  if INFO = i, the leading minor of order i of A is not
                 positive definite, so the factorization could not be
                 completed, and the solution has not been computed.

   =====================================================================
</pre>
<p>Extends from Modelica.Icons.Function (Icon for functions).</p>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Inputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, size(A, 1)]</td><td>Real symmetric positive definite matrix A</td></tr>
<tr><td>B[size(A, 2), :]</td><td>Right hand side of A*X = B</td></tr>
<tr><td>upper</td><td>True if the upper triangle of A is provided</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Outputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>X[size(B, 1), size(B, 2)]</td><td>Solution of A*X = B</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dpocon<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><a name="Modelica_LinearSystems2.Math.Matrices.LAPACK.dpocon"></a><a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</a>.dpocon</h2>
<p>
<b>Estimates the reciprocal of the condition number (1-norm) of a real symmetric matrix A using the Cholesky factor</b>
</p>
<h3>Information</h3>
<pre>Lapack documentation:

   Purpose
   =======

   DPOCON estimates the reciprocal of the condition number (in the
   1-norm) of a real symmetric positive definite matrix using the
   Cholesky factorization A = U**T*U or A = L*L**T computed by DPOTRF.

   An estimate is obtained for norm(inv(A)), and the reciprocal of the
   condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).

   Arguments
   =========

   UPLO    (input) CHARACTER*1
           = &#39;U&#39;:  Upper triangle of A is stored;
           = &#39;L&#39;:  Lower triangle of A is stored.

   N       (input) INTEGER
           The order of the matrix A.  N &gt;= 0.

   A       (input) DOUBLE PRECISION array, dimension (LDA,N)
           The triangular factor U or L from the Cholesky factorization
           A = U**T*U or A = L*L**T, as computed by DPOTRF.

   LDA     (input) INTEGER
           The leading dimension of the array A.  LDA &gt;= max(1,N).

   ANORM   (input) DOUBLE PRECISION
           The 1-norm (or infinity-norm) of the symmetric matrix A.

   RCOND   (output) DOUBLE PRECISION
           The reciprocal of the condition number of the matrix A,
           computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
           estimate of the 1-norm of inv(A) computed in this routine.

   WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)

   IWORK   (workspace) INTEGER array, dimension (N)

   INFO    (output) INTEGER
           = 0:  successful exit
           &lt; 0:  if INFO = -i, the i-th argument had an illegal value

   =====================================================================


</pre>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Inputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>cholA[:, size(cholA, 1)]</td><td>Cholesky factor of matrix A</td></tr>
<tr><td>anorm</td><td>Norm of A</td></tr>
<tr><td>upper</td><td>Specifies whether A is upper or lower Cholesky factor</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Outputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>rcond</td><td>Reciprocal condition number of A</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dgelqf<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><a name="Modelica_LinearSystems2.Math.Matrices.LAPACK.dgelqf"></a><a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</a>.dgelqf</h2>
<p>
<b>Compute LQ factorization of a real matrix A=L*Q</b>
</p>
<h3>Information</h3>
<pre>Lapack documentation:

   Purpose
   =======

   DGELQF computes an LQ factorization of a real M-by-N matrix A:
   A = L * Q.

   Arguments
   =========

   M       (input) INTEGER
           The number of rows of the matrix A.  M &gt;= 0.

   N       (input) INTEGER
           The number of columns of the matrix A.  N &gt;= 0.

   A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
           On entry, the M-by-N matrix A.
           On exit, the elements on and below the diagonal of the array
           contain the m-by-min(m,n) lower trapezoidal matrix L (L is
           lower triangular if m &lt;= n); the elements above the diagonal,
           with the array TAU, represent the orthogonal matrix Q as a
           product of elementary reflectors (see Further Details).

   LDA     (input) INTEGER
           The leading dimension of the array A.  LDA &gt;= max(1,M).

   TAU     (output) DOUBLE PRECISION array, dimension (min(M,N))
           The scalar factors of the elementary reflectors (see Further
           Details).

   WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

   LWORK   (input) INTEGER
           The dimension of the array WORK.  LWORK &gt;= max(1,M).
           For optimum performance LWORK &gt;= M*NB, where NB is the
           optimal blocksize.

           If LWORK = -1, then a workspace query is assumed; the routine
           only calculates the optimal size of the WORK array, returns
           this value as the first entry of the WORK array, and no error
           message related to LWORK is issued by XERBLA.

   INFO    (output) INTEGER
           = 0:  successful exit
           &lt; 0:  if INFO = -i, the i-th argument had an illegal value

   Further Details
   ===============

   The matrix Q is represented as a product of elementary reflectors

      Q = H(k) . . . H(2) H(1), where k = min(m,n).

   Each H(i) has the form

      H(i) = I - tau * v * v&#39;

   where tau is a real scalar, and v is a real vector with
   v(1:i-1) = 0 and v(i) = 1; v(i+1:n) is stored on exit in A(i,i+1:n),
   and tau in TAU(i).

   =====================================================================
 </pre>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Inputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, :]</td><td>&nbsp;</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Outputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>Aout[size(A, 1), size(A, 2)]</td><td>The lower triangle contains the m-min(m,n) lower trapezoidal matrix L, the elelments above contain the elementary reflectors</td></tr>
<tr><td>tau[min(size(A, 1), size(A, 2))]</td><td>Scalar factors of the elementary reflectors</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dorglq<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><a name="Modelica_LinearSystems2.Math.Matrices.LAPACK.dorglq"></a><a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</a>.dorglq</h2>
<p>
<b>Generate a matrix Q with orthonormal rows which is defined as the product of elementary reflectors, as returned by DGELQF</b>
</p>
<h3>Information</h3>
<pre>Lapack documentation:

   Purpose
   =======

   DORGLQ generates an M-by-N real matrix Q with orthonormal rows,
   which is defined as the first M rows of a product of K elementary
   reflectors of order N

         Q  =  H(k) . . . H(2) H(1)

   as returned by DGELQF.

   Arguments
   =========

   M       (input) INTEGER
           The number of rows of the matrix Q. M &gt;= 0.

   N       (input) INTEGER
           The number of columns of the matrix Q. N &gt;= M.

   K       (input) INTEGER
           The number of elementary reflectors whose product defines the
           matrix Q. M &gt;= K &gt;= 0.

   A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
           On entry, the i-th row must contain the vector which defines
           the elementary reflector H(i), for i = 1,2,...,k, as returned
           by DGELQF in the first k rows of its array argument A.
           On exit, the M-by-N matrix Q.

   LDA     (input) INTEGER
           The first dimension of the array A. LDA &gt;= max(1,M).

   TAU     (input) DOUBLE PRECISION array, dimension (K)
           TAU(i) must contain the scalar factor of the elementary
           reflector H(i), as returned by DGELQF.

   WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))
           On exit, if INFO = 0, WORK(1) returns the optimal LWORK.

   LWORK   (input) INTEGER
           The dimension of the array WORK. LWORK &gt;= max(1,M).
           For optimum performance LWORK &gt;= M*NB, where NB is
           the optimal blocksize.

           If LWORK = -1, then a workspace query is assumed; the routine
           only calculates the optimal size of the WORK array, returns
           this value as the first entry of the WORK array, and no error
           message related to LWORK is issued by XERBLA.

   INFO    (output) INTEGER
           = 0:  successful exit
           &lt; 0:  if INFO = -i, the i-th argument has an illegal value

   =====================================================================
</pre>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Inputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, :]</td><td>Orthogonal matrix of elementary reflectors</td></tr>
<tr><td>tau[:]</td><td>Scalar factors of the elementary reflectors</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Outputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>Q[size(A, 1), size(A, 2)]</td><td>&nbsp;</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE dtrtri<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="Modelica_LinearSystems2.M625f47d132641243trtriI.png" alt="Modelica_LinearSystems2.Math.Matrices.LAPACK.dtrtri" align="right" style="border: 1px solid" width="80" height="80">
<a name="Modelica_LinearSystems2.Math.Matrices.LAPACK.dtrtri"></a><a href="Modelica_LinearSystems2_Math_Matrices_LAPACK.html#Modelica_LinearSystems2.Math.Matrices.LAPACK"
>Modelica_LinearSystems2.Math.Matrices.LAPACK</a>.dtrtri</h2>
<p>
<b>Computes the inverse of a triangular real matrix A</b>
</p>
<h3>Information</h3>
<pre>Lapack documentation:

   Purpose
   =======

   DTRTRI computes the inverse of a real upper or lower triangular
   matrix A.

   This is the Level 3 BLAS version of the algorithm.

   Arguments
   =========

   UPLO    (input) CHARACTER*1
           = &#39;U&#39;:  A is upper triangular;
           = &#39;L&#39;:  A is lower triangular.

   DIAG    (input) CHARACTER*1
           = &#39;N&#39;:  A is non-unit triangular;
           = &#39;U&#39;:  A is unit triangular.

   N       (input) INTEGER
           The order of the matrix A.  N &gt;= 0.

   A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)
           On entry, the triangular matrix A.  If UPLO = &#39;U&#39;, the
           leading N-by-N upper triangular part of the array A contains
           the upper triangular matrix, and the strictly lower
           triangular part of A is not referenced.  If UPLO = &#39;L&#39;, the
           leading N-by-N lower triangular part of the array A contains
           the lower triangular matrix, and the strictly upper
           triangular part of A is not referenced.  If DIAG = &#39;U&#39;, the
           diagonal elements of A are also not referenced and are
           assumed to be 1.
           On exit, the (triangular) inverse of the original matrix, in
           the same storage format.

   LDA     (input) INTEGER
           The leading dimension of the array A.  LDA &gt;= max(1,N).

   INFO    (output) INTEGER
           = 0: successful exit
           &lt; 0: if INFO = -i, the i-th argument had an illegal value
           &gt; 0: if INFO = i, A(i,i) is exactly zero.  The triangular
                matrix is singular and its inverse can not be computed.

   =====================================================================  </pre>
<p>Extends from Modelica.Icons.Function (Icon for functions).</p>
<h3>Inputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Inputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>A[:, size(A, 1)]</td><td>Real symmetric positive definite matrix A</td></tr>
<tr><td>upper</td><td>True if the upper triangle of A is provided</td></tr>
</table>
<h3>Outputs</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Outputs">
<tr><th>Name</th><th>Description</th></tr>
<tr><td>invA[size(A, 1), size(A, 1)]</td><td>Inverse of A</td></tr>
<tr><td>info</td><td>&nbsp;</td></tr>
</table>
<address>
<a href="http://www.3ds.com/">Automatically generated</a> Fri Sep 12 12:44:59 2014.
</address>
</body>
</html>
